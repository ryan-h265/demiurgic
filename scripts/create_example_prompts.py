#!/usr/bin/env python3
"""
Generate example prompts for coding tasks.

Creates diverse coding prompts and saves them in various formats without
overwriting existing curated examples by default.
"""

import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent.parent))

import argparse
import importlib.util
import json


def _load_prompt_generator():
    """Load PromptGenerator directly from its module to avoid heavy package imports."""
    module_path = Path(__file__).parent.parent / "src" / "distillation" / "prompt_generator.py"
    spec = importlib.util.spec_from_file_location("prompt_generator", module_path)
    module = importlib.util.module_from_spec(spec)
    assert spec and spec.loader  # for type checkers
    spec.loader.exec_module(module)  # type: ignore[arg-type]
    return module.PromptGenerator


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Generate example coding prompts")
    parser.add_argument(
        "--num-prompts",
        type=int,
        default=300,
        help="Number of prompts to generate (default: 300 for broader coverage)",
    )
    parser.add_argument(
        "--seed",
        type=int,
        default=42,
        help="Random seed for reproducibility",
    )
    parser.add_argument(
        "--output-dir",
        type=Path,
        default=Path("prompts/generated_examples"),
        help="Output directory (defaults to a new location to avoid overwriting curated examples)",
    )
    parser.add_argument(
        "--allow-overwrite",
        action="store_true",
        help="Allow writing into a non-empty output directory",
    )
    return parser.parse_args()


def main():
    args = parse_args()

    print("\n" + "="*60)
    print("Generating Example Coding Prompts")
    print("="*60)

    # Create output directory
    output_dir = args.output_dir
    output_dir.mkdir(parents=True, exist_ok=True)

    # Safety: avoid clobbering existing curated examples
    if any(output_dir.iterdir()) and not args.allow_overwrite:
        print(f"\n✖ Output directory '{output_dir}' is not empty. "
              "Use --allow-overwrite to replace contents or choose a new --output-dir.")
        sys.exit(1)

    # Generate prompts
    print(f"\nGenerating {args.num_prompts} prompts using seed {args.seed}...")
    PromptGenerator = _load_prompt_generator()
    generator = PromptGenerator(seed=args.seed)
    prompts = generator.generate_prompts(num_prompts=args.num_prompts)

    print(f"✓ Generated {len(prompts)} prompts\n")

    # Analyze distribution
    categories = {}
    languages = {}
    for p in prompts:
        categories[p['category']] = categories.get(p['category'], 0) + 1
        languages[p['language']] = languages.get(p['language'], 0) + 1

    print("Distribution:")
    print("\nBy category:")
    for cat, count in sorted(categories.items(), key=lambda x: -x[1]):
        print(f"  • {cat}: {count}")

    print("\nBy language:")
    for lang, count in sorted(languages.items(), key=lambda x: -x[1]):
        print(f"  • {lang}: {count}")

    # Save all prompts as JSON
    json_file = output_dir / 'all_prompts.json'
    with open(json_file, 'w') as f:
        json.dump(prompts, f, indent=2)
    print(f"\n✓ Saved all prompts to {json_file}")

    # Save as JSONL (one per line)
    jsonl_file = output_dir / 'all_prompts.jsonl'
    with open(jsonl_file, 'w') as f:
        for p in prompts:
            f.write(json.dumps(p) + '\n')
    print(f"✓ Saved JSONL to {jsonl_file}")

    # Save individual prompt files organized by category
    print("\n✓ Saving individual prompt files...")
    for i, prompt_info in enumerate(prompts, 1):
        category = prompt_info['category']
        language = prompt_info['language']

        # Create category directory
        cat_dir = output_dir / category
        cat_dir.mkdir(exist_ok=True)

        # Save individual prompt file
        filename = f"{i:03d}_{language}.txt"
        prompt_file = cat_dir / filename

        with open(prompt_file, 'w') as f:
            f.write(f"Category: {category}\n")
            f.write(f"Language: {language}\n")
            f.write(f"\n{'='*60}\n\n")
            f.write(prompt_info['prompt'])
            f.write("\n")

    # Create README
    readme_file = output_dir / 'README.md'
    with open(readme_file, 'w') as f:
        f.write("# Example Coding Prompts\n\n")
        f.write(f"This directory contains {len(prompts)} example coding prompts generated by Demiurgic.\n\n")

        f.write("## Files\n\n")
        f.write("- `all_prompts.json` - All prompts in JSON format\n")
        f.write("- `all_prompts.jsonl` - All prompts in JSONL format (one per line)\n")
        f.write("- `<category>/` - Individual prompt files organized by category\n\n")

        f.write("## Distribution\n\n")
        f.write("### By Category\n\n")
        for cat, count in sorted(categories.items(), key=lambda x: -x[1]):
            f.write(f"- **{cat}**: {count} prompts\n")

        f.write("\n### By Language\n\n")
        for lang, count in sorted(languages.items(), key=lambda x: -x[1]):
            f.write(f"- **{lang}**: {count} prompts\n")

        f.write("\n## Categories\n\n")
        f.write("1. **function_implementation** - Basic function writing tasks\n")
        f.write("2. **algorithm** - Algorithm implementation (sorting, searching, etc.)\n")
        f.write("3. **data_structure** - Data structure implementation\n")
        f.write("4. **explanation** - Code explanation and understanding\n")
        f.write("5. **bug_fix** - Find and fix bugs in code\n")
        f.write("6. **refactoring** - Improve code quality\n")
        f.write("7. **real_world** - Practical tasks (file I/O, APIs, etc.)\n")
        f.write("8. **code_review** - Code review and optimization\n\n")

        f.write("## Usage\n\n")
        f.write("Use these prompts to:\n")
        f.write("- Test your model's code generation capabilities\n")
        f.write("- Understand the types of tasks in training data\n")
        f.write("- Generate responses from teacher models\n")
        f.write("- Create evaluation benchmarks\n\n")

        f.write("## Example\n\n")
        f.write("```python\n")
        f.write("import json\n\n")
        f.write("# Load all prompts\n")
        f.write("with open('all_prompts.json', 'r') as f:\n")
        f.write("    prompts = json.load(f)\n\n")
        f.write("# Use a prompt\n")
        f.write("prompt = prompts[0]['prompt']\n")
        f.write("print(prompt)\n")
        f.write("```\n")

    print(f"✓ Created README at {readme_file}")

    # Print some examples
    print("\n" + "="*60)
    print("Example Prompts")
    print("="*60)

    # Show one from each category
    shown_categories = set()
    for prompt_info in prompts:
        cat = prompt_info['category']
        if cat not in shown_categories:
            print(f"\n[{cat.upper()}] ({prompt_info['language']})")
            print("-" * 60)
            print(prompt_info['prompt'][:200] + ("..." if len(prompt_info['prompt']) > 200 else ""))
            shown_categories.add(cat)

            if len(shown_categories) >= 5:  # Show 5 examples
                break

    # Summary
    print("\n" + "="*60)
    print("Summary")
    print("="*60)
    print(f"\n✓ Generated {len(prompts)} diverse coding prompts")
    print(f"✓ {len(categories)} categories")
    print(f"✓ {len(languages)} programming languages")
    print(f"\nSaved to: {output_dir}/")
    print("\nFiles created:")
    print(f"  • all_prompts.json - All prompts in JSON")
    print(f"  • all_prompts.jsonl - All prompts in JSONL")
    print(f"  • README.md - Documentation")
    print(f"  • <category>/*.txt - Individual prompt files")

    print("\nDirectory structure:")
    for cat in sorted(categories.keys()):
        count = categories[cat]
        print(f"  • {cat}/ ({count} prompts)")

    print("\n" + "="*60)
    print("Ready to use!")
    print("="*60)
    print("\nYou can now:")
    print(f"1. Browse prompts in: {output_dir}/")
    print(f"2. Load all prompts: {output_dir}/all_prompts.json")
    print("3. Read individual prompts in category folders")
    print("4. Use these to test your model or generate training data")
    print()


if __name__ == "__main__":
    main()
