{"prompt": "Write Python code to solve: Find all permutations of a string", "response": "python\n```python\nfrom typing import List\n\n\ndef string_permutations(s: str) -> List[str]:\n    \"\"\"Return all permutations of the input string using backtracking.\"\"\"\n    chars = list(s)\n    result: List[str] = []\n\n    def backtrack(start: int) -> None:\n        # When we've placed every character, record the permutation\n        if start == len(chars):\n            result.append(\"\".join(chars))\n            return\n        for i in range(start, len(chars)):\n            # Choose: place chars[i] at the current position\n            chars[start], chars[i] = chars[i], chars[start]\n            backtrack(start + 1)\n            # Undo choice for the next iteration\n            chars[start], chars[i] = chars[i], chars[start]\n\n    backtrack(0)\n    return result\n```\n**Explanation:** Use backtracking to swap each character into the current position and recursively permute the remainder. When the current index reaches the end, join the characters and record one permutation. Swapping in-place keeps memory usage low and avoids extra string allocations on each recursion level.\n**Complexity:** Time: O(n·n!) because there are n! permutations and each requires O(n) to join; Space: O(n) for the recursion stack and character array (output excluded).\n**Example:**\nInput: \"abc\"\nOutput: [\"abc\", \"acb\", \"bac\", \"bca\", \"cba\", \"cab\"]\n**Notes:**\n- Handles repeated characters but will emit duplicate permutations; add a used-set per level to skip duplicates if needed.\n- Works for empty string (returns [\"\"]).\n- Avoids creating new lists on each recursion by swapping in-place.", "category": "algorithm", "language": "python"}
{"prompt": "Write Python code to solve: Find the kth largest element in an array", "response": "python\n```python\nimport heapq\nfrom typing import Iterable, List, Any\n\n\ndef kth_largest(nums: Iterable[int], k: int) -> int:\n    \"\"\"Return the kth largest element using a min-heap of size k.\"\"\"\n    min_heap: List[int] = []\n    for num in nums:\n        heapq.heappush(min_heap, num)\n        # Keep only the k largest seen so far\n        if len(min_heap) > k:\n            heapq.heappop(min_heap)\n    if len(min_heap) < k:\n        raise ValueError(\"k is larger than the number of elements\")\n    return min_heap[0]\n```\n**Explanation:** Iterate through numbers while maintaining a min-heap of the k largest values seen. When the heap grows beyond k, pop the smallest so only the k largest remain. After processing all numbers, the root of the heap is the kth largest.\n**Complexity:** Time: O(n log k); Space: O(k) for the heap.\n**Example:**\nInput: nums = [3, 2, 1, 5, 6, 4], k = 2\nOutput: 5\n**Notes:**\n- Raises ValueError when k exceeds the number of items.\n- For streaming data, this approach still works since it processes items one-by-one.\n- To get kth smallest, invert comparisons or use max-heap via negation.", "category": "algorithm", "language": "python"}
{"prompt": "Write JavaScript code to solve: Find the median of two sorted arrays", "response": "javascript\n```javascript\n/**\n * Find the median of two sorted arrays using binary search on the smaller array.\n * Time: O(log(min(m, n)))\n */\nfunction findMedianSortedArrays(nums1, nums2) {\n  // Ensure nums1 is the smaller array to minimize search space\n  if (nums1.length > nums2.length) return findMedianSortedArrays(nums2, nums1);\n\n  const m = nums1.length;\n  const n = nums2.length;\n  let low = 0;\n  let high = m;\n\n  while (low <= high) {\n    const partitionA = Math.floor((low + high) / 2);\n    const partitionB = Math.floor((m + n + 1) / 2) - partitionA;\n\n    const maxLeftA = partitionA === 0 ? -Infinity : nums1[partitionA - 1];\n    const minRightA = partitionA === m ? Infinity : nums1[partitionA];\n    const maxLeftB = partitionB === 0 ? -Infinity : nums2[partitionB - 1];\n    const minRightB = partitionB === n ? Infinity : nums2[partitionB];\n\n    // Correct partition if left parts contain only smaller elements\n    if (maxLeftA <= minRightB && maxLeftB <= minRightA) {\n      if ((m + n) % 2 === 0) {\n        return (Math.max(maxLeftA, maxLeftB) + Math.min(minRightA, minRightB)) / 2;\n      }\n      return Math.max(maxLeftA, maxLeftB);\n    }\n\n    // Move search window\n    if (maxLeftA > minRightB) {\n      high = partitionA - 1;\n    } else {\n      low = partitionA + 1;\n    }\n  }\n\n  throw new Error('Input arrays are not sorted');\n}\n```\n**Explanation:** Use binary search on the smaller array to find a partition where all elements on the left of both arrays are less than or equal to all elements on the right. Compute partition indices so that left and right halves have equal size (or differ by one). When the partition is valid, derive the median from border elements depending on total parity.\n**Complexity:** Time: O(log(min(m, n))); Space: O(1).\n**Example:**\nInput: nums1 = [1, 3], nums2 = [2]\nOutput: 2\n**Notes:**\n- Throws when arrays are not sorted because the partition conditions will never be satisfied.\n- Handles empty arrays because sentinels ±Infinity guard boundaries.\n- Works for even and odd combined lengths without extra passes.", "category": "algorithm", "language": "javascript"}
{"prompt": "Write Java code to solve: Trapping rain water", "response": "java\n```java\nimport java.util.*;\n\npublic class TrappingRainWater {\n    // Two-pointer approach to compute trapped water\n    public static int trap(int[] height) {\n        int left = 0, right = height.length - 1;\n        int leftMax = 0, rightMax = 0, water = 0;\n\n        while (left < right) {\n            if (height[left] < height[right]) {\n                if (height[left] >= leftMax) {\n                    leftMax = height[left];\n                } else {\n                    water += leftMax - height[left];\n                }\n                left++;\n            } else {\n                if (height[right] >= rightMax) {\n                    rightMax = height[right];\n                } else {\n                    water += rightMax - height[right];\n                }\n                right--;\n            }\n        }\n        return water;\n    }\n}\n```\n**Explanation:** Use two pointers moving inward from both ends. Track the highest wall seen from each side (`leftMax`, `rightMax`). At each step, move the pointer with the smaller height because its max bound is known; accumulate water as the difference between the current bound and the bar height.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\n**Notes:**\n- Handles empty or single-element arrays by returning 0.\n- Avoids overflow by using `int`; use `long` if heights may sum beyond `Integer.MAX_VALUE`.\n- Assumes non-negative heights.", "category": "algorithm", "language": "java"}
{"prompt": "Implement breadth-first search (BFS) in Java with detailed comments", "response": "java\n```java\nimport java.util.*;\n\npublic class BreadthFirstSearch {\n    /**\n     * Perform BFS starting from source on an adjacency-list graph.\n     * @param graph adjacency list where graph[u] contains neighbors of u\n     * @param start starting vertex id\n     * @return list of visited vertices in BFS order\n     */\n    public static List<Integer> bfs(List<List<Integer>> graph, int start) {\n        List<Integer> order = new ArrayList<>();\n        if (graph == null || graph.isEmpty()) return order;\n\n        boolean[] visited = new boolean[graph.size()];\n        Queue<Integer> queue = new ArrayDeque<>();\n\n        visited[start] = true;\n        queue.add(start);\n\n        while (!queue.isEmpty()) {\n            int node = queue.poll();\n            order.add(node);\n            for (int neighbor : graph.get(node)) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true; // mark before enqueue to avoid duplicates\n                    queue.add(neighbor);\n                }\n            }\n        }\n        return order;\n    }\n}\n```\n**Explanation:** Maintain a queue for the frontier and a visited array to avoid revisits. Start by enqueuing the source, then repeatedly pop from the queue, record the node, and enqueue all unvisited neighbors while marking them visited. This visits nodes in increasing distance from the start.\n**Complexity:** Time: O(V + E); Space: O(V) for the visited array and queue.\n**Example:**\nInput: graph = [[1,2],[0,3],[0,3],[1,2]], start = 0\nOutput: [0,1,2,3]\n**Notes:**\n- Works for directed or undirected graphs; neighbors list should reflect directionality.\n- If the start index is invalid, guard appropriately; here graph bounds are assumed valid.\n- To track parent paths, store predecessor array alongside visited.", "category": "algorithm", "language": "java"}
{"prompt": "Write Java code to solve: Find the median of two sorted arrays", "response": "java\n```java\npublic class MedianOfTwoSortedArrays {\n    // Binary search partition approach\n    public static double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        if (nums1.length > nums2.length) {\n            return findMedianSortedArrays(nums2, nums1); // ensure nums1 is smaller\n        }\n\n        int m = nums1.length, n = nums2.length;\n        int low = 0, high = m;\n\n        while (low <= high) {\n            int partitionA = (low + high) / 2;\n            int partitionB = (m + n + 1) / 2 - partitionA;\n\n            int maxLeftA = partitionA == 0 ? Integer.MIN_VALUE : nums1[partitionA - 1];\n            int minRightA = partitionA == m ? Integer.MAX_VALUE : nums1[partitionA];\n            int maxLeftB = partitionB == 0 ? Integer.MIN_VALUE : nums2[partitionB - 1];\n            int minRightB = partitionB == n ? Integer.MAX_VALUE : nums2[partitionB];\n\n            if (maxLeftA <= minRightB && maxLeftB <= minRightA) {\n                if ((m + n) % 2 == 0) {\n                    return (Math.max(maxLeftA, maxLeftB) + Math.min(minRightA, minRightB)) / 2.0;\n                }\n                return Math.max(maxLeftA, maxLeftB);\n            }\n\n            if (maxLeftA > minRightB) {\n                high = partitionA - 1; // move left\n            } else {\n                low = partitionA + 1; // move right\n            }\n        }\n\n        throw new IllegalArgumentException(\"Arrays must be sorted\");\n    }\n}\n```\n**Explanation:** Binary-search the smaller array for a partition that splits the combined arrays into equal (or nearly equal) halves where all left elements are ≤ right elements. Use sentinel values at boundaries. When the correct partition is found, compute the median from border elements depending on parity of total length.\n**Complexity:** Time: O(log(min(m, n))); Space: O(1).\n**Example:**\nInput: nums1 = [1, 3], nums2 = [2, 4]\nOutput: 2.5\n**Notes:**\n- Handles empty arrays due to sentinel values.\n- Throws when inputs are not sorted or sizes zero with k invalid.\n- Uses integer sentinels; adjust to long if values may hit Integer limits.", "category": "algorithm", "language": "java"}
{"prompt": "Write Python code to solve: Trapping rain water", "response": "python\n```python\nfrom typing import List\n\n\ndef trap(height: List[int]) -> int:\n    \"\"\"Compute trapped rain water using two pointers.\"\"\"\n    left, right = 0, len(height) - 1\n    left_max = right_max = water = 0\n\n    while left < right:\n        if height[left] < height[right]:\n            if height[left] >= left_max:\n                left_max = height[left]\n            else:\n                water += left_max - height[left]\n            left += 1\n        else:\n            if height[right] >= right_max:\n                right_max = height[right]\n            else:\n                water += right_max - height[right]\n            right -= 1\n    return water\n```\n**Explanation:** Move two pointers inward, tracking the maximum bar seen from each side. The smaller side determines the water level there, because a taller bar exists on the opposite side. Accumulate water as the difference between the current side's max and its height.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\n**Notes:**\n- Returns 0 for arrays shorter than 3.\n- Works with zero heights; assumes non-negative elevations.\n- For very large sums, switch to `int` -> `float`? `int` in Python is unbounded.", "category": "algorithm", "language": "python"}
{"prompt": "Write Python code to solve: Detect a cycle in a linked list", "response": "python\n```python\nfrom typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val: int, next: Optional[\"ListNode\"] = None):\n        self.val = val\n        self.next = next\n\n\ndef has_cycle(head: Optional[ListNode]) -> bool:\n    \"\"\"Detect a cycle using Floyd's tortoise and hare algorithm.\"\"\"\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow is fast:\n            return True\n    return False\n```\n**Explanation:** Advance two pointers at different speeds; if the fast pointer laps the slow pointer, a cycle exists. If the fast pointer reaches the end, the list terminates without a cycle.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: 1 -> 2 -> 3 -> 4 -> (points back to 2)\nOutput: True\n**Notes:**\n- Works for empty list (`head=None`) and single-node lists.\n- To find the cycle start, reset one pointer to head after detection and step both one at a time.\n- Avoids modifying the list or storing visited nodes.", "category": "algorithm", "language": "python"}
{"prompt": "Write Python code to solve: Find the kth largest element in an array", "response": "python\n```python\nimport heapq\nfrom typing import Iterable, List, Any\n\n\ndef kth_largest(nums: Iterable[int], k: int) -> int:\n    \"\"\"Return the kth largest element using a min-heap of size k.\"\"\"\n    min_heap: List[int] = []\n    for num in nums:\n        heapq.heappush(min_heap, num)\n        # Keep only the k largest seen so far\n        if len(min_heap) > k:\n            heapq.heappop(min_heap)\n    if len(min_heap) < k:\n        raise ValueError(\"k is larger than the number of elements\")\n    return min_heap[0]\n```\n**Explanation:** Iterate through numbers while maintaining a min-heap of the k largest values seen. When the heap grows beyond k, pop the smallest so only the k largest remain. After processing all numbers, the root of the heap is the kth largest.\n**Complexity:** Time: O(n log k); Space: O(k) for the heap.\n**Example:**\nInput: nums = [3, 2, 1, 5, 6, 4], k = 2\nOutput: 5\n**Notes:**\n- Raises ValueError when k exceeds the number of items.\n- For streaming data, this approach still works since it processes items one-by-one.\n- To get kth smallest, invert comparisons or use max-heap via negation.", "category": "algorithm", "language": "python"}
{"prompt": "Write JavaScript code to solve: Trapping rain water", "response": "javascript\n```javascript\n// Two-pointer solution to the trapping rain water problem\nfunction trap(height) {\n  let left = 0;\n  let right = height.length - 1;\n  let leftMax = 0;\n  let rightMax = 0;\n  let water = 0;\n\n  while (left < right) {\n    if (height[left] < height[right]) {\n      leftMax = Math.max(leftMax, height[left]);\n      water += leftMax - height[left];\n      left += 1;\n    } else {\n      rightMax = Math.max(rightMax, height[right]);\n      water += rightMax - height[right];\n      right -= 1;\n    }\n  }\n  return water;\n}\n```\n**Explanation:** Move pointers inward while tracking the maximum bar seen from each side. The smaller side dictates the water level at that position because a taller bound exists on the opposite side. Accumulate the difference between that bound and the current bar height.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: [4,2,0,3,2,5]\nOutput: 9\n**Notes:**\n- Returns 0 for arrays with fewer than 3 bars.\n- Assumes non-negative heights; negative values would break the water interpretation.\n- For large arrays, this still uses constant extra space versus precomputing prefix/suffix maxima.", "category": "algorithm", "language": "javascript"}
{"prompt": "Write Java code to solve: Find all permutations of a string", "response": "java\n```java\nimport java.util.*;\n\npublic class StringPermutations {\n    public static List<String> permutations(String s) {\n        List<String> result = new ArrayList<>();\n        char[] chars = s.toCharArray();\n        backtrack(chars, 0, result);\n        return result;\n    }\n\n    private static void backtrack(char[] chars, int start, List<String> result) {\n        if (start == chars.length) {\n            result.add(new String(chars));\n            return;\n        }\n        for (int i = start; i < chars.length; i++) {\n            swap(chars, start, i);\n            backtrack(chars, start + 1, result);\n            swap(chars, start, i); // restore\n        }\n    }\n\n    private static void swap(char[] arr, int i, int j) {\n        char tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }\n}\n```\n**Explanation:** Convert the string to a mutable character array and use backtracking. For each position, swap each remaining character into place, recurse for the next position, then swap back to restore state. When the position reaches the end, record the permutation.\n**Complexity:** Time: O(n·n!) due to n! permutations and O(n) copy for each; Space: O(n) recursion depth (output excluded).\n**Example:**\nInput: \"abc\"\nOutput: [\"abc\", \"acb\", \"bac\", \"bca\", \"cba\", \"cab\"]\n**Notes:**\n- For duplicate characters, add a `HashSet` at each depth to avoid repeating permutations.\n- Works for empty input (returns list with empty string).\n- Swapping in-place avoids repeated string concatenations.", "category": "algorithm", "language": "java"}
{"prompt": "Write JavaScript code to solve: Word ladder problem", "response": "javascript\n```javascript\n/**\n * Return the length of the shortest transformation sequence from beginWord to endWord.\n * Each step must change one letter and produce a word in wordList.\n */\nfunction wordLadder(beginWord, endWord, wordList) {\n  const wordSet = new Set(wordList);\n  if (!wordSet.has(endWord)) return 0;\n\n  const queue = [[beginWord, 1]]; // [word, steps]\n  const visited = new Set([beginWord]);\n  const alphabet = 'abcdefghijklmnopqrstuvwxyz';\n\n  while (queue.length) {\n    const [word, steps] = queue.shift();\n    if (word === endWord) return steps;\n\n    for (let i = 0; i < word.length; i++) {\n      for (const ch of alphabet) {\n        if (ch === word[i]) continue; // skip identical replacement\n        const next = word.slice(0, i) + ch + word.slice(i + 1);\n        if (wordSet.has(next) && !visited.has(next)) {\n          visited.add(next);\n          queue.push([next, steps + 1]);\n        }\n      }\n    }\n  }\n\n  return 0; // no transformation\n}\n```\n**Explanation:** Use BFS from `beginWord`, exploring all one-letter mutations present in the dictionary. Track visited words to prevent cycles. The first time `endWord` is dequeued gives the shortest transformation length due to BFS ordering.\n**Complexity:** Time: O(N * L * 26) where N is dictionary size and L is word length; Space: O(N) for the set and queue.\n**Example:**\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\nOutput: 5 (hit -> hot -> dot -> dog -> cog)\n**Notes:**\n- Returns 0 when `endWord` is unreachable or missing.\n- Assumes all words are same length; if not, filter beforehand.\n- For better performance, use bidirectional BFS when dictionaries are large.", "category": "algorithm", "language": "javascript"}
{"prompt": "Write Python code to solve: Detect a cycle in a linked list", "response": "python\n```python\nfrom typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val: int, next: Optional[\"ListNode\"] = None):\n        self.val = val\n        self.next = next\n\n\ndef has_cycle(head: Optional[ListNode]) -> bool:\n    \"\"\"Detect a cycle using Floyd's tortoise and hare algorithm.\"\"\"\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow is fast:\n            return True\n    return False\n```\n**Explanation:** Advance two pointers at different speeds; if the fast pointer laps the slow pointer, a cycle exists. If the fast pointer reaches the end, the list terminates without a cycle.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: 1 -> 2 -> 3 -> 4 -> (points back to 2)\nOutput: True\n**Notes:**\n- Works for empty list (`head=None`) and single-node lists.\n- To find the cycle start, reset one pointer to head after detection and step both one at a time.\n- Avoids modifying the list or storing visited nodes.", "category": "algorithm", "language": "python"}
{"prompt": "Implement breadth-first search (BFS) in JavaScript with detailed comments", "response": "javascript\n```javascript\n/**\n * Breadth-first search on an adjacency list graph starting from source.\n * Returns the visitation order.\n */\nfunction bfs(graph, start) {\n  const order = [];\n  if (!graph || graph.length === 0) return order;\n\n  const visited = new Array(graph.length).fill(false);\n  const queue = [];\n  visited[start] = true;\n  queue.push(start);\n\n  while (queue.length) {\n    const node = queue.shift();\n    order.push(node);\n    for (const neighbor of graph[node]) {\n      if (!visited[neighbor]) {\n        visited[neighbor] = true; // mark before enqueue to avoid duplicates\n        queue.push(neighbor);\n      }\n    }\n  }\n  return order;\n}\n```\n**Explanation:** Maintain a queue of frontier nodes. Start with the source, pop nodes in FIFO order, record them, and enqueue all unvisited neighbors while marking them visited immediately. This visits nodes in layers from the start node.\n**Complexity:** Time: O(V + E); Space: O(V) for `visited` and queue.\n**Example:**\nInput: graph = [[1,2],[0,3],[0,3],[1,2]], start = 0\nOutput: [0,1,2,3]\n**Notes:**\n- Works for directed graphs as long as adjacency lists reflect direction.\n- Returns empty list for invalid start indices; add bounds checks as needed.\n- To retrieve shortest paths, store parent pointers alongside visited marks.", "category": "algorithm", "language": "javascript"}
{"prompt": "Write Python code to solve: Trapping rain water", "response": "python\n```python\nfrom typing import List\n\n\ndef trap(height: List[int]) -> int:\n    \"\"\"Compute trapped rain water using two pointers.\"\"\"\n    left, right = 0, len(height) - 1\n    left_max = right_max = water = 0\n\n    while left < right:\n        if height[left] < height[right]:\n            if height[left] >= left_max:\n                left_max = height[left]\n            else:\n                water += left_max - height[left]\n            left += 1\n        else:\n            if height[right] >= right_max:\n                right_max = height[right]\n            else:\n                water += right_max - height[right]\n            right -= 1\n    return water\n```\n**Explanation:** Move two pointers inward, tracking the maximum bar seen from each side. The smaller side determines the water level there, because a taller bar exists on the opposite side. Accumulate water as the difference between the current side's max and its height.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\n**Notes:**\n- Returns 0 for arrays shorter than 3.\n- Works with zero heights; assumes non-negative elevations.\n- For very large sums, switch to `int` -> `float`? `int` in Python is unbounded.", "category": "algorithm", "language": "python"}
{"prompt": "Implement depth-first search (DFS) in C++ with detailed comments", "response": "c++\n```cpp\n#include <vector>\nusing Graph = std::vector<std::vector<int>>;\n\n// Depth-first search traversal returning visitation order\nvoid dfsHelper(const Graph &graph, int node, std::vector<bool> &visited, std::vector<int> &order) {\n    visited[node] = true;\n    order.push_back(node);\n    for (int neighbor : graph[node]) {\n        if (!visited[neighbor]) {\n            dfsHelper(graph, neighbor, visited, order);\n        }\n    }\n}\n\nstd::vector<int> dfs(const Graph &graph, int start) {\n    std::vector<int> order;\n    if (graph.empty()) return order;\n    std::vector<bool> visited(graph.size(), false);\n    dfsHelper(graph, start, visited, order);\n    return order;\n}\n```\n**Explanation:** Recursively explore each vertex, marking it visited to avoid cycles. Append the node when first seen, then recursively visit its neighbors. The helper manages state (visited/order) while the public `dfs` initializes storage and guards empty graphs.\n**Complexity:** Time: O(V + E); Space: O(V) for visited plus recursion stack.\n**Example:**\nInput: graph = {{1,2},{0,3},{0,3},{1,2}}, start = 0\nOutput: [0,1,3,2] (one valid DFS order)\n**Notes:**\n- For deep graphs, convert to iterative stack-based DFS to avoid stack overflow.\n- Works for directed graphs if adjacency reflects direction.\n- Ensure `start` is within bounds; here assumed valid.", "category": "algorithm", "language": "c++"}
{"prompt": "Write Python code to solve: Find the kth largest element in an array", "response": "python\n```python\nimport heapq\nfrom typing import Iterable, List, Any\n\n\ndef kth_largest(nums: Iterable[int], k: int) -> int:\n    \"\"\"Return the kth largest element using a min-heap of size k.\"\"\"\n    min_heap: List[int] = []\n    for num in nums:\n        heapq.heappush(min_heap, num)\n        # Keep only the k largest seen so far\n        if len(min_heap) > k:\n            heapq.heappop(min_heap)\n    if len(min_heap) < k:\n        raise ValueError(\"k is larger than the number of elements\")\n    return min_heap[0]\n```\n**Explanation:** Iterate through numbers while maintaining a min-heap of the k largest values seen. When the heap grows beyond k, pop the smallest so only the k largest remain. After processing all numbers, the root of the heap is the kth largest.\n**Complexity:** Time: O(n log k); Space: O(k) for the heap.\n**Example:**\nInput: nums = [3, 2, 1, 5, 6, 4], k = 2\nOutput: 5\n**Notes:**\n- Raises ValueError when k exceeds the number of items.\n- For streaming data, this approach still works since it processes items one-by-one.\n- To get kth smallest, invert comparisons or use max-heap via negation.", "category": "algorithm", "language": "python"}
{"prompt": "Implement merge sort in Python with detailed comments", "response": "python\n```python\nfrom typing import List\n\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"Return a sorted copy of arr using merge sort.\"\"\"\n    if len(arr) <= 1:\n        return arr[:]\n\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    merged: List[int] = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n    # Append any leftovers (only one of these loops will run)\n    merged.extend(left[i:])\n    merged.extend(right[j:])\n    return merged\n```\n**Explanation:** Recursively split the array into halves until size 1, then merge sorted halves by repeatedly picking the smaller front element. Merging preserves stability and produces a sorted list.\n**Complexity:** Time: O(n log n); Space: O(n) for the merged arrays and recursion stack.\n**Example:**\nInput: [5, 2, 4, 6, 1, 3]\nOutput: [1, 2, 3, 4, 5, 6]\n**Notes:**\n- Produces a new list; to sort in place, copy results back into the original list.\n- Stable sorting: equal elements preserve relative order.\n- Recursion depth is O(log n); for extremely large arrays, consider iterative merge sort.", "category": "algorithm", "language": "python"}
{"prompt": "Implement Dijkstra's shortest path in Python with detailed comments", "response": "python\n```python\nimport heapq\nfrom typing import Dict, List, Tuple\n\nGraph = Dict[str, List[Tuple[str, int]]]\n\n\ndef dijkstra(graph: Graph, source: str) -> Dict[str, int]:\n    \"\"\"Compute shortest path distances from source using Dijkstra's algorithm.\"\"\"\n    dist: Dict[str, int] = {node: float('inf') for node in graph}\n    dist[source] = 0\n    pq: List[Tuple[int, str]] = [(0, source)]\n\n    while pq:\n        current_dist, node = heapq.heappop(pq)\n        # Skip stale entries\n        if current_dist > dist[node]:\n            continue\n        for neighbor, weight in graph[node]:\n            new_dist = current_dist + weight\n            if new_dist < dist.get(neighbor, float('inf')):\n                dist[neighbor] = new_dist\n                heapq.heappush(pq, (new_dist, neighbor))\n    return dist\n```\n**Explanation:** Initialize all distances to infinity except the source. Use a min-heap priority queue keyed by tentative distance. Repeatedly extract the closest node; if the popped distance is stale, skip it. Relax all outgoing edges and push improved distances back onto the heap. Distances only decrease, so the first time a node is finalized its shortest path is known.\n**Complexity:** Time: O((V + E) log V) with the heap; Space: O(V) for distances and heap entries.\n**Example:**\nInput: graph = {'A': [('B', 2), ('C', 5)], 'B': [('C', 1)], 'C': []}, source = 'A'\nOutput: {'A': 0, 'B': 2, 'C': 3}\n**Notes:**\n- Assumes non-negative edge weights; Dijkstra fails with negative edges.\n- If graph is disconnected, unreachable nodes remain at infinity.\n- To reconstruct paths, store predecessors when relaxing edges.", "category": "algorithm", "language": "python"}
{"prompt": "Write JavaScript code to solve: Find the median of two sorted arrays", "response": "javascript\n```javascript\n/**\n * Find the median of two sorted arrays using binary search on the smaller array.\n * Time: O(log(min(m, n)))\n */\nfunction findMedianSortedArrays(nums1, nums2) {\n  // Ensure nums1 is the smaller array to minimize search space\n  if (nums1.length > nums2.length) return findMedianSortedArrays(nums2, nums1);\n\n  const m = nums1.length;\n  const n = nums2.length;\n  let low = 0;\n  let high = m;\n\n  while (low <= high) {\n    const partitionA = Math.floor((low + high) / 2);\n    const partitionB = Math.floor((m + n + 1) / 2) - partitionA;\n\n    const maxLeftA = partitionA === 0 ? -Infinity : nums1[partitionA - 1];\n    const minRightA = partitionA === m ? Infinity : nums1[partitionA];\n    const maxLeftB = partitionB === 0 ? -Infinity : nums2[partitionB - 1];\n    const minRightB = partitionB === n ? Infinity : nums2[partitionB];\n\n    // Correct partition if left parts contain only smaller elements\n    if (maxLeftA <= minRightB && maxLeftB <= minRightA) {\n      if ((m + n) % 2 === 0) {\n        return (Math.max(maxLeftA, maxLeftB) + Math.min(minRightA, minRightB)) / 2;\n      }\n      return Math.max(maxLeftA, maxLeftB);\n    }\n\n    // Move search window\n    if (maxLeftA > minRightB) {\n      high = partitionA - 1;\n    } else {\n      low = partitionA + 1;\n    }\n  }\n\n  throw new Error('Input arrays are not sorted');\n}\n```\n**Explanation:** Use binary search on the smaller array to find a partition where all elements on the left of both arrays are less than or equal to all elements on the right. Compute partition indices so that left and right halves have equal size (or differ by one). When the partition is valid, derive the median from border elements depending on total parity.\n**Complexity:** Time: O(log(min(m, n))); Space: O(1).\n**Example:**\nInput: nums1 = [1, 3], nums2 = [2]\nOutput: 2\n**Notes:**\n- Throws when arrays are not sorted because the partition conditions will never be satisfied.\n- Handles empty arrays because sentinels ±Infinity guard boundaries.\n- Works for even and odd combined lengths without extra passes.", "category": "algorithm", "language": "javascript"}
{"prompt": "Implement dynamic programming for coin change in C++ with detailed comments", "response": "c++\n```cpp\n#include <vector>\n#include <limits>\n\n// Return minimum number of coins needed to make up the amount; -1 if impossible\nint coinChange(const std::vector<int> &coins, int amount) {\n    const int INF = std::numeric_limits<int>::max() / 2; // avoid overflow\n    std::vector<int> dp(amount + 1, INF);\n    dp[0] = 0;\n\n    for (int coin : coins) {\n        for (int a = coin; a <= amount; ++a) {\n            dp[a] = std::min(dp[a], dp[a - coin] + 1);\n        }\n    }\n\n    return dp[amount] == INF ? -1 : dp[amount];\n}\n```\n**Explanation:** Use bottom-up DP where `dp[a]` holds the minimum coins to form amount `a`. Initialize to INF except `dp[0]=0`. For each coin, update reachable amounts by considering using that coin once more (`dp[a - coin] + 1`). The final value indicates the minimum coins or impossibility.\n**Complexity:** Time: O(amount * number_of_coins); Space: O(amount).\n**Example:**\nInput: coins = [1, 2, 5], amount = 11\nOutput: 3 (11 = 5 + 5 + 1)\n**Notes:**\n- Works with unlimited copies of each coin; for 0/1 knapsack variant, iterate amounts downward.\n- Returns -1 when no combination hits the exact amount.\n- To recover which coins were used, maintain a parent array recording the last coin chosen.", "category": "algorithm", "language": "c++"}
{"prompt": "Find and fix the bug in this Java code:\ndef factorial(n):\n    if n == 1:\n        return 1\n    return n * factorial(n-1)\nThe code should not go out of bounds", "response": "java\n```java\npublic class Factorial {\n    // Fix: handle n <= 1 as base case and guard against negatives\n    public static long factorial(int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\");\n        }\n        long result = 1;\n        for (int i = 2; i <= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n}\n```\n**Explanation:** The buggy version recursed without a base case for n == 0 and used Python syntax. Here we provide a Java implementation that iterates from 2 to n, multiplying into a running product. It treats 0! and 1! as 1 and rejects negative inputs.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: n = 5\nOutput: 120\n**Notes:**\n- Returns 1 for n = 0 or n = 1 per factorial definition.\n- Uses `long`; for larger n, switch to `BigInteger` to avoid overflow.\n- Iterative form avoids recursion depth concerns.", "category": "bug_fix", "language": "java"}
{"prompt": "Find and fix the bug in this Java code:\nfor (let i = 0; i <= arr.length; i++) { console.log(arr[i]); }\nThe code should handle n=0 correctly", "response": "java\n```java\nimport java.util.List;\n\npublic class ArrayPrinter {\n    // Fix: iterate with i < size, guard against null/empty arrays\n    public static void print(List<?> list) {\n        if (list == null || list.isEmpty()) {\n            return; // nothing to print, handles n = 0 case\n        }\n        for (int i = 0; i < list.size(); i++) {\n            System.out.println(list.get(i));\n        }\n    }\n}\n```\n**Explanation:** The buggy loop used `<= length`, causing an out-of-bounds access, and did not handle empty inputs. This Java version checks for null or empty lists and iterates with `i < size` to remain within bounds.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: list = [\"a\", \"b\", \"c\"]\nOutput: prints a\\nb\\nc\n**Notes:**\n- Replace `List<?>` with a concrete type if needed.\n- For arrays, adjust signature to accept `T[]` but keep the `< length` condition.\n- Early return keeps behavior safe for n = 0.", "category": "bug_fix", "language": "java"}
{"prompt": "Find and fix the bug in this JavaScript code:\nfor (let i = 0; i <= arr.length; i++) { console.log(arr[i]); }\nThe code should handle n=0 correctly", "response": "javascript\n```javascript\n// Fix: use i < arr.length and handle empty arrays gracefully\nfunction printArray(arr = []) {\n  for (let i = 0; i < arr.length; i++) {\n    console.log(arr[i]);\n  }\n}\n```\n**Explanation:** The original loop ran to `i <= arr.length`, causing an undefined access on the last iteration. This version iterates while `i < arr.length` and defaults to an empty array when none is provided, making n = 0 safe.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: arr = [1, 2]\nOutput: logs 1 then 2\n**Notes:**\n- Works for empty arrays without errors.\n- For large arrays, consider chunked logging to avoid console flooding.\n- If arr can be null/undefined, the default parameter prevents errors.", "category": "bug_fix", "language": "javascript"}
{"prompt": "Find and fix the bug in this Python code:\ndef factorial(n):\n    if n == 1:\n        return 1\n    return n * factorial(n-1)\nThe code should not go out of bounds", "response": "python\n```python\ndef factorial(n: int) -> int:\n    \"\"\"Compute n! with proper base cases and validation.\"\"\"\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result\n```\n**Explanation:** The buggy recursive version missed a base case for n = 0 and risked deep recursion. This iterative implementation validates non-negative input and multiplies from 2 through n, returning 1 for 0! and 1!.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: 5\nOutput: 120\n**Notes:**\n- Raises on negative inputs instead of recursing indefinitely.\n- Python's big integers avoid overflow for moderate n, but results grow quickly.\n- For recursion-based solutions, ensure `n <= 1` base case to avoid runaway calls.", "category": "bug_fix", "language": "python"}
{"prompt": "Find and fix the bug in this Python code:\ndef factorial(n):\n    if n == 1:\n        return 1\n    return n * factorial(n-1)\nThe code should handle n=0 correctly", "response": "python\n```python\ndef factorial(n: int) -> int:\n    \"\"\"Compute n! handling n = 0 safely.\"\"\"\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    if n == 0:\n        return 1\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result\n```\n**Explanation:** Adds the missing base case for n = 0 (0! = 1) and validates input. Iterative multiplication avoids recursion depth and ensures no out-of-bounds behavior.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: 3\nOutput: 6\n**Notes:**\n- For very large n, the result grows quickly; consider using math.prod on a range for brevity.\n- Negative inputs raise a clear error instead of recursing infinitely.\n- For memoization, cache computed values if calling repeatedly.", "category": "bug_fix", "language": "python"}
{"prompt": "Find and fix the bug in this Java code:\nfor (let i = 0; i <= arr.length; i++) { console.log(arr[i]); }\nThe code should handle n=0 correctly", "response": "java\n```java\npublic class SafePrinter {\n    // Fix: iterate with i < arr.length to avoid out-of-bounds, handle empty arrays\n    public static void print(int[] arr) {\n        if (arr == null || arr.length == 0) {\n            return;\n        }\n        for (int i = 0; i < arr.length; i++) {\n            System.out.println(arr[i]);\n        }\n    }\n}\n```\n**Explanation:** Corrects the loop condition from `<= length` to `< length`, preventing access past the last element. It also guards against null or empty arrays so n = 0 is safe.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: arr = {10, 20}\nOutput: prints 10 then 20\n**Notes:**\n- Replace `int` with the desired type as needed.\n- Early return keeps behavior no-op for missing data rather than throwing exceptions.\n- For logging, consider using a logger instead of `System.out`.", "category": "bug_fix", "language": "java"}
{"prompt": "Find and fix the bug in this JavaScript code:\ndef factorial(n):\n    if n == 1:\n        return 1\n    return n * factorial(n-1)\nThe code should not go out of bounds", "response": "javascript\n```javascript\n// Fix: add base cases for n <= 1 and validate input\nfunction factorial(n) {\n  if (n < 0) throw new Error('n must be non-negative');\n  let result = 1;\n  for (let i = 2; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n```\n**Explanation:** The original recursion lacked a base case for n = 0 and used Python syntax. This JavaScript version validates input, iteratively multiplies numbers from 2..n, and returns 1 for 0! and 1!.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: 4\nOutput: 24\n**Notes:**\n- Avoids recursion depth limits common in JS environments.\n- Throws on negative inputs instead of producing undefined behavior.\n- For memoization, cache results if computing factorials repeatedly.", "category": "bug_fix", "language": "javascript"}
{"prompt": "Find and fix the bug in this JavaScript code:\nfor (let i = 0; i <= arr.length; i++) { console.log(arr[i]); }\nThe code should not go out of bounds", "response": "javascript\n```javascript\n// Fix: stop at i < arr.length so we never access out of bounds\nfunction printSafe(arr = []) {\n  for (let i = 0; i < arr.length; i++) {\n    console.log(arr[i]);\n  }\n}\n```\n**Explanation:** The buggy loop used `<= arr.length`, which produced an extra iteration with `undefined`. Using `< arr.length` keeps indices within bounds, and the default parameter covers missing or empty inputs.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: arr = ['x', 'y']\nOutput: logs 'x' then 'y'\n**Notes:**\n- Works fine when `arr` is empty; loop runs zero times.\n- If `arr` may be null/undefined, keep the default or add guards.\n- For asynchronous logging, replace `console.log` accordingly.", "category": "bug_fix", "language": "javascript"}
{"prompt": "Implement a queue in Java with all basic operations", "response": "java\n```java\nimport java.util.NoSuchElementException;\n\npublic class ArrayQueue<T> {\n    private Object[] data;\n    private int head = 0; // points to current front\n    private int tail = 0; // points to next insertion spot\n    private int size = 0;\n\n    public ArrayQueue(int capacity) {\n        data = new Object[Math.max(1, capacity)];\n    }\n\n    public void enqueue(T value) {\n        ensureCapacity();\n        data[tail] = value;\n        tail = (tail + 1) % data.length;\n        size++;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public T dequeue() {\n        if (isEmpty()) throw new NoSuchElementException(\"Queue is empty\");\n        T value = (T) data[head];\n        data[head] = null; // help GC\n        head = (head + 1) % data.length;\n        size--;\n        return value;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public T peek() {\n        if (isEmpty()) throw new NoSuchElementException(\"Queue is empty\");\n        return (T) data[head];\n    }\n\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    public int size() {\n        return size;\n    }\n\n    private void ensureCapacity() {\n        if (size == data.length) {\n            Object[] newData = new Object[data.length * 2];\n            for (int i = 0; i < size; i++) {\n                newData[i] = data[(head + i) % data.length];\n            }\n            data = newData;\n            head = 0;\n            tail = size;\n        }\n    }\n}\n```\n**Explanation:** Implements a circular buffer queue backed by an array. Enqueue writes at `tail` and advances it modulo capacity; dequeue reads from `head`. When full, the array doubles and elements are realigned so head resets to 0. Size tracks occupancy for constant-time operations.\n**Complexity:** Time: O(1) amortized for enqueue/dequeue; Space: O(n) for stored elements.\n**Example:**\nInput: enqueue 1, enqueue 2, dequeue -> 1, peek -> 2\nOutput: queue order [2]\n**Notes:**\n- Throws `NoSuchElementException` when peeking/dequeuing an empty queue.\n- Generic storage uses Object array with unchecked casts; acceptable in Java due to type erasure.\n- For thread safety, wrap methods with synchronization or use `ConcurrentLinkedQueue`.", "category": "data_structure", "language": "java"}
{"prompt": "Implement a graph in Python with efficient lookup and insertion", "response": "python\n```python\nfrom collections import defaultdict\nfrom typing import Dict, List\n\n\nclass Graph:\n    def __init__(self) -> None:\n        # adjacency list: node -> list of neighbors\n        self.adj: Dict[str, List[str]] = defaultdict(list)\n\n    def add_edge(self, u: str, v: str, bidirectional: bool = False) -> None:\n        \"\"\"Add an edge u->v; optionally add v->u.\"\"\"\n        self.adj[u].append(v)\n        if bidirectional:\n            self.adj[v].append(u)\n\n    def neighbors(self, node: str) -> List[str]:\n        return list(self.adj.get(node, []))\n\n    def has_edge(self, u: str, v: str) -> bool:\n        return v in self.adj.get(u, [])\n```\n**Explanation:** Store the graph as a `defaultdict` of adjacency lists for O(1) insertion and average O(deg) neighbor lookup. `add_edge` appends to the source's list and can optionally add the reverse edge for undirected graphs. Helper methods expose neighbor retrieval and edge existence checks.\n**Complexity:** Time: O(1) average for insertion, O(deg(v)) to list neighbors; Space: O(V + E).\n**Example:**\nInput: add_edge('A','B'), add_edge('B','C', bidirectional=True)\nOutput: neighbors('B') -> ['C', 'A']\n**Notes:**\n- Use sets instead of lists if you want O(1) edge existence checks and no duplicates.\n- Node identifiers are strings here but can be any hashable type.\n- Extend with weight maps (dict of neighbor -> weight) for weighted graphs.", "category": "data_structure", "language": "python"}
{"prompt": "Implement a stack in Java with insert, delete, and search operations", "response": "java\n```java\nimport java.util.ArrayList;\nimport java.util.EmptyStackException;\n\npublic class Stack<T> {\n    private final ArrayList<T> data = new ArrayList<>();\n\n    public void push(T value) {\n        data.add(value);\n    }\n\n    public T pop() {\n        if (data.isEmpty()) throw new EmptyStackException();\n        return data.remove(data.size() - 1);\n    }\n\n    public T peek() {\n        if (data.isEmpty()) throw new EmptyStackException();\n        return data.get(data.size() - 1);\n    }\n\n    public boolean isEmpty() {\n        return data.isEmpty();\n    }\n\n    public int search(T value) {\n        // returns 1-based position from the top, -1 if not found (mimics java.util.Stack)\n        for (int i = data.size() - 1, pos = 1; i >= 0; i--, pos++) {\n            if ((value == null && data.get(i) == null) || (value != null && value.equals(data.get(i)))) {\n                return pos;\n            }\n        }\n        return -1;\n    }\n}\n```\n**Explanation:** Wraps an `ArrayList` to provide stack semantics. Push appends; pop and peek operate on the last element, throwing when empty. `search` walks downward from the top to find a value, returning its 1-based offset similar to `java.util.Stack`.\n**Complexity:** Time: O(1) for push/pop/peek, O(n) for search; Space: O(n).\n**Example:**\nInput: push 1, push 2, peek -> 2, pop -> 2\nOutput: stack contains [1]\n**Notes:**\n- Not thread-safe; synchronize externally if needed.\n- Accepts null values; equality check handles null safely.\n- For capacity-sensitive use, consider pre-sizing the ArrayList.", "category": "data_structure", "language": "java"}
{"prompt": "Implement a heap in Python with efficient lookup and insertion", "response": "python\n```python\nimport heapq\nfrom typing import List, Optional, TypeVar\n\nT = TypeVar(\"T\")\n\n\nclass MinHeap:\n    def __init__(self) -> None:\n        self._data: List[T] = []\n\n    def push(self, item: T) -> None:\n        heapq.heappush(self._data, item)\n\n    def pop(self) -> T:\n        if not self._data:\n            raise IndexError(\"pop from empty heap\")\n        return heapq.heappop(self._data)\n\n    def peek(self) -> Optional[T]:\n        return self._data[0] if self._data else None\n\n    def __len__(self) -> int:  # allows len(heap)\n        return len(self._data)\n```\n**Explanation:** Wraps Python's `heapq` to provide push, pop, and peek with O(log n) insertion/removal and O(1) access to the smallest element. Under the hood, `heapq` maintains the binary heap in a list.\n**Complexity:** Time: O(log n) for push/pop, O(1) for peek; Space: O(n).\n**Example:**\nInput: push 3, push 1, push 2, peek -> 1, pop -> 1\nOutput: remaining heap [2, 3]\n**Notes:**\n- `heapq` implements a min-heap; invert keys for max-heap behavior.\n- `peek` returns None when empty; `pop` raises an IndexError.\n- To support decrease-key, push a new pair (priority, value) and lazily discard stale entries on pop.", "category": "data_structure", "language": "python"}
{"prompt": "Implement a hash table in Java with all basic operations", "response": "java\n```java\nimport java.util.*;\n\npublic class HashTable<K, V> {\n    private static final double LOAD_FACTOR = 0.75;\n    private List<Entry<K, V>>[] buckets;\n    private int size = 0;\n\n    @SuppressWarnings(\"unchecked\")\n    public HashTable(int capacity) {\n        buckets = new List[Math.max(1, capacity)];\n    }\n\n    public V put(K key, V value) {\n        ensureCapacity();\n        int idx = index(key);\n        if (buckets[idx] == null) buckets[idx] = new LinkedList<>();\n        for (Entry<K, V> e : buckets[idx]) {\n            if (Objects.equals(e.key, key)) {\n                V old = e.value;\n                e.value = value;\n                return old;\n            }\n        }\n        buckets[idx].add(new Entry<>(key, value));\n        size++;\n        return null;\n    }\n\n    public V get(K key) {\n        int idx = index(key);\n        List<Entry<K, V>> bucket = buckets[idx];\n        if (bucket == null) return null;\n        for (Entry<K, V> e : bucket) {\n            if (Objects.equals(e.key, key)) return e.value;\n        }\n        return null;\n    }\n\n    public V remove(K key) {\n        int idx = index(key);\n        List<Entry<K, V>> bucket = buckets[idx];\n        if (bucket == null) return null;\n        Iterator<Entry<K, V>> it = bucket.iterator();\n        while (it.hasNext()) {\n            Entry<K, V> e = it.next();\n            if (Objects.equals(e.key, key)) {\n                it.remove();\n                size--;\n                return e.value;\n            }\n        }\n        return null;\n    }\n\n    public boolean containsKey(K key) {\n        return get(key) != null;\n    }\n\n    public int size() {\n        return size;\n    }\n\n    private int index(K key) {\n        return (key == null ? 0 : key.hashCode() & 0x7fffffff) % buckets.length;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void ensureCapacity() {\n        if (size >= buckets.length * LOAD_FACTOR) {\n            List<Entry<K, V>>[] old = buckets;\n            buckets = new List[old.length * 2];\n            size = 0;\n            for (List<Entry<K, V>> bucket : old) {\n                if (bucket == null) continue;\n                for (Entry<K, V> e : bucket) {\n                    put(e.key, e.value); // rehash\n                }\n            }\n        }\n    }\n\n    private static class Entry<K, V> {\n        final K key;\n        V value;\n        Entry(K key, V value) { this.key = key; this.value = value; }\n    }\n}\n```\n**Explanation:** Implements a hash table with separate chaining for collisions. Buckets are lists storing key-value entries. `put` inserts or updates an entry, `get` retrieves by linear scan of the bucket, and `remove` deletes while maintaining size. The table resizes (rehashes) when the load factor exceeds 0.75.\n**Complexity:** Time: O(1) average for put/get/remove; worst-case O(n) if all keys collide. Space: O(n) for entries and bucket array.\n**Example:**\nInput: put(\"a\",1), put(\"b\",2), get(\"a\")\nOutput: 1\n**Notes:**\n- Uses separate chaining; for open addressing adjust indexing strategy accordingly.\n- `containsKey` treats `null` value as absent; adapt if null values should be stored.\n- Hash quality depends on `hashCode`/`equals` implementations of K.", "category": "data_structure", "language": "java"}
{"prompt": "Implement a queue in Python with insert, delete, and search operations", "response": "python\n```python\nfrom collections import deque\nfrom typing import Deque, Generic, Iterable, Optional, TypeVar\n\nT = TypeVar(\"T\")\n\n\nclass Queue(Generic[T]):\n    def __init__(self, items: Optional[Iterable[T]] = None) -> None:\n        self._data: Deque[T] = deque(items or [])\n\n    def enqueue(self, item: T) -> None:\n        self._data.append(item)\n\n    def dequeue(self) -> T:\n        if not self._data:\n            raise IndexError(\"dequeue from empty queue\")\n        return self._data.popleft()\n\n    def peek(self) -> Optional[T]:\n        return self._data[0] if self._data else None\n\n    def search(self, item: T) -> int:\n        \"\"\"Return zero-based index of item, or -1 if not found.\"\"\"\n        for idx, val in enumerate(self._data):\n            if val == item:\n                return idx\n        return -1\n\n    def __len__(self) -> int:\n        return len(self._data)\n```\n**Explanation:** Wraps a `deque` for O(1) enqueue at the tail and dequeue at the head. Provides peek for front inspection and a linear search to find an item's index. The constructor optionally seeds the queue with initial items.\n**Complexity:** Time: O(1) for enqueue/dequeue/peek, O(n) for search; Space: O(n).\n**Example:**\nInput: enqueue 1, enqueue 2, dequeue -> 1, search(2) -> 0\nOutput: queue contains [2]\n**Notes:**\n- Raises on dequeue of empty queue to signal misuse; adjust to return None if preferred.\n- Equality in `search` relies on `==`; customize for identity checks if needed.\n- Deque preserves order; for max/min retrieval, pair with a monotonic queue.", "category": "data_structure", "language": "python"}
{"prompt": "Implement a queue in C++ with insert, delete, and search operations", "response": "c++\n```cpp\n#include <deque>\n#include <stdexcept>\n#include <algorithm>\n\ntemplate <typename T>\nclass Queue {\npublic:\n    void enqueue(const T &value) {\n        data_.push_back(value);\n    }\n\n    T dequeue() {\n        if (data_.empty()) throw std::out_of_range(\"dequeue from empty queue\");\n        T front = data_.front();\n        data_.pop_front();\n        return front;\n    }\n\n    const T &peek() const {\n        if (data_.empty()) throw std::out_of_range(\"peek from empty queue\");\n        return data_.front();\n    }\n\n    int search(const T &value) const {\n        auto it = std::find(data_.begin(), data_.end(), value);\n        return it == data_.end() ? -1 : static_cast<int>(std::distance(data_.begin(), it));\n    }\n\n    bool empty() const { return data_.empty(); }\n    std::size_t size() const { return data_.size(); }\n\nprivate:\n    std::deque<T> data_;\n};\n```\n**Explanation:** Uses `std::deque` for O(1) insertion at the back and removal from the front. Provides peek to inspect the front element and a linear search to find an element's index. Exceptions signal misuse on empty operations.\n**Complexity:** Time: O(1) for enqueue/dequeue/peek, O(n) for search; Space: O(n).\n**Example:**\nInput: enqueue 10, enqueue 20, peek -> 10, dequeue -> 10\nOutput: queue now holds [20]\n**Notes:**\n- Throws `std::out_of_range` on invalid operations; catch as needed.\n- To support move-only types, add overloads taking rvalue references.\n- For thread safety, wrap operations with mutexes.", "category": "data_structure", "language": "c++"}
