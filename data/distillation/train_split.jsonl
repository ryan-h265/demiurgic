{"prompt": "Implement a hash table in Java with efficient lookup and insertion", "response": "java\n```java\nimport java.util.*;\n\npublic class SimpleHashTable<K, V> {\n    private static final double LOAD_FACTOR = 0.75;\n    private List<Entry<K, V>>[] buckets;\n    private int size = 0;\n\n    @SuppressWarnings(\"unchecked\")\n    public SimpleHashTable(int capacity) {\n        buckets = new List[Math.max(1, capacity)];\n    }\n\n    public void put(K key, V value) {\n        ensureCapacity();\n        int idx = index(key);\n        if (buckets[idx] == null) buckets[idx] = new LinkedList<>();\n        for (Entry<K, V> e : buckets[idx]) {\n            if (Objects.equals(e.key, key)) {\n                e.value = value;\n                return;\n            }\n        }\n        buckets[idx].add(new Entry<>(key, value));\n        size++;\n    }\n\n    public V get(K key) {\n        List<Entry<K, V>> bucket = buckets[index(key)];\n        if (bucket == null) return null;\n        for (Entry<K, V> e : bucket) {\n            if (Objects.equals(e.key, key)) return e.value;\n        }\n        return null;\n    }\n\n    public boolean containsKey(K key) {\n        return get(key) != null;\n    }\n\n    public int size() {\n        return size;\n    }\n\n    private int index(K key) {\n        return (key == null ? 0 : key.hashCode() & 0x7fffffff) % buckets.length;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void ensureCapacity() {\n        if (size >= buckets.length * LOAD_FACTOR) {\n            List<Entry<K, V>>[] old = buckets;\n            buckets = new List[old.length * 2];\n            size = 0;\n            for (List<Entry<K, V>> bucket : old) {\n                if (bucket == null) continue;\n                for (Entry<K, V> e : bucket) {\n                    put(e.key, e.value);\n                }\n            }\n        }\n    }\n\n    private static class Entry<K, V> {\n        K key;\n        V value;\n        Entry(K key, V value) { this.key = key; this.value = value; }\n    }\n}\n```\n**Explanation:** A lightweight hash table using separate chaining. Keys hash to bucket indices, and collisions are stored in linked lists. Insertions update existing keys or append new entries; lookups scan the bucket for the matching key. Capacity doubles when the load factor is exceeded to keep operations near O(1).\n**Complexity:** Time: O(1) average for put/get/contains, worst-case O(n) on poor hashing; Space: O(n).\n**Example:**\nInput: put(\"id\", 7); get(\"id\")\nOutput: 7\n**Notes:**\n- Stores null keys by mapping them to bucket 0; adjust if null keys are disallowed.\n- Resize strategy keeps performance predictable; tune load factor for memory vs speed trade-offs.\n- Not synchronized; wrap with external locks for concurrent use.", "category": "data_structure", "language": "java"}
{"prompt": "Explain the time and space complexity of binary search", "response": "plaintext\n```text\nBinary search repeatedly halves the search space in a sorted array by comparing the target to the middle element and discarding one half each step.\n```\n**Explanation:** Each comparison discards half of the remaining elements, so the number of iterations grows with the logarithm of the input size. It requires the data to be sorted to safely skip halves.\n**Complexity:** Time: O(log n); Space: O(1) for iterative implementation (O(log n) if implemented recursively due to call stack).\n**Example:**\nInput: nums = [1, 3, 5, 7, 9], target = 7\nOutput: index 3\n**Notes:**\n- Sorting upfront costs O(n log n) if the array is unsorted.\n- Recursive forms add call-stack overhead; iterative keeps constant space.\n- Not suitable for unsorted data without preprocessing.", "category": "explanation", "language": "unknown"}
{"prompt": "Explain what this JavaScript code does and how it works:\nreduce((acc, x) => acc + x, [1, 2, 3, 4], 0)", "response": "javascript\n```javascript\n// Sums the numbers in the array starting from an initial accumulator of 0\nconst sum = [1, 2, 3, 4].reduce((acc, x) => acc + x, 0);\n```\n**Explanation:** `Array.prototype.reduce` walks the array left to right, passing the accumulator and current element to the callback. Starting at 0, it adds each value, so the accumulator evolves as 0 -> 1 -> 3 -> 6 -> 10, producing the total sum.\n**Complexity:** Time: O(n) over the array length; Space: O(1) auxiliary.\n**Example:**\nInput: [1, 2, 3, 4]\nOutput: 10\n**Notes:**\n- Without the initial `0`, the first element becomes the initial accumulator.\n- Callback can implement other folds (products, min/max, object aggregation, etc.).\n- For empty arrays, an initial value is required or reduce will throw.", "category": "explanation", "language": "javascript"}
{"prompt": "Explain the time and space complexity of binary search", "response": "plaintext\n```text\nBinary search repeatedly halves the search space in a sorted array by comparing the target to the middle element and discarding one half each step.\n```\n**Explanation:** Each comparison discards half of the remaining elements, so the number of iterations grows with the logarithm of the input size. It requires the data to be sorted to safely skip halves.\n**Complexity:** Time: O(log n); Space: O(1) for iterative implementation (O(log n) if implemented recursively due to call stack).\n**Example:**\nInput: nums = [1, 3, 5, 7, 9], target = 7\nOutput: index 3\n**Notes:**\n- Sorting upfront costs O(n log n) if the array is unsorted.\n- Recursive forms add call-stack overhead; iterative keeps constant space.\n- Not suitable for unsorted data without preprocessing.", "category": "explanation", "language": "unknown"}
{"prompt": "Explain what this JavaScript code does and how it works:\nlist(map(lambda x: x**2, filter(lambda x: x % 2 == 0, range(10))))", "response": "javascript\n```javascript\n// Equivalent behavior in JavaScript\nconst result = Array.from({ length: 10 }, (_, i) => i)\n  .filter(x => x % 2 === 0)\n  .map(x => x ** 2);\n```\n**Explanation:** The original expression filters numbers 0 through 9 to keep only even values, then maps each to its square, finally materializing the results in a list. The JavaScript translation above mirrors that pipeline: generate 0..9, filter by parity, then square.\n**Complexity:** Time: O(n) where n is the input range length; Space: O(n) for the resulting array.\n**Example:**\nInput: range 0..9\nOutput: [0, 4, 16, 36, 64]\n**Notes:**\n- Uses `**` for exponentiation; replace with `Math.pow` for older runtimes.\n- Composition order matters: filtering first avoids unnecessary work during mapping.\n- For large streams, use lazy iterators to avoid allocating intermediate arrays.", "category": "explanation", "language": "javascript"}
{"prompt": "Explain the time and space complexity of binary search", "response": "plaintext\n```text\nBinary search repeatedly halves the search space in a sorted array by comparing the target to the middle element and discarding one half each step.\n```\n**Explanation:** Each comparison discards half of the remaining elements, so the number of iterations grows with the logarithm of the input size. It requires the data to be sorted to safely skip halves.\n**Complexity:** Time: O(log n); Space: O(1) for iterative implementation (O(log n) if implemented recursively due to call stack).\n**Example:**\nInput: nums = [1, 3, 5, 7, 9], target = 7\nOutput: index 3\n**Notes:**\n- Sorting upfront costs O(n log n) if the array is unsorted.\n- Recursive forms add call-stack overhead; iterative keeps constant space.\n- Not suitable for unsorted data without preprocessing.", "category": "explanation", "language": "unknown"}
{"prompt": "Explain the time and space complexity of DFS and BFS", "response": "plaintext\n```text\nDFS explores a branch as deep as possible before backtracking; BFS explores neighbors level by level using a queue.\n```\n**Explanation:** On a graph with V vertices and E edges, both traverse each edge and vertex at most once. DFS uses a stack (explicit or recursion) to dive deep; BFS uses a queue to fan out by distance from the start.\n**Complexity:** Time: O(V + E) for both; Space: O(V) for visited plus O(V) recursion stack for DFS or queue for BFS.\n**Example:**\nInput: graph = {0:[1,2], 1:[3], 2:[3], 3:[]}, start = 0\nOutput DFS order: [0,1,3,2]; BFS order: [0,1,2,3]\n**Notes:**\n- BFS finds shortest paths in unweighted graphs; DFS does not guarantee shortest routes.\n- Recursive DFS may overflow on very deep graphs; use an explicit stack if needed.\n- Space dominates when the frontier (BFS) or recursion depth (DFS) grows to O(V).", "category": "explanation", "language": "unknown"}
{"prompt": "Explain the time and space complexity of binary search", "response": "plaintext\n```text\nBinary search repeatedly halves the search space in a sorted array by comparing the target to the middle element and discarding one half each step.\n```\n**Explanation:** Each comparison discards half of the remaining elements, so the number of iterations grows with the logarithm of the input size. It requires the data to be sorted to safely skip halves.\n**Complexity:** Time: O(log n); Space: O(1) for iterative implementation (O(log n) if implemented recursively due to call stack).\n**Example:**\nInput: nums = [1, 3, 5, 7, 9], target = 7\nOutput: index 3\n**Notes:**\n- Sorting upfront costs O(n log n) if the array is unsorted.\n- Recursive forms add call-stack overhead; iterative keeps constant space.\n- Not suitable for unsorted data without preprocessing.", "category": "explanation", "language": "unknown"}
{"prompt": "Explain the time and space complexity of DFS and BFS", "response": "plaintext\n```text\nDFS explores a branch as deep as possible before backtracking; BFS explores neighbors level by level using a queue.\n```\n**Explanation:** On a graph with V vertices and E edges, both traverse each edge and vertex at most once. DFS uses a stack (explicit or recursion) to dive deep; BFS uses a queue to fan out by distance from the start.\n**Complexity:** Time: O(V + E) for both; Space: O(V) for visited plus O(V) recursion stack for DFS or queue for BFS.\n**Example:**\nInput: graph = {0:[1,2], 1:[3], 2:[3], 3:[]}, start = 0\nOutput DFS order: [0,1,3,2]; BFS order: [0,1,2,3]\n**Notes:**\n- BFS finds shortest paths in unweighted graphs; DFS does not guarantee shortest routes.\n- Recursive DFS may overflow on very deep graphs; use an explicit stack if needed.\n- Space dominates when the frontier (BFS) or recursion depth (DFS) grows to O(V).", "category": "explanation", "language": "unknown"}
{"prompt": "Explain what this Python code does and how it works:\nreduce((acc, x) => acc + x, [1, 2, 3, 4], 0)", "response": "python\n```python\nfrom functools import reduce\n\n# Using Python's reduce to sum the list\nresult = reduce(lambda acc, x: acc + x, [1, 2, 3, 4], 0)\n```\n**Explanation:** `reduce` applies the lambda cumulatively from left to right. Starting at 0, it adds each element: (((0 + 1) + 2) + 3) + 4, resulting in 10. The arrow syntax shown in the prompt is JavaScript-style, but the behavior is equivalent to the Python example above.\n**Complexity:** Time: O(n); Space: O(1) auxiliary.\n**Example:**\nInput: [1, 2, 3, 4]\nOutput: 10\n**Notes:**\n- Always supply an initial value when the list might be empty to avoid `TypeError`.\n- For readability, `sum([1, 2, 3, 4])` is preferred when simply adding numbers.\n- The lambda can be replaced with any associative operation (product, max, merging dicts, etc.).", "category": "explanation", "language": "javascript"}
{"prompt": "Explain the time and space complexity of binary search", "response": "plaintext\n```text\nBinary search repeatedly halves the search space in a sorted array by comparing the target to the middle element and discarding one half each step.\n```\n**Explanation:** Each comparison discards half of the remaining elements, so the number of iterations grows with the logarithm of the input size. It requires the data to be sorted to safely skip halves.\n**Complexity:** Time: O(log n); Space: O(1) for iterative implementation (O(log n) if implemented recursively due to call stack).\n**Example:**\nInput: nums = [1, 3, 5, 7, 9], target = 7\nOutput: index 3\n**Notes:**\n- Sorting upfront costs O(n log n) if the array is unsorted.\n- Recursive forms add call-stack overhead; iterative keeps constant space.\n- Not suitable for unsorted data without preprocessing.", "category": "explanation", "language": "unknown"}
{"prompt": "Explain what this Python code does and how it works:\nreduce((acc, x) => acc + x, [1, 2, 3, 4], 0)", "response": "python\n```python\nfrom functools import reduce\n\n# Using Python's reduce to sum the list\nresult = reduce(lambda acc, x: acc + x, [1, 2, 3, 4], 0)\n```\n**Explanation:** `reduce` applies the lambda cumulatively from left to right. Starting at 0, it adds each element: (((0 + 1) + 2) + 3) + 4, resulting in 10. The arrow syntax shown in the prompt is JavaScript-style, but the behavior is equivalent to the Python example above.\n**Complexity:** Time: O(n); Space: O(1) auxiliary.\n**Example:**\nInput: [1, 2, 3, 4]\nOutput: 10\n**Notes:**\n- Always supply an initial value when the list might be empty to avoid `TypeError`.\n- For readability, `sum([1, 2, 3, 4])` is preferred when simply adding numbers.\n- The lambda can be replaced with any associative operation (product, max, merging dicts, etc.).", "category": "explanation", "language": "javascript"}
{"prompt": "Explain what this Python code does and how it works:\nreduce((acc, x) => acc + x, [1, 2, 3, 4], 0)", "response": "python\n```python\nfrom functools import reduce\n\n# Using Python's reduce to sum the list\nresult = reduce(lambda acc, x: acc + x, [1, 2, 3, 4], 0)\n```\n**Explanation:** `reduce` applies the lambda cumulatively from left to right. Starting at 0, it adds each element: (((0 + 1) + 2) + 3) + 4, resulting in 10. The arrow syntax shown in the prompt is JavaScript-style, but the behavior is equivalent to the Python example above.\n**Complexity:** Time: O(n); Space: O(1) auxiliary.\n**Example:**\nInput: [1, 2, 3, 4]\nOutput: 10\n**Notes:**\n- Always supply an initial value when the list might be empty to avoid `TypeError`.\n- For readability, `sum([1, 2, 3, 4])` is preferred when simply adding numbers.\n- The lambda can be replaced with any associative operation (product, max, merging dicts, etc.).", "category": "explanation", "language": "javascript"}
{"prompt": "Explain the time and space complexity of DFS and BFS", "response": "plaintext\n```text\nDFS explores a branch as deep as possible before backtracking; BFS explores neighbors level by level using a queue.\n```\n**Explanation:** On a graph with V vertices and E edges, both traverse each edge and vertex at most once. DFS uses a stack (explicit or recursion) to dive deep; BFS uses a queue to fan out by distance from the start.\n**Complexity:** Time: O(V + E) for both; Space: O(V) for visited plus O(V) recursion stack for DFS or queue for BFS.\n**Example:**\nInput: graph = {0:[1,2], 1:[3], 2:[3], 3:[]}, start = 0\nOutput DFS order: [0,1,3,2]; BFS order: [0,1,2,3]\n**Notes:**\n- BFS finds shortest paths in unweighted graphs; DFS does not guarantee shortest routes.\n- Recursive DFS may overflow on very deep graphs; use an explicit stack if needed.\n- Space dominates when the frontier (BFS) or recursion depth (DFS) grows to O(V).", "category": "explanation", "language": "unknown"}
{"prompt": "Explain what this Python code does and how it works:\nlist(map(lambda x: x**2, filter(lambda x: x % 2 == 0, range(10))))", "response": "python\n```python\n# Squares even numbers from 0 through 9\neven_squares = list(map(lambda x: x ** 2, filter(lambda x: x % 2 == 0, range(10))))\n```\n**Explanation:** `range(10)` produces 0..9, `filter` keeps values where `x % 2 == 0`, and `map` squares each remaining number. Wrapping with `list` materializes the results.\n**Complexity:** Time: O(n) over the range size; Space: O(n) for the resulting list (filter/map are lazy but list allocates the output).\n**Example:**\nInput: range(10)\nOutput: [0, 4, 16, 36, 64]\n**Notes:**\n- Equivalent list comprehension: `[x * x for x in range(10) if x % 2 == 0]`.\n- Using generator expressions keeps evaluation lazy until consumed.\n- Replace `range(10)` with any iterable to reuse the pattern.", "category": "explanation", "language": "python"}
{"prompt": "Implement a Python function to aggregate given a dictionary", "response": "python\n```python\nfrom typing import Dict, Iterable, Union\n\nNumber = Union[int, float]\n\n\ndef aggregate_dict(data: Dict[str, Iterable[Number]]) -> Dict[str, Number]:\n    \"\"\"Sum iterable numeric values for each key in the dictionary.\"\"\"\n    totals: Dict[str, Number] = {}\n    for key, values in data.items():\n        totals[key] = sum(values)\n    return totals\n```\n**Explanation:** Iterate over each key and sum its iterable of numeric values, storing the totals in a new dictionary. This aggregates scattered measurements (e.g., per-day counts) into a single number per key.\n**Complexity:** Time: O(total_items) across all iterables; Space: O(k) for k keys in the output.\n**Example:**\nInput: {\"apples\": [1, 2, 3], \"oranges\": [2, 2]}\nOutput: {\"apples\": 6, \"oranges\": 4}\n**Notes:**\n- Expects each value to be iterable; wrap scalars in a list before calling if needed.\n- Extend to other aggregates (avg/min/max) by swapping out `sum` or tracking counts.\n- Non-numeric items will raise a TypeError; validate inputs when necessary.", "category": "function_implementation", "language": "python"}
{"prompt": "Write a Python function that checks if a string is a palindrome", "response": "python\n```python\ndef is_palindrome(s: str) -> bool:\n    \"\"\"Check if a string reads the same forward and backward.\"\"\"\n    cleaned = ''.join(ch.lower() for ch in s if ch.isalnum())\n    return cleaned == cleaned[::-1]\n```\n**Explanation:** Normalize the string by lowercasing and removing non-alphanumeric characters, then compare it to its reverse slice. Equality indicates a palindrome.\n**Complexity:** Time: O(n); Space: O(n) for the cleaned copy.\n**Example:**\nInput: \"A man, a plan, a canal: Panama\"\nOutput: True\n**Notes:**\n- Remove the cleaning step if punctuation and case should be considered.\n- Handles empty strings (treated as palindrome).\n- For very long strings, compare characters from both ends to reduce temporary allocations.", "category": "function_implementation", "language": "python"}
{"prompt": "Write a Go function that reverses a linked list", "response": "go\n```go\npackage main\n\n// ListNode represents a singly-linked list node.\ntype ListNode struct {\n\tVal  int\n\tNext *ListNode\n}\n\n// Reverse reverses a singly-linked list in-place and returns the new head.\nfunc Reverse(head *ListNode) *ListNode {\n\tvar prev *ListNode\n\tcurr := head\n\tfor curr != nil {\n\t\tnext := curr.Next // store next\n\t\tcurr.Next = prev  // reverse pointer\n\t\tprev = curr       // move prev forward\n\t\tcurr = next       // advance\n\t}\n\treturn prev\n}\n```\n**Explanation:** Iterate through the list, rewiring each node's `Next` pointer to the previous node. Track `prev` as the new head under construction. After the loop, `prev` points to the reversed list's head.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: 1 -> 2 -> 3 -> nil\nOutput: 3 -> 2 -> 1 -> nil\n**Notes:**\n- Works for empty and single-node lists (returns the original head).\n- For immutable lists, construct new nodes instead of rewiring.\n- Use recursion carefully; iterative approach avoids stack growth.", "category": "function_implementation", "language": "go"}
{"prompt": "Implement a Python function to filter given a list of numbers", "response": "python\n```python\nfrom typing import Callable, Iterable, List\n\n\ndef filter_numbers(nums: Iterable[int], predicate: Callable[[int], bool] = lambda x: x % 2 == 0) -> List[int]:\n    \"\"\"Return numbers satisfying the predicate (even by default).\"\"\"\n    return [n for n in nums if predicate(n)]\n```\n**Explanation:** Iterate through the input and keep values that satisfy the predicate. By default it retains even numbers, but any boolean-valued function can be supplied.\n**Complexity:** Time: O(n); Space: O(n) for the filtered list.\n**Example:**\nInput: nums = [1, 2, 3, 4, 5], predicate = lambda x: x > 3\nOutput: [4, 5]\n**Notes:**\n- For streaming behavior, yield instead of building a list (use a generator).\n- Predicate defaults to even check; override for other criteria.\n- Works with any iterable, not just lists.", "category": "function_implementation", "language": "python"}
{"prompt": "Implement a Java function to aggregate given an array of objects", "response": "java\n```java\nimport java.util.List;\nimport java.util.function.ToDoubleFunction;\n\npublic class Aggregator {\n    /**\n     * Aggregate a list of objects by summing a numeric property extracted by getter.\n     */\n    public static <T> double sumBy(List<T> items, ToDoubleFunction<T> getter) {\n        double total = 0.0;\n        for (T item : items) {\n            total += getter.applyAsDouble(item);\n        }\n        return total;\n    }\n}\n```\n**Explanation:** Accepts a list of objects and a lambda that extracts a numeric field. Iterates once, summing the extracted values into a running total. Using a functional getter keeps the method reusable for different object shapes.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: items = [{price:10},{price:15}], getter = item -> item.price\nOutput: 25.0\n**Notes:**\n- For integer-safe sums, swap to `ToLongFunction` and `long` accumulator.\n- Validate `items` for null before iterating in production code.\n- Extend to compute averages or grouped totals by collecting into a map.", "category": "function_implementation", "language": "java"}
{"prompt": "Write a Rust function that finds the nth Fibonacci number", "response": "rust\n```rust\n/// Return the nth Fibonacci number (0-indexed: fib(0)=0, fib(1)=1).\npub fn fibonacci(n: u32) -> u64 {\n    if n == 0 {\n        return 0;\n    }\n    let mut a: u64 = 0;\n    let mut b: u64 = 1;\n    for _ in 1..n {\n        let next = a + b;\n        a = b;\n        b = next;\n    }\n    b\n}\n```\n**Explanation:** Handle the base case n = 0 separately, then iteratively update two accumulators `a` and `b` to walk the sequence without recursion. Each loop iteration computes the next value and shifts the window.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: n = 6\nOutput: 8\n**Notes:**\n- Uses `u64`; large n can overflow. Switch to `num_bigint::BigUint` for arbitrary precision.\n- Zero-indexing keeps fib(0)=0, fib(1)=1; adjust indexing if one-based is desired.\n- Iterative approach avoids recursion depth limits.", "category": "function_implementation", "language": "rust"}
{"prompt": "Write a Go function that validates an email address", "response": "go\n```go\npackage main\n\nimport (\n\t\"regexp\"\n)\n\nvar emailRegex = regexp.MustCompile(`^[\\w.+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$`)\n\n// IsValidEmail returns true if the string matches a basic email pattern.\nfunc IsValidEmail(email string) bool {\n\treturn emailRegex.MatchString(email)\n}\n```\n**Explanation:** Compiles a regular expression that checks for a local part of word characters/dots/plus/hyphen, an `@`, a domain, and a TLD of length >= 2. `MatchString` runs the regex against the input.\n**Complexity:** Time: O(n) relative to the input length for regex evaluation; Space: O(1) excluding the compiled pattern.\n**Example:**\nInput: \"user@example.com\"\nOutput: true\n**Notes:**\n- Regex is simplified and won't catch all invalid emails per RFC 5322 but works for common cases.\n- Compile the regex once (as above) to avoid repeated compilation costs.\n- Trim surrounding whitespace before validating if user input may contain it.", "category": "function_implementation", "language": "go"}
{"prompt": "Implement a JavaScript function to aggregate given an array of objects", "response": "javascript\n```javascript\n/**\n * Aggregate an array of objects by summing a numeric field for each key.\n * Example: [{category:'a', value:2}, {category:'a', value:3}] -> {a:5}\n */\nfunction aggregateByKey(items, keyField, valueField) {\n  return items.reduce((acc, item) => {\n    const key = item[keyField];\n    const val = Number(item[valueField] || 0);\n    acc[key] = (acc[key] || 0) + val;\n    return acc;\n  }, {});\n}\n```\n**Explanation:** Use `reduce` to walk the array once, extracting a grouping key and numeric value from each object. Accumulate totals in a plain object keyed by the grouping field.\n**Complexity:** Time: O(n); Space: O(k) where k is the number of unique keys.\n**Example:**\nInput: items = [{type:'fruit', count:2}, {type:'fruit', count:1}, {type:'veg', count:5}], keyField = 'type', valueField = 'count'\nOutput: { fruit: 3, veg: 5 }\n**Notes:**\n- Coerces values with `Number`; handle NaN cases as needed.\n- Works with any key/value property names; pass different field strings to reuse.\n- For nested keys, provide a custom extractor rather than direct indexing.", "category": "function_implementation", "language": "javascript"}
{"prompt": "Implement a Python function to process given a string", "response": "python\n```python\nimport re\n\n\ndef process_string(s: str) -> str:\n    \"\"\"Normalize a string: strip, lowercase, collapse whitespace, and remove extra punctuation spacing.\"\"\"\n    s = s.strip().lower()\n    s = re.sub(r\"\\s+\", \" \", s)  # collapse whitespace\n    return s\n```\n**Explanation:** Performs a simple normalization pipeline: trim leading/trailing whitespace, lowercase all characters, and collapse runs of whitespace into a single space. This is a common preprocessing step before downstream text tasks.\n**Complexity:** Time: O(n); Space: O(n) for the new normalized string.\n**Example:**\nInput: \"  Hello,   WORLD\\n\"\nOutput: \"hello, world\"\n**Notes:**\n- Extend with punctuation removal using another regex if desired.\n- For locale-aware case folding, use `str.casefold()` instead of `lower()`.\n- Works safely on empty strings, returning an empty string.", "category": "function_implementation", "language": "python"}
{"prompt": "Implement a Java function to validate given a list of numbers", "response": "java\n```java\nimport java.util.List;\nimport java.util.function.Predicate;\n\npublic class NumberValidator {\n    /**\n     * Validate that every number in the list satisfies the predicate (non-negative by default).\n     */\n    public static boolean validate(List<Integer> numbers, Predicate<Integer> rule) {\n        if (numbers == null) return false;\n        for (Integer n : numbers) {\n            if (n == null || !rule.test(n)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static boolean validateNonNegative(List<Integer> numbers) {\n        return validate(numbers, n -> n >= 0);\n    }\n}\n```\n**Explanation:** Iterate through the list and test each element against a provided predicate; the helper `validateNonNegative` checks that all entries are zero or greater. Null lists or null elements fail validation.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: numbers = [3, 5, 0]\nOutput: true\n**Notes:**\n- Swap the predicate to enforce range limits or parity checks.\n- Returns false on null input to avoid `NullPointerException`.\n- For primitive efficiency, consider using `IntPredicate` and `IntStream`.", "category": "function_implementation", "language": "java"}
{"prompt": "Write a Rust function that sorts an array using quicksort", "response": "rust\n```rust\npub fn quicksort(arr: &mut [i32]) {\n    if arr.len() <= 1 {\n        return;\n    }\n    let pivot_index = partition(arr);\n    let (left, right) = arr.split_at_mut(pivot_index);\n    quicksort(left);\n    quicksort(&mut right[1..]); // skip pivot in right half\n}\n\nfn partition(arr: &mut [i32]) -> usize {\n    let len = arr.len();\n    let pivot_index = len - 1;\n    let pivot = arr[pivot_index];\n    let mut store = 0;\n    for i in 0..pivot_index {\n        if arr[i] <= pivot {\n            arr.swap(i, store);\n            store += 1;\n        }\n    }\n    arr.swap(store, pivot_index);\n    store\n}\n```\n**Explanation:** Choose the last element as pivot, partition the slice so elements <= pivot move left, then recursively quicksort the left and right partitions. Splitting the mutable slice avoids extra allocations.\n**Complexity:** Time: O(n log n) average, O(n²) worst-case when pivots are poor; Space: O(log n) for recursion stack.\n**Example:**\nInput: [3, 1, 4, 1, 5]\nOutput: [1, 1, 3, 4, 5]\n**Notes:**\n- Pivot choice affects performance; randomizing pivot reduces worst-case likelihood.\n- Recursion depth may hit stack limits for large degenerate inputs; tail-call elimination is not guaranteed.\n- For large arrays, switch to insertion sort for small partitions to improve constants.", "category": "function_implementation", "language": "rust"}
{"prompt": "Write a Python function that calculates the factorial of a number", "response": "python\n```python\ndef factorial(n: int) -> int:\n    \"\"\"Return n! for n >= 0.\"\"\"\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result\n```\n**Explanation:** Validate input, then multiply integers from 2 through n into an accumulator. This computes factorial iteratively, avoiding recursion overhead.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: 4\nOutput: 24\n**Notes:**\n- Returns 1 for n = 0 as defined by factorial.\n- Python's big integers grow quickly; consider limiting n for user input.\n- For repeated calls, memoize results to avoid recomputation.", "category": "function_implementation", "language": "python"}
{"prompt": "Write a Rust function that checks if a string is a palindrome", "response": "rust\n```rust\npub fn is_palindrome(s: &str) -> bool {\n    let cleaned: String = s\n        .chars()\n        .filter(|c| c.is_alphanumeric())\n        .flat_map(|c| c.to_lowercase())\n        .collect();\n    cleaned.chars().eq(cleaned.chars().rev())\n}\n```\n**Explanation:** Normalize the string by keeping only alphanumeric characters and lowercasing them, then compare the iterator to its reverse. Equality implies the string reads the same forwards and backwards.\n**Complexity:** Time: O(n); Space: O(n) for the cleaned copy.\n**Example:**\nInput: \"RaceCar!\"\nOutput: true\n**Notes:**\n- Remove filtering if punctuation/case sensitivity matters.\n- For large inputs, you can avoid allocating `cleaned` by comparing characters from both ends directly.\n- Unicode-aware: `to_lowercase` handles multi-char conversions, so `flat_map` is used.", "category": "function_implementation", "language": "rust"}
{"prompt": "Write a Java function that validates an email address", "response": "java\n```java\nimport java.util.regex.Pattern;\n\npublic class EmailValidator {\n    private static final Pattern EMAIL_PATTERN =\n        Pattern.compile(\"^[\\\\w.+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$\");\n\n    public static boolean isValid(String email) {\n        return email != null && EMAIL_PATTERN.matcher(email).matches();\n    }\n}\n```\n**Explanation:** Compiles a simple regex that checks for a valid-looking local part, an `@`, a domain, and a top-level domain of at least two letters. `isValid` returns true when the input matches.\n**Complexity:** Time: O(n) for matching; Space: O(1) auxiliary (pattern is precompiled).\n**Example:**\nInput: \"user@example.com\"\nOutput: true\n**Notes:**\n- Regex is intentionally lenient; full RFC compliance requires a more complex pattern.\n- Returns false on null to avoid `NullPointerException`.\n- Trim whitespace before validation if user input may include it.", "category": "function_implementation", "language": "java"}
{"prompt": "Implement a JavaScript function to transform given a string", "response": "javascript\n```javascript\n/**\n * Transform a string by trimming, collapsing whitespace, and capitalizing each word.\n */\nfunction transformString(input) {\n  return input\n    .trim()\n    .split(/\\s+/)\n    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n    .join(' ');\n}\n```\n**Explanation:** Trim leading/trailing whitespace, split on runs of whitespace, title-case each word, and join back with single spaces. This normalizes spacing and casing in one pass.\n**Complexity:** Time: O(n); Space: O(n) for the array of words and output string.\n**Example:**\nInput: \"  hello   WORLD  \"\nOutput: \"Hello World\"\n**Notes:**\n- For locale-sensitive casing, use `toLocaleUpperCase`/`toLocaleLowerCase`.\n- If the input can be empty or whitespace-only, the result will be an empty string.\n- Extend with slugification by lowercasing and joining with `-` instead of capitalizing.", "category": "function_implementation", "language": "javascript"}
{"prompt": "Implement a JavaScript function to transform given a dictionary", "response": "javascript\n```javascript\n/**\n * Transform the values of an object with a callback, keeping the same keys.\n */\nfunction transformObject(obj, mapper) {\n  return Object.fromEntries(\n    Object.entries(obj).map(([key, value]) => [key, mapper(value, key)])\n  );\n}\n```\n**Explanation:** Convert the object to key-value pairs, map each value through the callback (receiving value and key), and rebuild a new object via `fromEntries`, preserving keys.\n**Complexity:** Time: O(k) for k entries; Space: O(k) for the new object.\n**Example:**\nInput: obj = { a: 1, b: 2 }, mapper = v => v * 10\nOutput: { a: 10, b: 20 }\n**Notes:**\n- Does not mutate the original object; adjust if in-place updates are acceptable.\n- Mapper can use the key for context (e.g., rename or conditionally transform).\n- For nested dictionaries, call recursively or use deep-walk utilities.", "category": "function_implementation", "language": "javascript"}
{"prompt": "Write a JavaScript function that converts a decimal number to binary", "response": "javascript\n```javascript\n// Convert a non-negative integer to its binary string representation\nfunction decimalToBinary(n) {\n  if (n < 0 || !Number.isInteger(n)) throw new Error('n must be a non-negative integer');\n  return n.toString(2);\n}\n```\n**Explanation:** Validate input and use JavaScript's built-in `Number.prototype.toString` with radix 2 to produce the binary representation.\n**Complexity:** Time: O(log n); Space: O(log n) for the output string length.\n**Example:**\nInput: 10\nOutput: \"1010\"\n**Notes:**\n- For padding, wrap with `result.padStart(width, '0')`.\n- For very large integers beyond `Number.MAX_SAFE_INTEGER`, use `BigInt` and call `.toString(2)` on it.\n- Throws on negative or non-integer input to avoid surprising results.", "category": "function_implementation", "language": "javascript"}
{"prompt": "Write a Java function that sorts an array using quicksort", "response": "java\n```java\npublic class QuickSort {\n    public static void quicksort(int[] arr) {\n        sort(arr, 0, arr.length - 1);\n    }\n\n    private static void sort(int[] arr, int low, int high) {\n        if (low >= high) return;\n        int pivotIndex = partition(arr, low, high);\n        sort(arr, low, pivotIndex - 1);\n        sort(arr, pivotIndex + 1, high);\n    }\n\n    private static int partition(int[] arr, int low, int high) {\n        int pivot = arr[high];\n        int i = low;\n        for (int j = low; j < high; j++) {\n            if (arr[j] <= pivot) {\n                swap(arr, i, j);\n                i++;\n            }\n        }\n        swap(arr, i, high);\n        return i;\n    }\n\n    private static void swap(int[] arr, int i, int j) {\n        int tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }\n}\n```\n**Explanation:** Choose the last element as pivot, partition the array so elements ≤ pivot are on the left, then recursively quicksort the subarrays on either side. Swapping in-place avoids extra allocations.\n**Complexity:** Time: O(n log n) average, O(n²) worst-case; Space: O(log n) for recursion stack.\n**Example:**\nInput: [3, 7, 2, 5]\nOutput: [2, 3, 5, 7]\n**Notes:**\n- Randomize or median-of-three pivot selection to reduce worst-case chances.\n- Tail recursion elimination is not guaranteed; consider iterative implementation for very large arrays.\n- Stable sorting is not provided by this quicksort variant.", "category": "function_implementation", "language": "java"}
{"prompt": "Implement a C++ function to aggregate given an array of objects", "response": "c++\n```cpp\n#include <vector>\n#include <functional>\n\ntemplate <typename T>\nlong long aggregate(const std::vector<T> &items, const std::function<long long(const T &)> &getter) {\n    long long total = 0;\n    for (const auto &item : items) {\n        total += getter(item);\n    }\n    return total;\n}\n```\n**Explanation:** Accepts a vector of objects and a getter that extracts a numeric value. Iterates once, summing the extracted numbers into a running total.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: items = [{count:2},{count:5}], getter = [](const auto &i){ return i.count; }\nOutput: 7\n**Notes:**\n- Use templates/lambdas to inline the getter and avoid `std::function` overhead when performance critical.\n- For floating-point aggregation, change accumulator type accordingly.\n- Validate input size or handle overflow as needed for large totals.", "category": "function_implementation", "language": "c++"}
{"prompt": "Implement a Python function to filter given a list of numbers", "response": "python\n```python\nfrom typing import Callable, Iterable, List\n\n\ndef filter_numbers(nums: Iterable[int], predicate: Callable[[int], bool] = lambda x: x % 2 == 0) -> List[int]:\n    \"\"\"Return numbers satisfying the predicate (even by default).\"\"\"\n    return [n for n in nums if predicate(n)]\n```\n**Explanation:** Iterate through the input and keep values that satisfy the predicate. By default it retains even numbers, but any boolean-valued function can be supplied.\n**Complexity:** Time: O(n); Space: O(n) for the filtered list.\n**Example:**\nInput: nums = [1, 2, 3, 4, 5], predicate = lambda x: x > 3\nOutput: [4, 5]\n**Notes:**\n- For streaming behavior, yield instead of building a list (use a generator).\n- Predicate defaults to even check; override for other criteria.\n- Works with any iterable, not just lists.", "category": "function_implementation", "language": "python"}
{"prompt": "Implement a JavaScript function to aggregate given an array of objects", "response": "javascript\n```javascript\n/**\n * Aggregate an array of objects by summing a numeric field for each key.\n * Example: [{category:'a', value:2}, {category:'a', value:3}] -> {a:5}\n */\nfunction aggregateByKey(items, keyField, valueField) {\n  return items.reduce((acc, item) => {\n    const key = item[keyField];\n    const val = Number(item[valueField] || 0);\n    acc[key] = (acc[key] || 0) + val;\n    return acc;\n  }, {});\n}\n```\n**Explanation:** Use `reduce` to walk the array once, extracting a grouping key and numeric value from each object. Accumulate totals in a plain object keyed by the grouping field.\n**Complexity:** Time: O(n); Space: O(k) where k is the number of unique keys.\n**Example:**\nInput: items = [{type:'fruit', count:2}, {type:'fruit', count:1}, {type:'veg', count:5}], keyField = 'type', valueField = 'count'\nOutput: { fruit: 3, veg: 5 }\n**Notes:**\n- Coerces values with `Number`; handle NaN cases as needed.\n- Works with any key/value property names; pass different field strings to reuse.\n- For nested keys, provide a custom extractor rather than direct indexing.", "category": "function_implementation", "language": "javascript"}
{"prompt": "Write Python code to make an HTTP GET request and parse JSON", "response": "python\n```python\nimport requests\n\n\ndef fetch_json(url: str) -> dict:\n    \"\"\"Perform an HTTP GET request and return parsed JSON.\"\"\"\n    resp = requests.get(url, timeout=10)\n    resp.raise_for_status()\n    return resp.json()\n```\n**Explanation:** Send a GET request with a 10-second timeout, raise for non-2xx responses, and parse the body as JSON via `response.json()`, returning the decoded Python object.\n**Complexity:** Time: O(response_size); Space: O(response_size) for the loaded JSON structure.\n**Example:**\nInput: url = \"https://api.github.com\"\nOutput: Parsed JSON dict (e.g., {\"current_user_url\": ...})\n**Notes:**\n- Wrap in try/except to handle network errors gracefully.\n- For large payloads, stream and incrementally parse instead of loading all at once.\n- Ensure `requests` is installed; alternatively use `http.client` or `urllib.request` from the stdlib.", "category": "real_world", "language": "python"}
{"prompt": "Write JavaScript code to validate user input", "response": "javascript\n```javascript\n/**\n * Validate a user input string: trimmed length within bounds and optional pattern.\n */\nfunction validateInput(value, { min = 1, max = 100, pattern = null } = {}) {\n  if (typeof value !== 'string') return { valid: false, error: 'Input must be a string' };\n  const trimmed = value.trim();\n  if (trimmed.length < min) return { valid: false, error: `Minimum length is ${min}` };\n  if (trimmed.length > max) return { valid: false, error: `Maximum length is ${max}` };\n  if (pattern && !pattern.test(trimmed)) return { valid: false, error: 'Input does not match required format' };\n  return { valid: true, value: trimmed };\n}\n```\n**Explanation:** Normalize the input by trimming, then enforce length bounds and an optional regex pattern. Returns a result object indicating validity and either the cleaned value or an error message.\n**Complexity:** Time: O(n) for string length/pattern checks; Space: O(1) auxiliary.\n**Example:**\nInput: value = \" user@example.com \", options = { pattern: /^[\\w.+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$/ }\nOutput: { valid: true, value: 'user@example.com' }\n**Notes:**\n- Extend with additional rules (profanity filters, blocked domains, etc.).\n- For multiple fields, reuse this helper with different patterns/limits.\n- Validate on both client and server to avoid relying solely on front-end checks.", "category": "real_world", "language": "javascript"}
{"prompt": "Write JavaScript code to create a simple web scraper", "response": "javascript\n```javascript\nimport fetch from 'node-fetch';\nimport { load } from 'cheerio';\n\n// Fetch a page and extract all anchor hrefs\nexport async function scrapeLinks(url) {\n  const resp = await fetch(url);\n  if (!resp.ok) throw new Error(`Request failed: ${resp.status}`);\n  const html = await resp.text();\n  const $ = load(html);\n  const links = [];\n  $('a[href]').each((_, el) => {\n    links.push($(el).attr('href'));\n  });\n  return links;\n}\n```\n**Explanation:** Use `fetch` to download the HTML, parse it with Cheerio (a server-side jQuery-like library), then collect `href` attributes from all anchor tags into an array.\n**Complexity:** Time: O(page_size + links); Space: O(page_size) for the HTML and DOM representation.\n**Example:**\nInput: scrapeLinks('https://example.com')\nOutput: ['https://www.iana.org/domains/example']\n**Notes:**\n- Requires `node-fetch` and `cheerio` packages; install with `npm install node-fetch cheerio`.\n- Respect robots.txt and site terms when scraping.\n- Add timeouts/retries to harden against network issues.", "category": "real_world", "language": "javascript"}
{"prompt": "Write Python code to make an HTTP GET request and parse JSON", "response": "python\n```python\nimport requests\n\n\ndef fetch_json(url: str) -> dict:\n    \"\"\"Perform an HTTP GET request and return parsed JSON.\"\"\"\n    resp = requests.get(url, timeout=10)\n    resp.raise_for_status()\n    return resp.json()\n```\n**Explanation:** Send a GET request with a 10-second timeout, raise for non-2xx responses, and parse the body as JSON via `response.json()`, returning the decoded Python object.\n**Complexity:** Time: O(response_size); Space: O(response_size) for the loaded JSON structure.\n**Example:**\nInput: url = \"https://api.github.com\"\nOutput: Parsed JSON dict (e.g., {\"current_user_url\": ...})\n**Notes:**\n- Wrap in try/except to handle network errors gracefully.\n- For large payloads, stream and incrementally parse instead of loading all at once.\n- Ensure `requests` is installed; alternatively use `http.client` or `urllib.request` from the stdlib.", "category": "real_world", "language": "python"}
{"prompt": "Write Java code to implement logging", "response": "java\n```java\nimport java.util.logging.ConsoleHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class LoggingExample {\n    private static final Logger LOGGER = Logger.getLogger(LoggingExample.class.getName());\n\n    static {\n        ConsoleHandler handler = new ConsoleHandler();\n        handler.setFormatter(new SimpleFormatter());\n        handler.setLevel(Level.INFO);\n        LOGGER.addHandler(handler);\n        LOGGER.setUseParentHandlers(false);\n        LOGGER.setLevel(Level.INFO);\n    }\n\n    public static void doWork() {\n        LOGGER.info(\"Starting work\");\n        try {\n            // business logic here\n            LOGGER.fine(\"Detailed debug message\");\n        } catch (Exception ex) {\n            LOGGER.log(Level.SEVERE, \"Unexpected error\", ex);\n        } finally {\n            LOGGER.info(\"Finished work\");\n        }\n    }\n}\n```\n**Explanation:** Configures a `Logger` with a console handler and simple formatter, sets log levels, and uses it to emit info/debug/error messages around a unit of work. Disables parent handlers to prevent duplicate logging.\n**Complexity:** Time: O(1) per log call (ignoring I/O); Space: O(1).\n**Example:**\nInput: call `LoggingExample.doWork()`\nOutput: Console logs such as \"INFO: Starting work\" and \"INFO: Finished work\"\n**Notes:**\n- Adjust handler levels and add file handlers for persistent logs.\n- In larger apps, prefer SLF4J + Logback/Log4j2 for richer configuration.\n- Avoid expensive string concatenation by using parameterized logging or guards around debug statements.", "category": "real_world", "language": "java"}
{"prompt": "Write JavaScript code to create a simple web scraper", "response": "javascript\n```javascript\nimport fetch from 'node-fetch';\nimport { load } from 'cheerio';\n\n// Fetch a page and extract all anchor hrefs\nexport async function scrapeLinks(url) {\n  const resp = await fetch(url);\n  if (!resp.ok) throw new Error(`Request failed: ${resp.status}`);\n  const html = await resp.text();\n  const $ = load(html);\n  const links = [];\n  $('a[href]').each((_, el) => {\n    links.push($(el).attr('href'));\n  });\n  return links;\n}\n```\n**Explanation:** Use `fetch` to download the HTML, parse it with Cheerio (a server-side jQuery-like library), then collect `href` attributes from all anchor tags into an array.\n**Complexity:** Time: O(page_size + links); Space: O(page_size) for the HTML and DOM representation.\n**Example:**\nInput: scrapeLinks('https://example.com')\nOutput: ['https://www.iana.org/domains/example']\n**Notes:**\n- Requires `node-fetch` and `cheerio` packages; install with `npm install node-fetch cheerio`.\n- Respect robots.txt and site terms when scraping.\n- Add timeouts/retries to harden against network issues.", "category": "real_world", "language": "javascript"}
{"prompt": "Write Python code to validate user input", "response": "python\n```python\nimport re\nfrom typing import Optional, Pattern, Tuple\n\n\ndef validate_input(value: str, *, min_len: int = 1, max_len: int = 100, pattern: Optional[Pattern[str]] = None) -> Tuple[bool, str]:\n    \"\"\"Validate a user input string with length bounds and optional regex pattern.\"\"\"\n    if not isinstance(value, str):\n        return False, \"Input must be a string\"\n    cleaned = value.strip()\n    if len(cleaned) < min_len:\n        return False, f\"Minimum length is {min_len}\"\n    if len(cleaned) > max_len:\n        return False, f\"Maximum length is {max_len}\"\n    if pattern and not pattern.fullmatch(cleaned):\n        return False, \"Input does not match required format\"\n    return True, cleaned\n```\n**Explanation:** Trim whitespace, enforce minimum/maximum length, and optionally require the string to match a regex. Returns a tuple indicating validity and either the cleaned value or an error message.\n**Complexity:** Time: O(n) for length and regex checks; Space: O(1) auxiliary.\n**Example:**\nInput: value=\" user@example.com \", pattern=r\"^[\\w.+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$\"\nOutput: (True, \"user@example.com\")\n**Notes:**\n- Swap `pattern.fullmatch` for `search` if the pattern should match a substring.\n- Adjust `min_len`/`max_len` per field requirements.\n- Combine with additional domain-specific validations (blocked words, profanity filters) as needed.", "category": "real_world", "language": "python"}
{"prompt": "Write Python code to validate user input", "response": "python\n```python\nimport re\nfrom typing import Optional, Pattern, Tuple\n\n\ndef validate_input(value: str, *, min_len: int = 1, max_len: int = 100, pattern: Optional[Pattern[str]] = None) -> Tuple[bool, str]:\n    \"\"\"Validate a user input string with length bounds and optional regex pattern.\"\"\"\n    if not isinstance(value, str):\n        return False, \"Input must be a string\"\n    cleaned = value.strip()\n    if len(cleaned) < min_len:\n        return False, f\"Minimum length is {min_len}\"\n    if len(cleaned) > max_len:\n        return False, f\"Maximum length is {max_len}\"\n    if pattern and not pattern.fullmatch(cleaned):\n        return False, \"Input does not match required format\"\n    return True, cleaned\n```\n**Explanation:** Trim whitespace, enforce minimum/maximum length, and optionally require the string to match a regex. Returns a tuple indicating validity and either the cleaned value or an error message.\n**Complexity:** Time: O(n) for length and regex checks; Space: O(1) auxiliary.\n**Example:**\nInput: value=\" user@example.com \", pattern=r\"^[\\w.+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$\"\nOutput: (True, \"user@example.com\")\n**Notes:**\n- Swap `pattern.fullmatch` for `search` if the pattern should match a substring.\n- Adjust `min_len`/`max_len` per field requirements.\n- Combine with additional domain-specific validations (blocked words, profanity filters) as needed.", "category": "real_world", "language": "python"}
{"prompt": "Write Java code to create a simple web scraper", "response": "java\n```java\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.jsoup.Jsoup;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.select.Elements;\n\npublic class WebScraper {\n    // Fetch a page and extract all anchor hrefs\n    public static List<String> scrapeLinks(String url) throws IOException {\n        Document doc = Jsoup.connect(url).get();\n        Elements anchors = doc.select(\"a[href]\");\n        List<String> links = new ArrayList<>();\n        for (Element a : anchors) {\n            links.add(a.attr(\"abs:href\"));\n        }\n        return links;\n    }\n}\n```\n**Explanation:** Uses Jsoup to download and parse HTML. Selects all anchor tags with href attributes, extracts absolute URLs, and returns them as a list.\n**Complexity:** Time: O(page_size + links); Space: O(page_size) for DOM representation plus O(k) for collected links.\n**Example:**\nInput: scrapeLinks(\"https://example.com\")\nOutput: [\"https://www.iana.org/domains/example\"]\n**Notes:**\n- Requires Jsoup dependency (e.g., Maven: `org.jsoup:jsoup`).\n- Respect robots.txt and site terms when scraping; add user-agent and rate limiting as appropriate.\n- Wrap in try/catch to handle network/parse failures gracefully.", "category": "real_world", "language": "java"}
{"prompt": "Implement depth-first search (DFS) in Java with detailed comments", "response": "java\n```java\nimport java.util.*;\n\npublic class DepthFirstSearch {\n    /**\n     * Perform DFS on an adjacency-list graph starting at \"start\".\n     * Returns vertices in visitation order.\n     */\n    public static List<Integer> dfs(List<List<Integer>> graph, int start) {\n        List<Integer> order = new ArrayList<>();\n        boolean[] visited = new boolean[graph.size()];\n        Deque<Integer> stack = new ArrayDeque<>();\n\n        stack.push(start);\n        while (!stack.isEmpty()) {\n            int node = stack.pop();\n            if (visited[node]) continue; // skip if already processed\n            visited[node] = true;\n            order.add(node);\n            // Push neighbors in reverse so earlier neighbors are visited first\n            List<Integer> neighbors = graph.get(node);\n            for (int i = neighbors.size() - 1; i >= 0; i--) {\n                int nei = neighbors.get(i);\n                if (!visited[nei]) stack.push(nei);\n            }\n        }\n        return order;\n    }\n}\n```\n**Explanation:** Uses an explicit stack to traverse depth-first from the start node. Mark nodes visited when popped to avoid duplicates, append to the result list, and push unvisited neighbors (reversed to preserve adjacency order). Works for directed or undirected graphs represented as adjacency lists.\n**Complexity:** Time: O(V + E); Space: O(V) for visited and stack.\n**Example:**\nInput: graph = [[1,2],[3],[3],[]], start = 0\nOutput: [0,2,3,1] (one valid DFS order)\n**Notes:**\n- Swap to a recursive helper if call-stack depth is safe.\n- For deterministic order, sort adjacency lists before traversal.\n- Detect cycles by checking `visited` before processing neighbors.", "category": "algorithm", "language": "java"}
{"prompt": "Implement dynamic programming for coin change in Rust with detailed comments", "response": "rust\n```rust\n/// Compute minimum coins to make up `amount` using unlimited coins via DP.\npub fn coin_change(coins: &[i32], amount: i32) -> i32 {\n    let mut dp = vec![amount + 1; (amount + 1) as usize];\n    dp[0] = 0;\n    for &coin in coins {\n        for a in coin..=amount {\n            let idx = a as usize;\n            let prev = (a - coin) as usize;\n            dp[idx] = dp[idx].min(dp[prev] + 1);\n        }\n    }\n    let ans = dp[amount as usize];\n    if ans > amount { -1 } else { ans }\n}\n```\n**Explanation:** Bottom-up dynamic programming where `dp[a]` stores the minimum coins to form amount `a`. Initialize unreachable states to a sentinel (`amount+1`), iterate coins and update amounts from coin value upward (unbounded knapsack). If the final state remains sentinel, return -1 to signal impossibility.\n**Complexity:** Time: O(amount * |coins|); Space: O(amount).\n**Example:**\nInput: coins = [1, 2, 5], amount = 11\nOutput: 3 (5 + 5 + 1)\n**Notes:**\n- Assumes non-negative coin values and amount.\n- For large `amount`, consider early exits when `dp[a]` stops changing.\n- To reconstruct which coins were used, track a parent array alongside `dp`.", "category": "algorithm", "language": "rust"}
{"prompt": "Write Python code to solve: Serialize and deserialize a binary tree", "response": "python\n```python\nfrom collections import deque\nfrom typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val: int, left: Optional['TreeNode'] = None, right: Optional['TreeNode'] = None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef serialize(root: Optional[TreeNode]) -> str:\n    if not root:\n        return \"\"\n    out = []\n    q = deque([root])\n    while q:\n        node = q.popleft()\n        if node:\n            out.append(str(node.val))\n            q.append(node.left)\n            q.append(node.right)\n        else:\n            out.append(\"#\")\n    # trim trailing nulls\n    while out and out[-1] == \"#\":\n        out.pop()\n    return \",\".join(out)\n\n\ndef deserialize(data: str) -> Optional[TreeNode]:\n    if not data:\n        return None\n    vals = data.split(',')\n    root = TreeNode(int(vals[0]))\n    q = deque([root])\n    i = 1\n    while q and i < len(vals):\n        node = q.popleft()\n        if vals[i] != \"#\":\n            node.left = TreeNode(int(vals[i])); q.append(node.left)\n        i += 1\n        if i < len(vals) and vals[i] != \"#\":\n            node.right = TreeNode(int(vals[i])); q.append(node.right)\n        i += 1\n    return root\n```\n**Explanation:** Level-order serialize using `#` placeholders for nulls; trailing nulls are trimmed for brevity. Deserialize by rebuilding the tree level-order: read values, attach children sequentially, and enqueue non-null nodes for further expansion.\n**Complexity:** Time: O(n) for n nodes; Space: O(n) for output string and queues.\n**Example:**\nInput: root representing [1,2,3,#,#,4]\nOutput: serialized string \"1,2,3,#,#,4\"; deserializing returns an equivalent tree.\n**Notes:**\n- Works for arbitrary integer values; extend parsing for other types as needed.\n- Trimming trailing nulls shortens the string but preserves structure.\n- Replace `#`/`,` if those characters may appear in values (or encode safely).", "category": "algorithm", "language": "python"}
{"prompt": "Write JavaScript code to solve: Implement LRU cache", "response": "javascript\n```javascript\n// LRU Cache with Map + doubly-linked list semantics using Map insertion order\nclass LRUCache {\n  constructor(capacity) {\n    if (capacity <= 0) throw new Error('capacity must be positive');\n    this.cap = capacity;\n    this.map = new Map();\n  }\n\n  get(key) {\n    if (!this.map.has(key)) return -1;\n    const value = this.map.get(key);\n    // refresh recency by re-inserting\n    this.map.delete(key);\n    this.map.set(key, value);\n    return value;\n  }\n\n  put(key, value) {\n    if (this.map.has(key)) {\n      this.map.delete(key);\n    }\n    this.map.set(key, value);\n    if (this.map.size > this.cap) {\n      // remove least-recently used (Map iteration order is insertion order)\n      const lruKey = this.map.keys().next().value;\n      this.map.delete(lruKey);\n    }\n  }\n}\n```\n**Explanation:** Stores entries in a `Map`, which preserves insertion order. On `get`/`put`, the accessed key is removed and reinserted to mark it as most recently used. When capacity is exceeded, evict the oldest key via `map.keys().next().value`.\n**Complexity:** Time: O(1) amortized for get/put; Space: O(capacity).\n**Example:**\nInput: `cache = new LRUCache(2); cache.put(1,1); cache.put(2,2); cache.get(1); cache.put(3,3); cache.get(2);`\nOutput: `get(1) => 1`, `get(2) => -1` (2 evicted)\n**Notes:**\n- Map order semantics are defined in ES2015+; safe in modern runtimes.\n- For very large caches, consider a custom doubly-linked list to avoid Map rehashing costs.\n- Evict on every put that exceeds capacity to keep size bounded.", "category": "algorithm", "language": "javascript"}
{"prompt": "Implement quick sort in JavaScript with detailed comments", "response": "javascript\n```javascript\n// In-place quicksort (Lomuto partition) with comments\nfunction quickSort(arr, lo = 0, hi = arr.length - 1) {\n  if (lo >= hi) return arr;\n  const p = partition(arr, lo, hi);\n  quickSort(arr, lo, p - 1);\n  quickSort(arr, p + 1, hi);\n  return arr;\n}\n\nfunction partition(arr, lo, hi) {\n  const pivot = arr[hi];\n  let i = lo;\n  for (let j = lo; j < hi; j++) {\n    if (arr[j] <= pivot) {\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n      i++;\n    }\n  }\n  [arr[i], arr[hi]] = [arr[hi], arr[i]];\n  return i;\n}\n```\n**Explanation:** Recursively sorts subarrays around a pivot. `partition` places elements ≤ pivot to the left and returns the pivot’s final index, then quicksort recurses on the left/right partitions.\n**Complexity:** Time: O(n log n) average, O(n²) worst when partitions are unbalanced; Space: O(log n) recursion stack.\n**Example:**\nInput: [3, 1, 4, 1]\nOutput: [1, 1, 3, 4]\n**Notes:**\n- Randomize the pivot (swap with a random index) to mitigate worst cases.\n- Tail-call optimize or switch to insertion sort on tiny partitions for speed.\n- Not stable; equal elements may reorder.", "category": "algorithm", "language": "javascript"}
{"prompt": "Write TypeScript code to solve: Validate binary search tree", "response": "typescript\n```typescript\n// Validate if a binary tree is a BST using inorder traversal (iterative)\nclass TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val: number, left: TreeNode | null = null, right: TreeNode | null = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\nfunction isValidBST(root: TreeNode | null): boolean {\n  const stack: TreeNode[] = [];\n  let prev: number | null = null;\n  let node = root;\n\n  while (stack.length || node) {\n    while (node) {\n      stack.push(node);\n      node = node.left;\n    }\n    node = stack.pop()!;\n    if (prev !== null && node.val <= prev) return false;\n    prev = node.val;\n    node = node.right;\n  }\n  return true;\n}\n```\n**Explanation:** Inorder traversal of a BST should yield a strictly increasing sequence. The iterative traversal tracks the previously visited value; any violation (`current <= prev`) means the BST property is broken.\n**Complexity:** Time: O(n); Space: O(h) where h is tree height (stack).\n**Example:**\nInput: root with values [2,1,3]\nOutput: true\n**Notes:**\n- Use `prev` initialized to `null` to allow any first value; adjust for duplicates if your BST allows equality.\n- Recursive traversal is simpler but may hit stack limits on deep trees.\n- Ensure all subtree values respect both min and max bounds; inorder check covers this for BSTs.", "category": "algorithm", "language": "typescript"}
{"prompt": "Write Python code to solve: Rotate a matrix 90 degrees", "response": "python\n```python\nfrom typing import List\n\ndef rotate(matrix: List[List[int]]) -> None:\n    \"\"\"Rotate the square matrix 90 degrees clockwise in-place.\"\"\"\n    n = len(matrix)\n    # transpose\n    for i in range(n):\n        for j in range(i + 1, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n    # reverse each row\n    for row in matrix:\n        row.reverse()\n```\n**Explanation:** Transpose swaps rows and columns, then reversing each row yields a 90° clockwise rotation. Both steps are in-place, requiring only constant extra space.\n**Complexity:** Time: O(n²); Space: O(1) extra.\n**Example:**\nInput: [[1,2],[3,4]]\nOutput: [[3,1],[4,2]]\n**Notes:**\n- Matrix must be square; pad or adjust for rectangular shapes.\n- For counterclockwise rotation, transpose then reverse columns instead.\n- Validate non-empty input to avoid index errors.", "category": "algorithm", "language": "python"}
{"prompt": "Write Java code to solve: Detect a cycle in a linked list", "response": "java\n```java\npublic class LinkedListCycle {\n    static class ListNode {\n        int val; ListNode next;\n        ListNode(int v) { val = v; }\n    }\n\n    public static boolean hasCycle(ListNode head) {\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) return true;\n        }\n        return false;\n    }\n}\n```\n**Explanation:** Floyd’s tortoise-hare algorithm advances `fast` two steps and `slow` one; if a cycle exists, they eventually meet. Reaching the end (`fast == null` or `fast.next == null`) implies no cycle.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: 1 -> 2 -> 3 -> 2 (cycle)\nOutput: true\n**Notes:**\n- To find the cycle start, reset one pointer to head after meeting and move both one step until they meet again.\n- Works for empty and single-node lists (returns false).\n- Avoid modifying list structure during detection.", "category": "algorithm", "language": "java"}
{"prompt": "Implement binary search in Java with detailed comments", "response": "java\n```java\npublic class BinarySearch {\n    /**\n     * Return index of target in sorted array nums, or -1 if not found.\n     */\n    public static int search(int[] nums, int target) {\n        int lo = 0, hi = nums.length - 1;\n        while (lo <= hi) {\n            int mid = lo + (hi - lo) / 2; // avoid overflow\n            if (nums[mid] == target) return mid;\n            if (nums[mid] < target) {\n                lo = mid + 1;\n            } else {\n                hi = mid - 1;\n            }\n        }\n        return -1;\n    }\n}\n```\n**Explanation:** Standard iterative binary search on a sorted array. Narrow the search interval based on the mid comparison until the target is found or the interval is empty.\n**Complexity:** Time: O(log n); Space: O(1).\n**Example:**\nInput: nums = [1, 3, 5, 7], target = 5\nOutput: 2\n**Notes:**\n- Requires sorted input; otherwise results are undefined.\n- For first/last occurrence in duplicates, bias the bounds accordingly.\n- Mid computation uses `lo + (hi - lo) / 2` to prevent overflow on large indices.", "category": "algorithm", "language": "java"}
{"prompt": "Implement Kruskal's minimum spanning tree in Java with detailed comments", "response": "java\n```java\nimport java.util.*;\n\npublic class KruskalMST {\n    static class Edge {\n        int u, v, w;\n        Edge(int u, int v, int w) { this.u = u; this.v = v; this.w = w; }\n    }\n\n    static class DSU {\n        int[] p, r;\n        DSU(int n) { p = new int[n]; r = new int[n]; for (int i = 0; i < n; i++) p[i] = i; }\n        int find(int x) { return p[x] == x ? x : (p[x] = find(p[x])); }\n        boolean union(int a, int b) {\n            a = find(a); b = find(b);\n            if (a == b) return false;\n            if (r[a] < r[b]) { int t=a; a=b; b=t; }\n            p[b] = a;\n            if (r[a] == r[b]) r[a]++;\n            return true;\n        }\n    }\n\n    public static int mstWeight(int n, List<Edge> edges) {\n        edges.sort(Comparator.comparingInt(e -> e.w));\n        DSU dsu = new DSU(n);\n        int total = 0, used = 0;\n        for (Edge e : edges) {\n            if (dsu.union(e.u, e.v)) {\n                total += e.w;\n                if (++used == n - 1) break;\n            }\n        }\n        if (used != n - 1) throw new IllegalStateException(\"Graph not connected\");\n        return total;\n    }\n}\n```\n**Explanation:** Sort edges by weight and greedily add them if their endpoints are in different components, using a DSU with path compression and union by rank to track components. Accumulate weights until n-1 edges are chosen for a connected MST.\n**Complexity:** Time: O(E log E); Space: O(V) for DSU.\n**Example:**\nInput: n=3, edges [(0,1,1),(1,2,2),(0,2,3)]\nOutput: MST weight = 3\n**Notes:**\n- Throws if the graph is disconnected (fewer than n-1 edges accepted).\n- Extend Edge to hold metadata if you need to return the edge set, not just weight.\n- Works for undirected graphs; ensure edges are bidirectional in the input.", "category": "algorithm", "language": "java"}
{"prompt": "Implement depth-first search (DFS) in Rust with detailed comments", "response": "rust\n```rust\npub fn dfs(graph: &[Vec<usize>], start: usize) -> Vec<usize> {\n    let mut visited = vec![false; graph.len()];\n    let mut stack = vec![start];\n    let mut order = Vec::new();\n\n    while let Some(node) = stack.pop() {\n        if visited[node] { continue; }\n        visited[node] = true;\n        order.push(node);\n        for &nei in graph[node].iter().rev() { // reverse to preserve adjacency order\n            if !visited[nei] {\n                stack.push(nei);\n            }\n        }\n    }\n    order\n}\n```\n**Explanation:** Iterative DFS with an explicit stack. Pop a node, skip if already visited, mark visited, record it, then push unvisited neighbors (reversed so earlier neighbors are processed first).\n**Complexity:** Time: O(V + E); Space: O(V) for visited and stack.\n**Example:**\nInput: graph = vec![vec![1,2], vec![2], vec![3], vec![]], start = 0\nOutput: [0,2,3,1] (one valid DFS order)\n**Notes:**\n- Use recursion if depth is small, but iterative avoids stack overflow.\n- For directed graphs, adjacency should reflect edge direction.\n- Add bounds checks for `start` in production.", "category": "algorithm", "language": "rust"}
{"prompt": "Implement union-find with path compression in Python with detailed comments", "response": "python\n```python\nclass UnionFind:\n    def __init__(self, n: int):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, x: int) -> int:\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, a: int, b: int) -> None:\n        ra, rb = self.find(a), self.find(b)\n        if ra == rb:\n            return\n        if self.rank[ra] < self.rank[rb]:\n            ra, rb = rb, ra\n        self.parent[rb] = ra\n        if self.rank[ra] == self.rank[rb]:\n            self.rank[ra] += 1\n```\n**Explanation:** Maintains parent/rank arrays; `find` compresses paths recursively, `union` attaches the lower-rank root under the higher-rank root to keep trees shallow.\n**Complexity:** Time: Amortized ~O(α(n)) per op; Space: O(n).\n**Example:**\nInput: uf = UnionFind(3); uf.union(0,1); uf.union(1,2); uf.find(2)\nOutput: 0 (or 1) as representative of the merged set\n**Notes:**\n- No dynamic growth; instantiate with known maximum size.\n- Add `connected(a,b)` helper for readability.\n- Validate indices before use in production code.", "category": "algorithm", "language": "python"}
{"prompt": "Write JavaScript code to solve: Rotate a matrix 90 degrees", "response": "javascript\n```javascript\n// Rotate an n x n matrix 90 degrees clockwise in-place\nfunction rotate(matrix) {\n  const n = matrix.length;\n  // transpose\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\n    }\n  }\n  // reverse each row\n  for (const row of matrix) {\n    row.reverse();\n  }\n  return matrix;\n}\n```\n**Explanation:** Transpose swaps matrix[i][j] with matrix[j][i], then reversing each row yields a 90° clockwise rotation without extra space.\n**Complexity:** Time: O(n²); Space: O(1) extra.\n**Example:**\nInput: [[1,2],[3,4]]\nOutput: [[3,1],[4,2]]\n**Notes:**\n- Requires a square matrix; pad or adjust for rectangular shapes.\n- For counterclockwise, transpose then reverse columns instead.\n- Validate non-empty input to avoid undefined behavior on jagged arrays.", "category": "algorithm", "language": "javascript"}
{"prompt": "Write TypeScript code to solve: Find all permutations of a string", "response": "typescript\n```typescript\nfunction permutations(s: string): string[] {\n  const chars = s.split(\"\");\n  const result: string[] = [];\n\n  function backtrack(start: number): void {\n    if (start === chars.length) {\n      result.push(chars.join(\"\"));\n      return;\n    }\n    for (let i = start; i < chars.length; i++) {\n      [chars[start], chars[i]] = [chars[i], chars[start]];\n      backtrack(start + 1);\n      [chars[start], chars[i]] = [chars[i], chars[start]]; // undo\n    }\n  }\n\n  backtrack(0);\n  return result;\n}\n```\n**Explanation:** Uses swap-based backtracking: fix each position by swapping in every candidate character, recurse to fill the rest, then swap back to restore state. When the current index reaches the string length, collect a permutation.\n**Complexity:** Time: O(n·n!) due to generating all permutations; Space: O(n) recursion stack (output excluded).\n**Example:**\nInput: \"abc\"\nOutput: [\"abc\", \"acb\", \"bac\", \"bca\", \"cba\", \"cab\"]\n**Notes:**\n- Strings with duplicate characters will produce duplicate permutations; use a set per level to skip repeats.\n- Works for empty string (returns [\"\"]).\n- Swapping in-place avoids extra allocations per recursion level.", "category": "algorithm", "language": "typescript"}
{"prompt": "Implement Dijkstra's shortest path in C++ with detailed comments", "response": "c++\n```cpp\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing Edge = std::pair<int, int>; // neighbor, weight\nusing Graph = std::vector<std::vector<Edge>>;\n\nstd::vector<int> dijkstra(const Graph& g, int src) {\n    const int INF = std::numeric_limits<int>::max();\n    std::vector<int> dist(g.size(), INF);\n    dist[src] = 0;\n    using Node = std::pair<int,int>; // dist, node\n    std::priority_queue<Node, std::vector<Node>, std::greater<Node>> pq;\n    pq.push({0, src});\n\n    while (!pq.empty()) {\n        auto [d, u] = pq.top(); pq.pop();\n        if (d != dist[u]) continue; // stale entry\n        for (auto [v, w] : g[u]) {\n            if (d + w < dist[v]) {\n                dist[v] = d + w;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n    return dist;\n}\n```\n**Explanation:** Initializes distances to INF except the source, uses a min-heap to extract the closest unprocessed node, and relaxes outgoing edges. Stale heap entries are skipped when their stored distance differs from the current best.\n**Complexity:** Time: O((V + E) log V); Space: O(V) for dist and heap.\n**Example:**\nInput: Graph with edges 0-1 (2), 1-2 (1), 0-2 (5); src=0\nOutput: dist = [0, 2, 3]\n**Notes:**\n- Requires non-negative weights; negative edges invalidate Dijkstra.\n- To reconstruct paths, keep a `parent` array when relaxing.\n- For dense graphs, consider a Fibonacci heap for theoretical improvements.", "category": "algorithm", "language": "c++"}
{"prompt": "Write Python code to solve: Detect a cycle in a linked list", "response": "python\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\ndef has_cycle(head: ListNode) -> bool:\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow is fast:\n            return True\n    return False\n```\n**Explanation:** Uses Floyd’s tortoise-hare pointers; if `fast` ever laps `slow`, a cycle exists. Terminating when `fast` or `fast.next` is null implies no cycle.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: 1 -> 2 -> 3 -> 2 (cycle)\nOutput: True\n**Notes:**\n- Handles empty/one-node lists safely.\n- To locate the cycle entry, reset one pointer to head after detection and step both until they meet.\n- Does not modify the list.", "category": "algorithm", "language": "python"}
{"prompt": "Implement topological sort with cycle detection in Java with detailed comments", "response": "java\n```java\nimport java.util.*;\n\npublic class TopoSort {\n    /**\n     * Kahn's algorithm: returns topological order or throws on cycle.\n     */\n    public static List<Integer> topoOrder(int n, List<int[]> edges) {\n        List<List<Integer>> adj = new ArrayList<>();\n        int[] indeg = new int[n];\n        for (int i = 0; i < n; i++) adj.add(new ArrayList<>());\n        for (int[] e : edges) {\n            adj.get(e[0]).add(e[1]);\n            indeg[e[1]]++;\n        }\n        Queue<Integer> q = new ArrayDeque<>();\n        for (int i = 0; i < n; i++) if (indeg[i] == 0) q.add(i);\n        List<Integer> order = new ArrayList<>();\n        while (!q.isEmpty()) {\n            int u = q.poll();\n            order.add(u);\n            for (int v : adj.get(u)) {\n                if (--indeg[v] == 0) q.add(v);\n            }\n        }\n        if (order.size() != n) throw new IllegalStateException(\"Cycle detected\");\n        return order;\n    }\n}\n```\n**Explanation:** Builds adjacency and indegree arrays, enqueues zero-indegree nodes, repeatedly removes them, and decreases neighbors’ indegrees. If nodes remain with indegree > 0, a cycle exists.\n**Complexity:** Time: O(V + E); Space: O(V + E).\n**Example:**\nInput: n=3, edges=[[0,1],[1,2]]\nOutput: [0,1,2]\n**Notes:**\n- Works only on DAGs; cycles trigger an exception.\n- Multiple valid orders can exist depending on queue tie-breaking.\n- For DFS-based topo sort, postorder nodes onto a stack instead of indegree processing.", "category": "algorithm", "language": "java"}
{"prompt": "Write JavaScript code to solve: Serialize and deserialize a binary tree", "response": "javascript\n```javascript\n// Binary tree node\nfunction TreeNode(val, left = null, right = null) {\n  this.val = val;\n  this.left = left;\n  this.right = right;\n}\n\n// Serialize with BFS, using '#' for nulls\nfunction serialize(root) {\n  if (!root) return '';\n  const out = [];\n  const queue = [root];\n  while (queue.length) {\n    const node = queue.shift();\n    if (node) {\n      out.push(String(node.val));\n      queue.push(node.left, node.right);\n    } else {\n      out.push('#');\n    }\n  }\n  while (out.length && out[out.length - 1] === '#') out.pop();\n  return out.join(',');\n}\n\nfunction deserialize(data) {\n  if (!data) return null;\n  const vals = data.split(',');\n  const root = new TreeNode(parseInt(vals[0], 10));\n  const queue = [root];\n  let i = 1;\n  while (queue.length && i < vals.length) {\n    const node = queue.shift();\n    const leftVal = vals[i++];\n    if (leftVal !== '#' && leftVal !== undefined) {\n      node.left = new TreeNode(parseInt(leftVal, 10));\n      queue.push(node.left);\n    }\n    const rightVal = vals[i++];\n    if (rightVal !== '#' && rightVal !== undefined) {\n      node.right = new TreeNode(parseInt(rightVal, 10));\n      queue.push(node.right);\n    }\n  }\n  return root;\n}\n```\n**Explanation:** Serializes with level-order traversal, inserting `#` for nulls and trimming trailing null markers. Deserializes by rebuilding level-order: read values, attach children sequentially, and enqueue non-null nodes.\n**Complexity:** Time: O(n); Space: O(n).\n**Example:**\nInput: root with values [1,2,3,#,#,4]\nOutput: serialized \"1,2,3,#,#,4\"; deserialization restores an equivalent tree\n**Notes:**\n- If node values may include commas or '#', encode/escape them first.\n- Trimming trailing nulls shortens the payload while preserving structure.\n- Switch to pre/postorder formats if you prefer a recursive encoding.", "category": "algorithm", "language": "javascript"}
{"prompt": "Implement depth-first search (DFS) in JavaScript with detailed comments", "response": "javascript\n```javascript\nfunction dfs(graph, start) {\n  const visited = new Array(graph.length).fill(false);\n  const stack = [start];\n  const order = [];\n  while (stack.length) {\n    const node = stack.pop();\n    if (visited[node]) continue;\n    visited[node] = true;\n    order.push(node);\n    const neighbors = graph[node];\n    for (let i = neighbors.length - 1; i >= 0; i--) {\n      const nei = neighbors[i];\n      if (!visited[nei]) stack.push(nei);\n    }\n  }\n  return order;\n}\n```\n**Explanation:** Iterative DFS using a stack; marks nodes as visited when popped, records visitation order, and pushes unvisited neighbors (reversed to honor adjacency order) onto the stack.\n**Complexity:** Time: O(V + E); Space: O(V).\n**Example:**\nInput: graph = [[1,2],[3],[3],[]], start = 0\nOutput: [0,2,3,1] (one valid DFS order)\n**Notes:**\n- Replace with recursion if depth is small and stack overflow isn’t a concern.\n- Add bounds checks for `start` in production code.\n- Works for directed/undirected graphs depending on adjacency construction.", "category": "algorithm", "language": "javascript"}
{"prompt": "Write JavaScript code to solve: Word ladder problem", "response": "javascript\n```javascript\nfunction ladderLength(beginWord, endWord, wordList) {\n  const dict = new Set(wordList);\n  if (!dict.has(endWord)) return 0;\n  const queue = [[beginWord, 1]];\n  const visited = new Set([beginWord]);\n  const alphabet = 'abcdefghijklmnopqrstuvwxyz';\n\n  while (queue.length) {\n    const [word, depth] = queue.shift();\n    if (word === endWord) return depth;\n    for (let i = 0; i < word.length; i++) {\n      for (const ch of alphabet) {\n        if (ch === word[i]) continue;\n        const next = word.slice(0, i) + ch + word.slice(i + 1);\n        if (dict.has(next) && !visited.has(next)) {\n          visited.add(next);\n          queue.push([next, depth + 1]);\n        }\n      }\n    }\n  }\n  return 0;\n}\n```\n**Explanation:** BFS explores one-letter transformations present in the dictionary, starting from `beginWord`. The first time `endWord` is dequeued yields the shortest ladder length. Visited set prevents revisiting words.\n**Complexity:** Time: O(N * L * 26) where N is dictionary size and L word length; Space: O(N) for sets/queue.\n**Example:**\nInput: begin=\"hit\", end=\"cog\", list=[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\nOutput: 5\n**Notes:**\n- Returns 0 if `endWord` not reachable or absent.\n- For performance on large dictionaries, precompute wildcard patterns or use bidirectional BFS.\n- Assumes all words have equal length; filter otherwise.", "category": "algorithm", "language": "javascript"}
{"prompt": "Implement backtracking for N-queens in JavaScript with detailed comments", "response": "javascript\n```javascript\nfunction solveNQueens(n) {\n  const solutions = [];\n  const cols = new Set();\n  const diag1 = new Set(); // r - c\n  const diag2 = new Set(); // r + c\n  const board = Array.from({ length: n }, () => Array(n).fill('.'));\n\n  function backtrack(r) {\n    if (r === n) {\n      solutions.push(board.map(row => row.join('')));\n      return;\n    }\n    for (let c = 0; c < n; c++) {\n      if (cols.has(c) || diag1.has(r - c) || diag2.has(r + c)) continue;\n      cols.add(c); diag1.add(r - c); diag2.add(r + c);\n      board[r][c] = 'Q';\n      backtrack(r + 1);\n      board[r][c] = '.';\n      cols.delete(c); diag1.delete(r - c); diag2.delete(r + c);\n    }\n  }\n\n  backtrack(0);\n  return solutions;\n}\n```\n**Explanation:** Backtracks row by row, placing queens only where columns and diagonals are unoccupied, tracked by three sets. On placing queens in all rows, records the board layout.\n**Complexity:** Time: O(N!) in the worst case; Space: O(N) for recursion plus O(N) for tracking sets.\n**Example:**\nInput: n = 4\nOutput: [\".Q..\",\"...Q\",\"Q...\",\"..Q.\"], [\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]\n**Notes:**\n- Uses string rows for readable solutions; adjust output as needed.\n- Sets give O(1) threat checks; bitmasks can improve performance.\n- Prune early by skipping attacked columns/diagonals.", "category": "algorithm", "language": "javascript"}
{"prompt": "Implement k-way merge using heaps in Python with detailed comments", "response": "python\n```python\nimport heapq\nfrom typing import List\n\ndef k_way_merge(lists: List[List[int]]) -> List[int]:\n    \"\"\"Merge k sorted lists into one sorted list using a min-heap.\"\"\"\n    heap = []\n    result: List[int] = []\n    for i, arr in enumerate(lists):\n        if arr:\n            heapq.heappush(heap, (arr[0], i, 0))\n    while heap:\n        val, li, idx = heapq.heappop(heap)\n        result.append(val)\n        nxt = idx + 1\n        if nxt < len(lists[li]):\n            heapq.heappush(heap, (lists[li][nxt], li, nxt))\n    return result\n```\n**Explanation:** Initializes a min-heap with the first element of each list and repeatedly pops the smallest, pushing the next element from that list. This maintains the overall sorted order across all lists.\n**Complexity:** Time: O(N log k) where N is total elements and k is number of lists; Space: O(k) for the heap plus output.\n**Example:**\nInput: [[1,4],[2,3],[0,5]]\nOutput: [0,1,2,3,4,5]\n**Notes:**\n- Handles empty lists gracefully.\n- For custom ordering, store comparator keys accordingly.\n- Keep tuples small to minimize heap overhead.", "category": "algorithm", "language": "python"}
{"prompt": "Implement union-find with path compression in JavaScript with detailed comments", "response": "javascript\n```javascript\nclass UnionFind {\n  constructor(n) {\n    this.parent = Array.from({ length: n }, (_, i) => i);\n    this.rank = Array(n).fill(0);\n  }\n  find(x) {\n    if (this.parent[x] !== x) {\n      this.parent[x] = this.find(this.parent[x]);\n    }\n    return this.parent[x];\n  }\n  union(a, b) {\n    let ra = this.find(a), rb = this.find(b);\n    if (ra === rb) return;\n    if (this.rank[ra] < this.rank[rb]) [ra, rb] = [rb, ra];\n    this.parent[rb] = ra;\n    if (this.rank[ra] === this.rank[rb]) this.rank[ra]++;\n  }\n}\n```\n**Explanation:** Implements union-find with path compression in `find` and union by rank to attach shallower trees under deeper ones, keeping operations nearly constant time.\n**Complexity:** Time: Amortized ~O(α(n)) per op; Space: O(n).\n**Example:**\nInput: uf.union(0,1); uf.union(1,2); uf.find(2)\nOutput: representative of set {0,1,2}\n**Notes:**\n- Ensure indices are within bounds.\n- Add a `connected(a,b)` helper for readability.\n- Capacity is fixed at construction; create a new instance to grow.", "category": "algorithm", "language": "javascript"}
{"prompt": "Write TypeScript code to solve: Word ladder problem", "response": "typescript\n```typescript\nexport function ladderLength(beginWord: string, endWord: string, wordList: string[]): number {\n  const dict = new Set(wordList);\n  if (!dict.has(endWord)) return 0;\n  const queue: [string, number][] = [[beginWord, 1]];\n  const visited = new Set<string>([beginWord]);\n  const alphabet = 'abcdefghijklmnopqrstuvwxyz';\n\n  while (queue.length) {\n    const [word, dist] = queue.shift()!;\n    if (word === endWord) return dist;\n    for (let i = 0; i < word.length; i++) {\n      for (const ch of alphabet) {\n        if (ch === word[i]) continue;\n        const next = word.slice(0, i) + ch + word.slice(i + 1);\n        if (dict.has(next) && !visited.has(next)) {\n          visited.add(next);\n          queue.push([next, dist + 1]);\n        }\n      }\n    }\n  }\n  return 0;\n}\n```\n**Explanation:** BFS explores one-letter transformations present in the dictionary. The first time `endWord` is dequeued gives the shortest transformation length. Visited tracking prevents cycles.\n**Complexity:** Time: O(N * L * 26) where N is dictionary size and L word length; Space: O(N) for sets and queue.\n**Example:**\nInput: begin=\"hit\", end=\"cog\", list=[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\nOutput: 5\n**Notes:**\n- Returns 0 if `endWord` not in the dictionary or unreachable.\n- For large dictionaries, bidirectional BFS halves the search depth.\n- Assumes all words have equal length.", "category": "algorithm", "language": "typescript"}
{"prompt": "Write TypeScript code to solve: Trapping rain water", "response": "typescript\n```typescript\nexport function trap(height: number[]): number {\n  let left = 0, right = height.length - 1;\n  let leftMax = 0, rightMax = 0, water = 0;\n  while (left < right) {\n    if (height[left] < height[right]) {\n      leftMax = Math.max(leftMax, height[left]);\n      water += leftMax - height[left];\n      left++;\n    } else {\n      rightMax = Math.max(rightMax, height[right]);\n      water += rightMax - height[right];\n      right--;\n    }\n  }\n  return water;\n}\n```\n**Explanation:** Two-pointer approach: move the pointer on the lower side inward, tracking maximums from each side. Water at a position is bounded by the smaller side’s max minus current height.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: [4,2,0,3,2,5]\nOutput: 9\n**Notes:**\n- Assumes non-negative heights.\n- Returns 0 for arrays shorter than 3 bars.\n- For debugging, compare with prefix/suffix max precompute approach.", "category": "algorithm", "language": "typescript"}
{"prompt": "Implement depth-first search (DFS) in Python with detailed comments", "response": "python\n```python\ndef dfs(graph, start):\n    visited = [False] * len(graph)\n    stack = [start]\n    order = []\n    while stack:\n        node = stack.pop()\n        if visited[node]:\n            continue\n        visited[node] = True\n        order.append(node)\n        for nei in reversed(graph[node]):\n            if not visited[nei]:\n                stack.append(nei)\n    return order\n```\n**Explanation:** Iterative depth-first search using a stack. Pops a node, skips if already seen, marks visited, records order, and pushes unvisited neighbors (reversed to respect adjacency order).\n**Complexity:** Time: O(V + E); Space: O(V) for visited/stack.\n**Example:**\nInput: graph=[[1,2],[3],[3],[]], start=0\nOutput: [0,2,3,1] (one valid DFS order)\n**Notes:**\n- Add bounds checking for invalid start indices.\n- For recursive style, ensure recursion depth is safe for large graphs.\n- Works for directed/undirected graphs depending on adjacency lists.", "category": "algorithm", "language": "python"}
{"prompt": "Write TypeScript code to solve: Implement LRU cache", "response": "typescript\n```typescript\nclass LRUCache<K, V> {\n  private map = new Map<K, V>();\n  constructor(private capacity: number) {\n    if (capacity <= 0) throw new Error('capacity must be positive');\n  }\n  get(key: K): V | -1 {\n    if (!this.map.has(key)) return -1;\n    const val = this.map.get(key)!;\n    this.map.delete(key);\n    this.map.set(key, val); // refresh recency\n    return val;\n  }\n  put(key: K, value: V): void {\n    if (this.map.has(key)) this.map.delete(key);\n    this.map.set(key, value);\n    if (this.map.size > this.capacity) {\n      const lruKey = this.map.keys().next().value;\n      this.map.delete(lruKey);\n    }\n  }\n}\n```\n**Explanation:** Uses `Map` insertion order to track recency. Access deletes and re-inserts the key to mark it as most recent; `put` evicts the oldest key when capacity is exceeded.\n**Complexity:** Time: O(1) amortized for get/put; Space: O(capacity).\n**Example:**\nInput: cache.put(1,\"a\"), cache.put(2,\"b\"), cache.get(1), cache.put(3,\"c\"), cache.get(2)\nOutput: get(1) -> \"a\", get(2) -> -1\n**Notes:**\n- Works in modern runtimes where Map preserves insertion order.\n- Add type guards or default values to avoid returning -1 with non-number V if desired.\n- Eviction occurs immediately after any insertion that exceeds capacity.", "category": "algorithm", "language": "typescript"}
{"prompt": "Write Java code to solve: Maximum subarray sum (Kadane)", "response": "java\n```java\npublic class MaxSubarray {\n    public static int maxSubArray(int[] nums) {\n        int best = nums[0];\n        int curr = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            curr = Math.max(nums[i], curr + nums[i]);\n            best = Math.max(best, curr);\n        }\n        return best;\n    }\n}\n```\n**Explanation:** Kadane’s algorithm keeps a running maximum ending at the current index (`curr`) and a global best. At each step, either extend the previous subarray or start new at the current element.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\n**Notes:**\n- Works when all numbers are negative (returns the largest single element).\n- To recover indices, track start/end positions alongside `curr`.\n- Requires non-empty array; guard if input may be empty.", "category": "algorithm", "language": "java"}
{"prompt": "Implement A* pathfinding in Go with detailed comments", "response": "go\n```go\npackage main\n\nimport (\n\t\"container/heap\"\n\t\"math\"\n)\n\ntype Node struct {\n\tid     int\n\tx, y   int\n\tcost   float64\n\tindex  int\n\tparent *Node\n}\n\ntype PriorityQueue []*Node\n\nfunc (pq PriorityQueue) Len() int { return len(pq) }\nfunc (pq PriorityQueue) Less(i, j int) bool { return pq[i].cost < pq[j].cost }\nfunc (pq PriorityQueue) Swap(i, j int) {\n\tpq[i], pq[j] = pq[j], pq[i]\n\tpq[i].index = i; pq[j].index = j\n}\nfunc (pq *PriorityQueue) Push(x interface{}) { *pq = append(*pq, x.(*Node)) }\nfunc (pq *PriorityQueue) Pop() interface{} {\n\told := *pq\n\tn := len(old)\n\titem := old[n-1]\n\t*pq = old[:n-1]\n\treturn item\n}\n\nfunc heuristic(a, b *Node) float64 {\n\tdx := float64(a.x - b.x)\n\tdy := float64(a.y - b.y)\n\treturn math.Abs(dx) + math.Abs(dy) // Manhattan\n}\n\n// AStar runs A* search on a grid graph described by walkable matrix.\nfunc AStar(grid [][]int, start, goal [2]int) []*Node {\n\trows, cols := len(grid), len(grid[0])\n\tnodes := make([][]*Node, rows)\n\tfor i := range nodes {\n\t\tnodes[i] = make([]*Node, cols)\n\t}\n\tvar goalNode *Node\n\tid := 0\n\tfor r := 0; r < rows; r++ {\n\t\tfor c := 0; c < cols; c++ {\n\t\t\tnodes[r][c] = &Node{id: id, x: r, y: c, cost: math.Inf(1)}\n\t\t\tid++\n\t\t}\n\t}\n\tstartNode := nodes[start[0]][start[1]]\n\tgoalNode = nodes[goal[0]][goal[1]]\n\n\topen := PriorityQueue{}\n\theap.Init(&open)\n\tstartNode.cost = heuristic(startNode, goalNode)\n\theap.Push(&open, startNode)\n\tgScore := map[*Node]float64{startNode: 0}\n\tcameFrom := map[*Node]*Node{}\n\n\tdirs := [][2]int{{1,0},{-1,0},{0,1},{0,-1}}\n\n\tfor open.Len() > 0 {\n\t\tcurrent := heap.Pop(&open).(*Node)\n\t\tif current == goalNode {\n\t\t\treturn reconstructPath(cameFrom, current)\n\t\t}\n\t\tfor _, d := range dirs {\n\t\t\tnr, nc := current.x+d[0], current.y+d[1]\n\t\t\tif nr < 0 || nr >= rows || nc < 0 || nc >= cols || grid[nr][nc] == 1 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tneighbor := nodes[nr][nc]\n\t\t\ttentative := gScore[current] + 1\n\t\t\tif g, ok := gScore[neighbor]; !ok || tentative < g {\n\t\t\t\tcameFrom[neighbor] = current\n\t\t\t\tgScore[neighbor] = tentative\n\t\t\t\tneighbor.cost = tentative + heuristic(neighbor, goalNode)\n\t\t\t\theap.Push(&open, neighbor)\n\t\t\t}\n\t\t}\n\t}\n\treturn nil // no path\n}\n\nfunc reconstructPath(prev map[*Node]*Node, current *Node) []*Node {\n\tpath := []*Node{current}\n\tfor p := prev[current]; p != nil; p = prev[p] {\n\t\tpath = append(path, p)\n\t}\n\tfor i, j := 0, len(path)-1; i < j; i, j = i+1, j-1 {\n\t\tpath[i], path[j] = path[j], path[i]\n\t}\n\treturn path\n}\n```\n**Explanation:** Represents grid cells as nodes, uses a min-heap priority queue ordered by f = g + h (gScore + Manhattan heuristic). Expands neighbors skipping walls (grid value 1). Tracks predecessors to reconstruct the path when the goal is dequeued.\n**Complexity:** Time: O(E log V); Space: O(V) for scores, heap, and path.\n**Example:**\nInput: 0/1 grid with start (0,0) and goal (1,1)\nOutput: Shortest walkable path as a list of nodes\n**Notes:**\n- Heuristic assumes 4-neighbor grid; adjust for diagonals.\n- For weighted grids, add edge weights to gScore increments.\n- Validate bounds and walkability before running.", "category": "algorithm", "language": "go"}
{"prompt": "Write Java code to solve: Implement LRU cache", "response": "java\n```java\nimport java.util.*;\n\npublic class LRUCache {\n    private final int capacity;\n    private final Map<Integer, Integer> map = new HashMap<>();\n    private final Deque<Integer> order = new ArrayDeque<>();\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n    }\n\n    public int get(int key) {\n        if (!map.containsKey(key)) return -1;\n        touch(key);\n        return map.get(key);\n    }\n\n    public void put(int key, int value) {\n        if (map.containsKey(key)) {\n            map.put(key, value);\n            touch(key);\n            return;\n        }\n        if (map.size() == capacity) {\n            int lru = order.removeLast();\n            map.remove(lru);\n        }\n        map.put(key, value);\n        order.addFirst(key);\n    }\n\n    private void touch(int key) {\n        order.remove(key);\n        order.addFirst(key);\n    }\n}\n```\n**Explanation:** HashMap stores key->value; a deque tracks recency. `get`/`put` move accessed keys to the front; when capacity is exceeded, evict the least recently used key from the back.\n**Complexity:** Time: O(1) average for get/put (deque removal of known element is O(n), acceptable for small caches; switch to LinkedHashMap for strict O(1)); Space: O(capacity).\n**Example:**\nInput: cap=2; put(1,1); put(2,2); get(1); put(3,3); get(2)\nOutput: get(1)=1, get(2)=-1\n**Notes:**\n- Replace deque/remove with LinkedHashMap to ensure O(1) recency updates.\n- Returns -1 on miss; adjust per needs.\n- Capacity must be > 0.", "category": "algorithm", "language": "java"}
{"prompt": "Write Python code to solve: Implement LRU cache", "response": "python\n```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        if capacity <= 0:\n            raise ValueError(\"capacity must be positive\")\n        self.cap = capacity\n        self.cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key)\n        return self.cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.cap:\n            self.cache.popitem(last=False)\n```\n**Explanation:** Uses an access-ordered `OrderedDict` to track recency. `get` refreshes the key’s position; `put` inserts/updates and evicts the least-recently used entry when capacity is exceeded.\n**Complexity:** Time: O(1) average per op; Space: O(capacity).\n**Example:**\nInput: cap=2; put(1,1); put(2,2); get(1); put(3,3); get(2)\nOutput: get(1)=1, get(2)=-1\n**Notes:**\n- Returns -1 for missing keys; adjust to raise if preferred.\n- Keys/values typed as int here; generalize as needed.\n- For thread safety, wrap operations with a lock.", "category": "algorithm", "language": "python"}
{"prompt": "Write JavaScript code to solve: Longest increasing subsequence", "response": "javascript\n```javascript\nfunction lengthOfLIS(nums) {\n  const tails = [];\n  for (const x of nums) {\n    let lo = 0, hi = tails.length;\n    while (lo < hi) {\n      const mid = (lo + hi) >> 1;\n      if (tails[mid] < x) lo = mid + 1; else hi = mid;\n    }\n    tails[lo] = x;\n  }\n  return tails.length;\n}\n```\n**Explanation:** Patience sorting approach: `tails[i]` holds the smallest possible tail of an increasing subsequence of length `i+1`. Binary search finds the position to place each number, extending the list when it exceeds current tails.\n**Complexity:** Time: O(n log n); Space: O(n).\n**Example:**\nInput: [10,9,2,5,3,7,101,18]\nOutput: 4\n**Notes:**\n- Change comparison to `<=` for non-decreasing subsequences.\n- To reconstruct the actual sequence, track predecessors and indices of tails.\n- Handles empty input (returns 0).", "category": "algorithm", "language": "javascript"}
{"prompt": "Write Python code to solve: Find the kth largest element in an array", "response": "python\n```python\nimport heapq\nfrom typing import Iterable\n\ndef kth_largest(nums: Iterable[int], k: int) -> int:\n    heap = []\n    for n in nums:\n        heapq.heappush(heap, n)\n        if len(heap) > k:\n            heapq.heappop(heap)\n    if len(heap) < k:\n        raise ValueError(\"k larger than number of elements\")\n    return heap[0]\n```\n**Explanation:** Maintains a min-heap of size k containing the k largest elements seen. After processing all numbers, the heap root is the kth largest.\n**Complexity:** Time: O(n log k); Space: O(k).\n**Example:**\nInput: nums=[3,2,1,5,6,4], k=2\nOutput: 5\n**Notes:**\n- Validate k>0 before running.\n- For kth smallest, invert comparisons or use a max-heap.\n- Stream-friendly: works on any iterable, including generators.", "category": "algorithm", "language": "python"}
{"prompt": "Implement breadth-first search (BFS) in Go with detailed comments", "response": "go\n```go\npackage main\n\nimport \"container/list\"\n\n// BFS returns visitation order from start in an adjacency list graph.\nfunc BFS(graph [][]int, start int) []int {\n\torder := []int{}\n\tif start < 0 || start >= len(graph) {\n\t\treturn order\n\t}\n\tvisited := make([]bool, len(graph))\n\tq := list.New()\n\tvisited[start] = true\n\tq.PushBack(start)\n\tfor q.Len() > 0 {\n\t\te := q.Front()\n\t\tnode := e.Value.(int)\n\t\tq.Remove(e)\n\t\torder = append(order, node)\n\t\tfor _, nei := range graph[node] {\n\t\t\tif !visited[nei] {\n\t\t\t\tvisited[nei] = true\n\t\t\t\tq.PushBack(nei)\n\t\t\t}\n\t\t}\n\t}\n\treturn order\n}\n```\n**Explanation:** Uses a queue to explore neighbors level by level. Marks nodes visited on enqueue to avoid duplicates, appending each dequeued node to the output order.\n**Complexity:** Time: O(V + E); Space: O(V) for visited and queue.\n**Example:**\nInput: graph = [[1,2],[3],[3],[]], start=0\nOutput: [0,1,2,3]\n**Notes:**\n- Bounds-check start to prevent panics.\n- Works for directed/undirected graphs based on adjacency input.\n- Replace list with slice-based queue if preferred.", "category": "algorithm", "language": "go"}
{"prompt": "Write TypeScript code to solve: Detect a cycle in a linked list", "response": "typescript\n```typescript\nclass ListNode {\n  val: number;\n  next: ListNode | null;\n  constructor(val?: number, next?: ListNode | null) {\n    this.val = val ?? 0;\n    this.next = next ?? null;\n  }\n}\n\nexport function hasCycle(head: ListNode | null): boolean {\n  let slow = head, fast = head;\n  while (fast && fast.next) {\n    slow = slow!.next;\n    fast = fast.next.next;\n    if (slow === fast) return true;\n  }\n  return false;\n}\n```\n**Explanation:** Floyd’s tortoise-hare algorithm advances `fast` twice as quickly; if a cycle exists, pointers meet. Null checks prevent out-of-bounds access.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: 1 -> 2 -> 3 -> (points back to 2)\nOutput: true\n**Notes:**\n- Handles empty and single-node lists safely.\n- To find the cycle entry, reset one pointer to head after detection and step both until they meet again.\n- Leaves list unmodified.", "category": "algorithm", "language": "typescript"}
{"prompt": "Write Java code to solve: Trapping rain water", "response": "java\n```java\npublic class TrappingRainWater {\n    public static int trap(int[] height) {\n        int left = 0, right = height.length - 1;\n        int leftMax = 0, rightMax = 0, water = 0;\n        while (left < right) {\n            if (height[left] < height[right]) {\n                leftMax = Math.max(leftMax, height[left]);\n                water += leftMax - height[left];\n                left++;\n            } else {\n                rightMax = Math.max(rightMax, height[right]);\n                water += rightMax - height[right];\n                right--;\n            }\n        }\n        return water;\n    }\n}\n```\n**Explanation:** Two-pointer technique: move the shorter side inward, tracking maximum heights seen from each side. Water at a position is bounded by the smaller side’s max minus current height; accumulate as pointers converge.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\n**Notes:**\n- Assumes non-negative heights.\n- Returns 0 for arrays shorter than 3.\n- For debugging, compare with precomputed prefix/suffix maxima arrays.", "category": "algorithm", "language": "java"}
{"prompt": "Implement topological sort with cycle detection in Rust with detailed comments", "response": "rust\n```rust\nuse std::collections::{HashMap, VecDeque};\n\n/// Kahn's algorithm for topological sort; returns None if a cycle exists.\npub fn topo_sort(n: usize, edges: &[(usize, usize)]) -> Option<Vec<usize>> {\n    let mut adj: Vec<Vec<usize>> = vec![Vec::new(); n];\n    let mut indeg = vec![0usize; n];\n    for &(u, v) in edges {\n        adj[u].push(v);\n        indeg[v] += 1;\n    }\n    let mut q: VecDeque<usize> = indeg\n        .iter()\n        .enumerate()\n        .filter_map(|(i, &d)| if d == 0 { Some(i) } else { None })\n        .collect();\n    let mut order = Vec::with_capacity(n);\n    while let Some(u) = q.pop_front() {\n        order.push(u);\n        for &v in &adj[u] {\n            indeg[v] -= 1;\n            if indeg[v] == 0 {\n                q.push_back(v);\n            }\n        }\n    }\n    if order.len() == n { Some(order) } else { None }\n}\n```\n**Explanation:** Builds adjacency and indegree arrays, enqueues all zero-indegree nodes, and repeatedly removes them, decrementing indegrees of neighbors. If all nodes are emitted, returns the order; otherwise returns `None` to signal a cycle.\n**Complexity:** Time: O(V + E); Space: O(V + E).\n**Example:**\nInput: n=3, edges=[(0,1),(1,2)]\nOutput: Some([0,1,2])\n**Notes:**\n- Use DFS-based topo sort if you prefer recursion; still detect cycles when a back edge is found.\n- Ensure node indices are within [0, n).\n- Multiple valid orders may exist depending on queue ordering.", "category": "algorithm", "language": "rust"}
{"prompt": "Write JavaScript code to solve: Validate binary search tree", "response": "javascript\n```javascript\n// Validate a binary search tree using bounds\nfunction isValidBST(root) {\n  function helper(node, low, high) {\n    if (!node) return true;\n    if ((low !== null && node.val <= low) || (high !== null && node.val >= high)) return false;\n    return helper(node.left, low, node.val) && helper(node.right, node.val, high);\n  }\n  return helper(root, null, null);\n}\n```\n**Explanation:** Recursively enforces BST constraints by carrying lower/upper bounds to children. Each node must be greater than all values in its left ancestors (low) and less than all in its right ancestors (high).\n**Complexity:** Time: O(n); Space: O(h) recursion, h=height.\n**Example:**\nInput: root of [2,1,3]\nOutput: true\n**Notes:**\n- Handles duplicates by requiring strict inequalities; relax if duplicates allowed on one side.\n- Use iterative stack if recursion depth may overflow.\n- Ensure node structure has `val`, `left`, `right` fields.", "category": "algorithm", "language": "javascript"}
{"prompt": "Write TypeScript code to solve: Count islands in a grid", "response": "typescript\n```typescript\nfunction numIslands(grid: string[][]): number {\n  if (!grid.length) return 0;\n  const rows = grid.length, cols = grid[0].length;\n  let count = 0;\n  const dirs = [[1,0],[-1,0],[0,1],[0,-1]];\n\n  const dfs = (r: number, c: number) => {\n    if (r < 0 || c < 0 || r >= rows || c >= cols || grid[r][c] !== '1') return;\n    grid[r][c] = '0';\n    for (const [dr, dc] of dirs) dfs(r + dr, c + dc);\n  };\n\n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      if (grid[r][c] === '1') {\n        count++;\n        dfs(r, c);\n      }\n    }\n  }\n  return count;\n}\n```\n**Explanation:** Scans the grid, launching DFS from each unvisited land cell ('1') to sink its entire island to '0'. Counts how many times DFS is triggered, which equals the number of islands.\n**Complexity:** Time: O(RC); Space: O(RC) recursion stack in worst case.\n**Example:**\nInput: [[\"1\",\"1\",\"0\"],[\"0\",\"1\",\"0\"],[\"1\",\"0\",\"1\"]]\nOutput: 3\n**Notes:**\n- Replace DFS with iterative stack to avoid deep recursion on large grids.\n- Mutates the grid to mark visited; clone first if you need to preserve input.\n- For 8-direction adjacency, extend dirs accordingly.", "category": "algorithm", "language": "typescript"}
{"prompt": "Write Python code to solve: Maximum subarray sum (Kadane)", "response": "python\n```python\ndef max_subarray(nums):\n    best = curr = nums[0]\n    for n in nums[1:]:\n        curr = max(n, curr + n)\n        best = max(best, curr)\n    return best\n```\n**Explanation:** Kadane’s algorithm keeps a running best ending at each position (`curr`) and tracks the global maximum (`best`). At each element, decide whether to start fresh or extend the current subarray.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\n**Notes:**\n- Works even if all numbers are negative; returns the largest element.\n- To recover indices, track start/end positions when updating best.\n- Requires non-empty array; add guard if inputs may be empty.", "category": "algorithm", "language": "python"}
{"prompt": "Write Java code to solve: Word ladder problem", "response": "java\n```java\nimport java.util.*;\n\npublic class WordLadder {\n    public static int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> dict = new HashSet<>(wordList);\n        if (!dict.contains(endWord)) return 0;\n        Queue<String> q = new ArrayDeque<>();\n        q.add(beginWord);\n        Set<String> visited = new HashSet<>();\n        visited.add(beginWord);\n        int steps = 1;\n        while (!q.isEmpty()) {\n            int sz = q.size();\n            for (int i = 0; i < sz; i++) {\n                String word = q.poll();\n                if (word.equals(endWord)) return steps;\n                char[] chars = word.toCharArray();\n                for (int pos = 0; pos < chars.length; pos++) {\n                    char original = chars[pos];\n                    for (char c = 'a'; c <= 'z'; c++) {\n                        if (c == original) continue;\n                        chars[pos] = c;\n                        String next = new String(chars);\n                        if (dict.contains(next) && visited.add(next)) {\n                            q.add(next);\n                        }\n                    }\n                    chars[pos] = original;\n                }\n            }\n            steps++;\n        }\n        return 0;\n    }\n}\n```\n**Explanation:** BFS over one-letter transformations contained in the dictionary. Tracks visited words to avoid cycles; the first time `endWord` is reached yields the shortest ladder length.\n**Complexity:** Time: O(N * L * 26) where N is dictionary size and L word length; Space: O(N) for visited/queue.\n**Example:**\nInput: begin=\"hit\", end=\"cog\", list=[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\nOutput: 5\n**Notes:**\n- Returns 0 if no transformation exists or endWord missing.\n- For speed on large dicts, use bidirectional BFS.\n- Assumes all words are same length; filter otherwise.", "category": "algorithm", "language": "java"}
{"prompt": "Write TypeScript code to solve: Longest increasing subsequence", "response": "typescript\n```typescript\nexport function lengthOfLIS(nums: number[]): number {\n  const tails: number[] = [];\n  for (const x of nums) {\n    let lo = 0, hi = tails.length;\n    while (lo < hi) {\n      const mid = (lo + hi) >> 1;\n      if (tails[mid] < x) lo = mid + 1; else hi = mid;\n    }\n    tails[lo] = x;\n  }\n  return tails.length;\n}\n```\n**Explanation:** Maintains minimal tail values for increasing subsequences of each length. Binary searches the insertion point for each number; extending tails grows the LIS length, replacing a tail keeps subsequences optimal.\n**Complexity:** Time: O(n log n); Space: O(n).\n**Example:**\nInput: [10,9,2,5,3,7,101,18]\nOutput: 4\n**Notes:**\n- Change `<` to `<=` for non-decreasing sequences.\n- To recover the subsequence, track predecessors and tail indices.\n- Handles empty input (returns 0).", "category": "algorithm", "language": "typescript"}
{"prompt": "Write Java code to solve: Validate binary search tree", "response": "java\n```java\npublic class ValidateBST {\n    static class TreeNode { int val; TreeNode left, right; TreeNode(int v){val=v;} }\n\n    public static boolean isValidBST(TreeNode root) {\n        return helper(root, null, null);\n    }\n    private static boolean helper(TreeNode node, Integer low, Integer high) {\n        if (node == null) return true;\n        if ((low != null && node.val <= low) || (high != null && node.val >= high)) return false;\n        return helper(node.left, low, node.val) && helper(node.right, node.val, high);\n    }\n}\n```\n**Explanation:** Recursively enforces BST bounds: each node must be greater than all left ancestors (low) and less than all right ancestors (high). Any violation returns false.\n**Complexity:** Time: O(n); Space: O(h) recursion stack.\n**Example:**\nInput: [2,1,3]\nOutput: true\n**Notes:**\n- Strict inequalities forbid duplicates; adjust if duplicates allowed on one side.\n- Use iterative inorder traversal if concerned about stack depth.\n- Ensure TreeNode structure matches your environment.", "category": "algorithm", "language": "java"}
{"prompt": "Implement edit distance (Levenshtein) using DP in Python with detailed comments", "response": "python\n```python\ndef edit_distance(a: str, b: str) -> int:\n    m, n = len(a), len(b)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            cost = 0 if a[i - 1] == b[j - 1] else 1\n            dp[i][j] = min(\n                dp[i - 1][j] + 1,      # deletion\n                dp[i][j - 1] + 1,      # insertion\n                dp[i - 1][j - 1] + cost  # substitution\n            )\n    return dp[m][n]\n```\n**Explanation:** Classic Levenshtein dynamic programming: `dp[i][j]` is the edit distance between prefixes `a[:i]` and `b[:j]`. Initializes base rows/cols for empty strings, then fills using insertion, deletion, substitution transitions.\n**Complexity:** Time: O(mn); Space: O(mn) (optimize to O(min(m, n)) with rolling rows).\n**Example:**\nInput: a=\"kitten\", b=\"sitting\"\nOutput: 3\n**Notes:**\n- Use Damerau-Levenshtein to allow transpositions if needed.\n- For memory savings, keep only two rows at a time.\n- Handles empty strings naturally via base initialization.", "category": "algorithm", "language": "python"}
{"prompt": "Write TypeScript code to solve: Find the median of two sorted arrays", "response": "typescript\n```typescript\nexport function findMedianSortedArrays(a: number[], b: number[]): number {\n  if (a.length > b.length) return findMedianSortedArrays(b, a);\n  const m = a.length, n = b.length;\n  let lo = 0, hi = m;\n  while (lo <= hi) {\n    const i = (lo + hi) >> 1;\n    const j = ((m + n + 1) >> 1) - i;\n    const maxLeftA = i === 0 ? -Infinity : a[i - 1];\n    const minRightA = i === m ? Infinity : a[i];\n    const maxLeftB = j === 0 ? -Infinity : b[j - 1];\n    const minRightB = j === n ? Infinity : b[j];\n    if (maxLeftA <= minRightB && maxLeftB <= minRightA) {\n      if ((m + n) % 2 === 0) {\n        return (Math.max(maxLeftA, maxLeftB) + Math.min(minRightA, minRightB)) / 2;\n      }\n      return Math.max(maxLeftA, maxLeftB);\n    }\n    if (maxLeftA > minRightB) hi = i - 1; else lo = i + 1;\n  }\n  throw new Error('Input arrays not sorted');\n}\n```\n**Explanation:** Binary searches the smaller array for a partition where left parts are <= right parts across both arrays. Computes the median from border elements depending on total parity.\n**Complexity:** Time: O(log(min(m,n))); Space: O(1).\n**Example:**\nInput: [1,3], [2]\nOutput: 2\n**Notes:**\n- Handles empty arrays via sentinels +/-Infinity.\n- Throws if inputs are unsorted.\n- Works for even/odd combined lengths without extra passes.", "category": "algorithm", "language": "typescript"}
{"prompt": "Implement A* pathfinding in JavaScript with detailed comments", "response": "javascript\n```javascript\nfunction aStar(grid, start, goal) {\n  const rows = grid.length, cols = grid[0].length;\n  const inBounds = (r, c) => r >= 0 && c >= 0 && r < rows && c < cols;\n  const dirs = [[1,0],[-1,0],[0,1],[0,-1]];\n  const h = (r, c) => Math.abs(r - goal[0]) + Math.abs(c - goal[1]);\n\n  const open = new MinHeap();\n  const gScore = Array.from({ length: rows }, () => Array(cols).fill(Infinity));\n  gScore[start[0]][start[1]] = 0;\n  open.push({ r: start[0], c: start[1], f: h(start[0], start[1]) });\n\n  while (!open.isEmpty()) {\n    const { r, c } = open.pop();\n    if (r === goal[0] && c === goal[1]) return true;\n    for (const [dr, dc] of dirs) {\n      const nr = r + dr, nc = c + dc;\n      if (!inBounds(nr, nc) || grid[nr][nc] === 1) continue;\n      const tentative = gScore[r][c] + 1;\n      if (tentative < gScore[nr][nc]) {\n        gScore[nr][nc] = tentative;\n        open.push({ r: nr, c: nc, f: tentative + h(nr, nc) });\n      }\n    }\n  }\n  return false;\n}\n\nclass MinHeap {\n  constructor() { this.data = []; }\n  isEmpty() { return this.data.length === 0; }\n  push(x) { this.data.push(x); this._up(this.data.length - 1); }\n  pop() {\n    if (!this.data.length) return null;\n    const root = this.data[0];\n    const last = this.data.pop();\n    if (this.data.length && last) { this.data[0] = last; this._down(0); }\n    return root;\n  }\n  _up(i) { while (i>0) { const p=(i-1)>>1; if (this.data[p].f <= this.data[i].f) break; [this.data[p],this.data[i]]=[this.data[i],this.data[p]]; i=p; } }\n  _down(i) {\n    const n=this.data.length;\n    while (true) {\n      let s=i; const l=2*i+1, r=2*i+2;\n      if (l<n && this.data[l].f < this.data[s].f) s=l;\n      if (r<n && this.data[r].f < this.data[s].f) s=r;\n      if (s===i) break; [this.data[i],this.data[s]]=[this.data[s],this.data[i]]; i=s;\n    }\n  }\n}\n```\n**Explanation:** A* on a grid using Manhattan heuristic, skipping walls (cells=1). `gScore` holds best-known path cost; the heap orders nodes by f = g + h. Returns true when the goal is popped.\n**Complexity:** Time: O(E log V); Space: O(V) for scores and heap.\n**Example:**\nInput: grid of 0/1, start [0,0], goal [1,1]\nOutput: true if reachable\n**Notes:**\n- For actual path reconstruction, store parents.\n- Adjust heuristic and movement for diagonals or weighted grids.\n- Validate start/goal walkability before running.", "category": "algorithm", "language": "javascript"}
{"prompt": "Write Java code to solve: Count islands in a grid", "response": "java\n```java\nimport java.util.*;\n\npublic class NumIslands {\n    public static int numIslands(char[][] grid) {\n        int rows = grid.length, cols = grid[0].length;\n        int count = 0;\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < cols; c++) {\n                if (grid[r][c] == '1') {\n                    count++;\n                    Queue<int[]> q = new ArrayDeque<>();\n                    q.add(new int[]{r,c});\n                    grid[r][c] = '0';\n                    while (!q.isEmpty()) {\n                        int[] cur = q.poll();\n                        for (int[] d : dirs) {\n                            int nr = cur[0] + d[0], nc = cur[1] + d[1];\n                            if (nr>=0 && nc>=0 && nr<rows && nc<cols && grid[nr][nc]=='1') {\n                                grid[nr][nc]='0';\n                                q.add(new int[]{nr,nc});\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return count;\n    }\n}\n```\n**Explanation:** Scans the grid; upon finding land, increments the island count and BFS-flood-fills to mark all connected land as water, preventing recounting. Uses four-direction adjacency.\n**Complexity:** Time: O(RC); Space: O(RC) worst-case for the queue.\n**Example:**\nInput: [['1','1','0'],['0','1','0'],['1','0','1']]\nOutput: 3\n**Notes:**\n- Mutates the grid; clone if mutation is undesired.\n- Replace BFS with DFS if preferred; ensure recursion depth is safe.\n- Extend dirs for diagonal adjacency if required.", "category": "algorithm", "language": "java"}
{"prompt": "Implement k-way merge using heaps in Rust with detailed comments", "response": "rust\n```rust\nuse std::cmp::Reverse;\nuse std::collections::BinaryHeap;\n\npub fn k_way_merge(lists: Vec<Vec<i32>>) -> Vec<i32> {\n    let mut heap: BinaryHeap<(Reverse<i32>, usize, usize)> = BinaryHeap::new();\n    for (i, list) in lists.iter().enumerate() {\n        if let Some(&val) = list.get(0) {\n            heap.push((Reverse(val), i, 0));\n        }\n    }\n    let mut out = Vec::new();\n    while let Some((Reverse(val), li, idx)) = heap.pop() {\n        out.push(val);\n        let next = idx + 1;\n        if let Some(&v) = lists[li].get(next) {\n            heap.push((Reverse(v), li, next));\n        }\n    }\n    out\n}\n```\n**Explanation:** Initializes a min-heap with the first element of each list, repeatedly extracts the smallest, appends it to output, and pushes the next element from that list. This preserves sorted order across k sorted inputs.\n**Complexity:** Time: O(N log k) where N is total elements; Space: O(k) for the heap plus output.\n**Example:**\nInput: [[1,4],[2,3],[0,5]]\nOutput: [0,1,2,3,4,5]\n**Notes:**\n- Skips empty lists gracefully.\n- Wrap values with `Reverse` to simulate a min-heap using `BinaryHeap`'s max-heap default.\n- For large merges, stream output instead of collecting into a Vec.", "category": "algorithm", "language": "rust"}
{"prompt": "Write Python code to solve: Count islands in a grid", "response": "python\n```python\nfrom typing import List\n\ndef num_islands(grid: List[List[str]]) -> int:\n    if not grid:\n        return 0\n    rows, cols = len(grid), len(grid[0])\n    dirs = [(1,0),(-1,0),(0,1),(0,-1)]\n\n    def dfs(r: int, c: int) -> None:\n        if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] != '1':\n            return\n        grid[r][c] = '0'\n        for dr, dc in dirs:\n            dfs(r + dr, c + dc)\n\n    count = 0\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '1':\n                count += 1\n                dfs(r, c)\n    return count\n```\n**Explanation:** DFS flood-fills each discovered land cell to mark its entire island, incrementing a counter for each DFS launch. Mutates grid to mark visited cells as water.\n**Complexity:** Time: O(RC); Space: O(RC) worst-case recursion.\n**Example:**\nInput: [['1','1','0'],['0','1','0'],['1','0','1']]\nOutput: 3\n**Notes:**\n- Use an explicit stack to avoid recursion depth issues on large grids.\n- For 8-direction adjacency, extend dirs accordingly.\n- Clone the grid if mutation is undesirable.", "category": "algorithm", "language": "python"}
{"prompt": "Implement union-find with path compression in C++ with detailed comments", "response": "c++\n```cpp\n#include <vector>\n#include <numeric>\n\nclass UnionFind {\npublic:\n    explicit UnionFind(int n) : parent_(n), rank_(n, 0) {\n        std::iota(parent_.begin(), parent_.end(), 0);\n    }\n    int find(int x) {\n        if (parent_[x] != x) parent_[x] = find(parent_[x]);\n        return parent_[x];\n    }\n    void unite(int a, int b) {\n        a = find(a); b = find(b);\n        if (a == b) return;\n        if (rank_[a] < rank_[b]) std::swap(a, b);\n        parent_[b] = a;\n        if (rank_[a] == rank_[b]) rank_[a]++;\n    }\n};\n```\n**Explanation:** Disjoint set union with path compression and union by rank for efficient connectivity queries.\n**Complexity:** Time: Amortized ~O(α(n)) per op; Space: O(n).\n**Example:**\nInput: unite(0,1); unite(1,2); find(2)\nOutput: representative of merged set\n**Notes:**\n- Add `connected(a,b)` for readability.\n- Capacity fixed at construction; reinitialize to grow.\n- Not thread-safe; add locking for concurrent use.", "category": "algorithm", "language": "c++"}
{"prompt": "Write JavaScript code to solve: Detect a cycle in a linked list", "response": "javascript\n```javascript\nfunction ListNode(val, next = null) {\n  this.val = val;\n  this.next = next;\n}\n\nfunction hasCycle(head) {\n  let slow = head, fast = head;\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n    if (slow === fast) return true;\n  }\n  return false;\n}\n```\n**Explanation:** Uses Floyd’s tortoise-hare pointers; if the fast pointer laps the slow one, a cycle exists. Terminates when reaching list end (no cycle).\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: 1 -> 2 -> 3 -> 2\nOutput: true\n**Notes:**\n- Handles empty/one-node lists safely.\n- To locate the cycle entry, reset one pointer to head after detection and step both one node at a time.\n- Leaves the list structure unchanged.", "category": "algorithm", "language": "javascript"}
{"prompt": "Implement topological sort with cycle detection in Go with detailed comments", "response": "go\n```go\npackage main\n\nimport \"container/list\"\n\n// Topological sort with cycle detection; returns order and ok flag.\nfunc TopoSort(n int, edges [][2]int) ([]int, bool) {\n    adj := make([][]int, n)\n    indeg := make([]int, n)\n    for _, e := range edges {\n        u, v := e[0], e[1]\n        adj[u] = append(adj[u], v)\n        indeg[v]++\n    }\n    q := list.New()\n    for i, d := range indeg {\n        if d == 0 {\n            q.PushBack(i)\n        }\n    }\n    order := make([]int, 0, n)\n    for q.Len() > 0 {\n        e := q.Front()\n        q.Remove(e)\n        u := e.Value.(int)\n        order = append(order, u)\n        for _, v := range adj[u] {\n            indeg[v]--\n            if indeg[v] == 0 {\n                q.PushBack(v)\n            }\n        }\n    }\n    if len(order) != n {\n        return nil, false\n    }\n    return order, true\n}\n```\n**Explanation:** Kahn’s algorithm: build indegrees, queue zero-indegree nodes, pop/append to order, and decrement neighbors. If not all nodes are processed, a cycle exists.\n**Complexity:** Time: O(V+E); Space: O(V+E).\n**Example:**\nInput: n=3, edges={(0,1),(1,2)}\nOutput: order [0,1,2], ok=true\n**Notes:**\n- Validate node indices in production code.\n- Multiple valid orders may exist; queue order determines which is returned.\n- Use DFS variant if recursion depth is manageable.", "category": "algorithm", "language": "go"}
{"prompt": "Implement quick sort in Rust with detailed comments", "response": "rust\n```rust\npub fn quicksort(arr: &mut [i32]) {\n    if arr.len() <= 1 { return; }\n    let pivot = partition(arr);\n    let (left, right) = arr.split_at_mut(pivot);\n    quicksort(left);\n    quicksort(&mut right[1..]);\n}\n\nfn partition(arr: &mut [i32]) -> usize {\n    let len = arr.len();\n    let pivot = arr[len - 1];\n    let mut i = 0;\n    for j in 0..len-1 {\n        if arr[j] <= pivot {\n            arr.swap(i, j);\n            i += 1;\n        }\n    }\n    arr.swap(i, len - 1);\n    i\n}\n```\n**Explanation:** In-place quicksort using Lomuto partition: choose last element as pivot, partition slice so elements ≤ pivot come before it, then recursively sort sub-slices on each side.\n**Complexity:** Time: O(n log n) average, O(n²) worst; Space: O(log n) stack.\n**Example:**\nInput: [3,1,4,1]\nOutput: [1,1,3,4]\n**Notes:**\n- Randomize pivot to reduce worst-case chance.\n- For tiny partitions, switch to insertion sort to improve constants.\n- Not stable; equal elements may reorder.", "category": "algorithm", "language": "rust"}
{"prompt": "Implement merge sort in Rust with detailed comments", "response": "rust\n```rust\npub fn merge_sort(arr: &mut [i32]) {\n    let n = arr.len();\n    if n <= 1 { return; }\n    let mid = n / 2;\n    merge_sort(&mut arr[..mid]);\n    merge_sort(&mut arr[mid..]);\n    let mut merged = arr.to_vec();\n    let (left, right) = merged.split_at_mut(mid);\n    left.copy_from_slice(&arr[..mid]);\n    right.copy_from_slice(&arr[mid..]);\n    merge(left, right, arr);\n}\n\nfn merge(left: &[i32], right: &[i32], out: &mut [i32]) {\n    let (mut i, mut j, mut k) = (0, 0, 0);\n    while i < left.len() && j < right.len() {\n        if left[i] <= right[j] {\n            out[k] = left[i]; i += 1;\n        } else {\n            out[k] = right[j]; j += 1;\n        }\n        k += 1;\n    }\n    while i < left.len() { out[k] = left[i]; i += 1; k += 1; }\n    while j < right.len() { out[k] = right[j]; j += 1; k += 1; }\n}\n```\n**Explanation:** Recursively splits the array, sorts halves, and merges them with a temporary buffer copied from the original. Stable and deterministic regardless of input order.\n**Complexity:** Time: O(n log n); Space: O(n) for the buffer plus O(log n) stack.\n**Example:**\nInput: [5,2,4,6,1,3]\nOutput: [1,2,3,4,5,6]\n**Notes:**\n- For large inputs, consider iterative bottom-up merges to reduce recursion.\n- To minimize allocations, reuse a scratch buffer across calls.\n- Stable ordering keeps equal elements in their original relative order.", "category": "algorithm", "language": "rust"}
{"prompt": "Implement Dijkstra's shortest path in Java with detailed comments", "response": "java\n```java\nimport java.util.*;\n\npublic class Dijkstra {\n    public static int[] shortestPaths(int n, List<int[]> edges, int source) {\n        List<List<int[]>> adj = new ArrayList<>();\n        for (int i = 0; i < n; i++) adj.add(new ArrayList<>());\n        for (int[] e : edges) {\n            int u = e[0], v = e[1], w = e[2];\n            adj.get(u).add(new int[]{v, w});\n        }\n        int INF = Integer.MAX_VALUE / 4;\n        int[] dist = new int[n];\n        Arrays.fill(dist, INF);\n        dist[source] = 0;\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\n        pq.add(new int[]{0, source});\n        while (!pq.isEmpty()) {\n            int[] cur = pq.poll();\n            int d = cur[0], u = cur[1];\n            if (d != dist[u]) continue; // stale entry\n            for (int[] nxt : adj.get(u)) {\n                int v = nxt[0], w = nxt[1];\n                if (d + w < dist[v]) {\n                    dist[v] = d + w;\n                    pq.add(new int[]{dist[v], v});\n                }\n            }\n        }\n        return dist;\n    }\n}\n```\n**Explanation:** Builds adjacency lists, initializes distances to INF, and uses a min-heap to extract the closest node. Skips stale heap entries and relaxes outgoing edges, updating distances and pushing improved estimates.\n**Complexity:** Time: O((V + E) log V); Space: O(V + E).\n**Example:**\nInput: n=3, edges=[(0,1,2),(1,2,1),(0,2,5)], source=0\nOutput: dist = [0,2,3]\n**Notes:**\n- Requires non-negative weights; negative edges break Dijkstra.\n- Track parents to reconstruct paths if needed.\n- For dense graphs, consider adjacency matrix + O(V^2) approach.", "category": "algorithm", "language": "java"}
{"prompt": "Write Java code to solve: Longest increasing subsequence", "response": "java\n```java\nimport java.util.*;\n\npublic class LongestIncreasingSubsequence {\n    public static int lengthOfLIS(int[] nums) {\n        int[] tails = new int[nums.length];\n        int size = 0;\n        for (int x : nums) {\n            int i = Arrays.binarySearch(tails, 0, size, x);\n            if (i < 0) i = -i - 1; // lower bound\n            tails[i] = x;\n            if (i == size) size++;\n        }\n        return size;\n    }\n}\n```\n**Explanation:** Maintains `tails[len]` as the smallest tail of an increasing subsequence of length `len+1`. For each number, binary search finds its position; replacing tails preserves minimal tails, and extending increases LIS length.\n**Complexity:** Time: O(n log n); Space: O(n) for tails.\n**Example:**\nInput: [10,9,2,5,3,7,101,18]\nOutput: 4\n**Notes:**\n- For non-decreasing LIS, adjust binary search to upper_bound.\n- To reconstruct the sequence, track predecessors alongside tails indices.\n- Handles empty input (size remains 0).", "category": "algorithm", "language": "java"}
{"prompt": "Write TypeScript code to solve: Rotate a matrix 90 degrees", "response": "typescript\n```typescript\nexport function rotate(matrix: number[][]): void {\n  const n = matrix.length;\n  // transpose\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\n    }\n  }\n  // reverse rows\n  for (const row of matrix) row.reverse();\n}\n```\n**Explanation:** Rotates a square matrix 90° clockwise in-place by transposing, then reversing each row.\n**Complexity:** Time: O(n²); Space: O(1) extra.\n**Example:**\nInput: [[1,2],[3,4]]\nOutput: [[3,1],[4,2]]\n**Notes:**\n- Requires square matrix; adjust for rectangular cases.\n- For counterclockwise rotation, transpose then reverse columns instead.\n- Ensure matrix is non-jagged to avoid index errors.", "category": "algorithm", "language": "typescript"}
{"prompt": "Implement breadth-first search (BFS) in Java with detailed comments", "response": "java\n```java\nimport java.util.*;\n\npublic class BreadthFirstSearch {\n    /**\n     * Return BFS traversal order from start on an adjacency-list graph.\n     */\n    public static List<Integer> bfs(List<List<Integer>> graph, int start) {\n        List<Integer> order = new ArrayList<>();\n        if (start < 0 || start >= graph.size()) return order;\n        boolean[] visited = new boolean[graph.size()];\n        Queue<Integer> q = new ArrayDeque<>();\n        visited[start] = true;\n        q.add(start);\n        while (!q.isEmpty()) {\n            int node = q.poll();\n            order.add(node);\n            for (int nei : graph.get(node)) {\n                if (!visited[nei]) {\n                    visited[nei] = true;\n                    q.add(nei);\n                }\n            }\n        }\n        return order;\n    }\n}\n```\n**Explanation:** Typical BFS with a queue and visited array. Start node enqueued and marked; pop nodes in FIFO order, visit neighbors, mark them, and enqueue to explore by layers.\n**Complexity:** Time: O(V + E); Space: O(V) for visited and queue.\n**Example:**\nInput: graph=[[1,2],[3],[3],[]], start=0\nOutput: [0,1,2,3]\n**Notes:**\n- Bounds-check start to avoid exceptions.\n- For shortest paths in unweighted graphs, store parent pointers alongside visited.\n- Works for directed or undirected graphs depending on adjacency input.", "category": "algorithm", "language": "java"}
{"prompt": "Implement A* pathfinding in Rust with detailed comments", "response": "rust\n```rust\nuse std::cmp::Ordering;\nuse std::collections::BinaryHeap;\n\n#[derive(Eq, PartialEq)]\nstruct Node {\n    f: i32,\n    g: i32,\n    pos: (i32, i32),\n}\n\nimpl Ord for Node {\n    fn cmp(&self, other: &Self) -> Ordering {\n        other.f.cmp(&self.f) // min-heap via reverse\n    }\n}\n\nimpl PartialOrd for Node {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\npub fn a_star(grid: &[Vec<i32>], start: (i32, i32), goal: (i32, i32)) -> Option<i32> {\n    let rows = grid.len() as i32;\n    let cols = grid[0].len() as i32;\n    let dirs = [(1,0),(-1,0),(0,1),(0,-1)];\n    let h = |r: i32, c: i32| (r - goal.0).abs() + (c - goal.1).abs();\n    let mut open = BinaryHeap::new();\n    open.push(Node { f: h(start.0, start.1), g: 0, pos: start });\n    let mut gscore = vec![vec![i32::MAX; cols as usize]; rows as usize];\n    gscore[start.0 as usize][start.1 as usize] = 0;\n\n    while let Some(Node { f: _, g, pos }) = open.pop() {\n        if pos == goal {\n            return Some(g);\n        }\n        let (r, c) = pos;\n        for (dr, dc) in dirs {\n            let nr = r + dr;\n            let nc = c + dc;\n            if nr < 0 || nc < 0 || nr >= rows || nc >= cols { continue; }\n            if grid[nr as usize][nc as usize] == 1 { continue; }\n            let tentative = g + 1;\n            if tentative < gscore[nr as usize][nc as usize] {\n                gscore[nr as usize][nc as usize] = tentative;\n                let fscore = tentative + h(nr, nc);\n                open.push(Node { f: fscore, g: tentative, pos: (nr, nc) });\n            }\n        }\n    }\n    None\n}\n```\n**Explanation:** A* on a grid: uses a min-heap ordered by f = g + heuristic (Manhattan). Skips walls (cells with 1). Updates g-scores when a better path is found and pushes neighbors with their new f-score. Returns path cost if the goal is reached.\n**Complexity:** Time: O(E log V); Space: O(V) for scores and heap.\n**Example:**\nInput: grid [[0,0],[0,0]], start (0,0), goal (1,1)\nOutput: Some(2)\n**Notes:**\n- Heuristic assumes 4-direction movement; adjust for diagonals.\n- For path reconstruction, store parents when relaxing edges.\n- Ensure start/goal are walkable before running.", "category": "algorithm", "language": "rust"}
{"prompt": "Find and fix the bug in this Python code:\nfor (let i = 0; i <= arr.length; i++) { console.log(arr[i]); }\nThe code should return correct value for missing elements", "response": "python\n```python\ndef print_array(arr):\n    if arr is None:\n        return\n    for i in range(len(arr)):\n        print(arr[i])\n```\n**Explanation:** The original loop used `i <= arr.length`, which iterated one element too far. Here we iterate with Python's `range(len(arr))`, which stops at the last valid index, preventing out-of-bounds access.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: `[1, 2, 3]`\nOutput: prints `1\\n2\\n3`\n**Notes:**\n- Safely returns if `arr` is `None` or empty; loop naturally does nothing for empty arrays.\n- For large arrays, consider chunked output or logging instead of printing.\n- In JavaScript, the equivalent fix is `for (let i = 0; i < arr.length; i++)`.", "category": "bug_fix", "language": "python"}
{"prompt": "Find and fix the bug in this JavaScript code:\ndef factorial(n):\n    if n == 1:\n        return 1\n    return n * factorial(n-1)\nThe code should return correct value for missing elements", "response": "javascript\n```javascript\n// Corrected factorial with proper base case and validation\nfunction factorial(n) {\n  if (!Number.isInteger(n) || n < 0) throw new Error('n must be a non-negative integer');\n  let result = 1;\n  for (let i = 2; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n```\n**Explanation:** Adds validation and handles `n = 0` by returning 1. The original recursive snippet lacked a base case for zero and used Python syntax; this JavaScript version iterates safely and returns defined results for all non-negative integers.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: `factorial(0)`\nOutput: `1`\n**Notes:**\n- Iterative form avoids recursion depth limits.\n- Throws on negative or non-integer input to prevent incorrect results.\n- For large `n`, consider BigInt to avoid overflow.", "category": "bug_fix", "language": "javascript"}
{"prompt": "Find and fix the bug in this JavaScript code:\nfor i in range(len(nums)):\n    if nums[i] == target:\n        return i\n    return -1\nThe code should handle n=0 correctly", "response": "javascript\n```javascript\n// Corrected linear search with proper loop and default return\nfunction indexOf(nums, target) {\n  if (!Array.isArray(nums)) return -1;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === target) return i;\n  }\n  return -1;\n}\n```\n**Explanation:** The original code returned -1 inside the loop, exiting after the first element. This version loops through all elements with `i < nums.length` and only returns -1 after exhausting the array, safely handling empty arrays (n=0).\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: nums = [4, 2, 7], target = 7\nOutput: 2\n**Notes:**\n- Works for empty arrays, immediately returning -1.\n- Strict equality avoids type coercion surprises; adjust if loose matching is desired.\n- For large datasets with repeated lookups, consider building a map for O(1) average access.", "category": "bug_fix", "language": "javascript"}
{"prompt": "Find and fix the bug in this Python code:\ndef factorial(n):\n    if n == 1:\n        return 1\n    return n * factorial(n-1)\nThe code should return correct value for missing elements", "response": "python\n```python\ndef factorial(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result\n```\n**Explanation:** Adds validation and handles `n = 0` by returning 1 (loop skips). The original recursive snippet lacked the 0 base case and used Python indentation incorrectly for the missing-elements scenario; this iterative version is safe and straightforward.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: 0\nOutput: 1\n**Notes:**\n- Iterative approach avoids recursion depth issues for large n.\n- For very large results, consider using `math.prod(range(1, n+1))` for brevity; Python ints are unbounded.\n- Negative inputs raise immediately to avoid undefined behavior.", "category": "bug_fix", "language": "python"}
{"prompt": "Find and fix the bug in this Python code:\nif (head.next == null) return false;\nwhile (head) {\n    head = head.next.next;\n}\nThe code should not go out of bounds", "response": "python\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\ndef has_cycle_safe(head: ListNode) -> bool:\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow is fast:\n            return True\n    return False\n```\n**Explanation:** Replaces the unsafe pointer jumping with Floyd's cycle detection, advancing `fast` two steps only when `fast` and `fast.next` are non-null to avoid out-of-bounds.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: 1 -> 2 -> 3 -> (back to 2)\nOutput: True\n**Notes:**\n- Works for empty and single-node lists without throwing.\n- If you just need to check for null next, guard before `next.next` access as shown.\n- To find the cycle start, reset one pointer to head after detection and advance both one step at a time.", "category": "bug_fix", "language": "python"}
{"prompt": "Find and fix the bug in this Java code:\nfor (let i = 0; i <= arr.length; i++) { console.log(arr[i]); }\nThe code should return correct value for missing elements", "response": "java\n```java\npublic class SafeArrayPrinter {\n    public static void print(int[] arr) {\n        if (arr == null) return;\n        for (int i = 0; i < arr.length; i++) {\n            System.out.println(arr[i]);\n        }\n    }\n}\n```\n**Explanation:** Fixes the off-by-one loop (`<= arr.length`) that accessed beyond the array. Uses `< arr.length` and guards null input.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: [1, 2, 3]\nOutput: prints 1, 2, 3 on separate lines\n**Notes:**\n- For empty arrays, the loop runs zero times safely.\n- Replace `System.out` with a logger for production code.\n- Add bounds checks if user-provided indices are involved.", "category": "bug_fix", "language": "java"}
{"prompt": "Find and fix the bug in this Java code:\nfor (let i = 0; i <= arr.length; i++) { console.log(arr[i]); }\nThe code should not go out of bounds", "response": "java\n```java\npublic class SafeLoop {\n    public static void print(int[] arr) {\n        if (arr == null) return;\n        for (int i = 0; i < arr.length; i++) {\n            System.out.println(arr[i]);\n        }\n    }\n}\n```\n**Explanation:** Changes the erroneous `i <= arr.length` loop to `i < arr.length` and guards null input, preventing out-of-bounds access.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: [10, 20]\nOutput: prints 10 then 20\n**Notes:**\n- Works for empty arrays (loop not entered).\n- Replace printing with logging or accumulation as needed.\n- Add try/catch if downstream output operations may fail.", "category": "bug_fix", "language": "java"}
{"prompt": "Find and fix the bug in this JavaScript code:\nif (head.next == null) return false;\nwhile (head) {\n    head = head.next.next;\n}\nThe code should avoid null pointer exceptions", "response": "javascript\n```javascript\nfunction hasCycle(head) {\n  let slow = head;\n  let fast = head;\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n    if (slow === fast) return true;\n  }\n  return false;\n}\n```\n**Explanation:** The original loop dereferenced `head.next.next` without null checks. This uses Floyd's cycle detection with guards on `fast` and `fast.next` to avoid null-pointer errors while safely detecting cycles.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: 1 -> 2 -> 3 -> 2 (cycle)\nOutput: true\n**Notes:**\n- Works for empty or single-node lists (returns false).\n- To find cycle entry, reset one pointer to head after detection and move both one step at a time.\n- Does not modify the list structure.", "category": "bug_fix", "language": "javascript"}
{"prompt": "Find and fix the bug in this Python code:\nif (head.next == null) return false;\nwhile (head) {\n    head = head.next.next;\n}\nThe code should handle n=0 correctly", "response": "python\n```python\ndef has_cycle(head):\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow is fast:\n            return True\n    return False\n```\n**Explanation:** Guards null pointers by checking `fast` and `fast.next` before advancing two steps, preventing out-of-bounds when the list is empty (`n=0`) or of length 1. Uses Floyd's algorithm to detect cycles.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: head=None\nOutput: False\n**Notes:**\n- Works for all list sizes without throwing.\n- To find cycle entry, apply the standard two-phase approach after detection.\n- Leaves list structure unchanged.", "category": "bug_fix", "language": "python"}
{"prompt": "Find and fix the bug in this Python code:\nfor i in range(len(nums)):\n    if nums[i] == target:\n        return i\n    return -1\nThe code should return correct value for missing elements", "response": "python\n```python\ndef index_of(nums, target):\n    for i, val in enumerate(nums):\n        if val == target:\n            return i\n    return -1\n```\n**Explanation:** Moves the `return -1` outside the loop so the search scans the entire list. Uses Python's enumerate for clarity, returning -1 only if the target is absent.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: nums=[1,2,3], target=4\nOutput: -1\n**Notes:**\n- Works for empty lists (immediately returns -1).\n- For frequent lookups, consider building a dictionary of value->index for O(1) average access.\n- If multiple occurrences exist, returns the first index; adjust if last/any is needed.", "category": "bug_fix", "language": "python"}
{"prompt": "Find and fix the bug in this Python code:\nfor i in range(len(nums)):\n    if nums[i] == target:\n        return i\n    return -1\nThe code should not go out of bounds", "response": "python\n```python\ndef index_of(nums, target):\n    for i, val in enumerate(nums):\n        if val == target:\n            return i\n    return -1\n```\n**Explanation:** Moves the default `-1` return outside the loop so the entire list is scanned. This prevents early exit after the first element and avoids any out-of-bounds access.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: nums = [1, 2, 3], target = 3\nOutput: 2\n**Notes:**\n- Works for empty lists (returns -1 immediately).\n- For multiple matches, returns the first index; adjust if last occurrence is needed.\n- For repeated lookups, build a dict for O(1) average access.", "category": "bug_fix", "language": "python"}
{"prompt": "Find and fix the bug in this Python code:\nfor (let i = 0; i <= arr.length; i++) { console.log(arr[i]); }\nThe code should not go out of bounds", "response": "python\n```python\ndef print_array(arr):\n    if arr is None:\n        return\n    for i in range(len(arr)):\n        print(arr[i])\n```\n**Explanation:** The original loop used `<= arr.length`, causing an out-of-bounds access. Here we iterate with `range(len(arr))`, which stops before the end index, and guard against `None` input.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: [1, 2]\nOutput: prints 1 then 2\n**Notes:**\n- Works safely for empty arrays (no output).\n- Use logging instead of print for production environments.\n- For huge arrays, consider batching output to avoid overwhelming stdout.", "category": "bug_fix", "language": "python"}
{"prompt": "Find and fix the bug in this Python code:\nfor i in range(len(nums)):\n    if nums[i] == target:\n        return i\n    return -1\nThe code should avoid null pointer exceptions", "response": "python\n```python\ndef index_of(nums, target):\n    if nums is None:\n        return -1\n    for i, val in enumerate(nums):\n        if val == target:\n            return i\n    return -1\n```\n**Explanation:** Adds a None check to avoid dereferencing a null-like value, and places the default `-1` return after the loop so all elements are examined. This prevents premature returns and avoids attribute errors on missing input.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: nums=None, target=3\nOutput: -1\n**Notes:**\n- Works safely for empty lists (returns -1).\n- For repeated queries, prebuild a map for faster lookups.\n- Adjust to raise on None if silence is undesirable.", "category": "bug_fix", "language": "python"}
{"prompt": "Find and fix the bug in this Python code:\nif (head.next == null) return false;\nwhile (head) {\n    head = head.next.next;\n}\nThe code should return correct value for missing elements", "response": "python\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\ndef has_cycle(head: ListNode) -> bool:\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow is fast:\n            return True\n    return False\n```\n**Explanation:** Replaces unsafe `head.next.next` traversal with Floyd’s cycle detection that checks `fast` and `fast.next` before advancing two steps. Returns a boolean indicating presence of a cycle, covering empty or single-node lists safely.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: 1 -> 2 -> 3 -> 2\nOutput: True\n**Notes:**\n- Handles n=0 without throwing.\n- To find the cycle start, reset one pointer to head after detection and move both one step at a time.\n- Leaves the list unmodified.", "category": "bug_fix", "language": "python"}
{"prompt": "Find and fix the bug in this JavaScript code:\nfor i in range(len(nums)):\n    if nums[i] == target:\n        return i\n    return -1\nThe code should avoid null pointer exceptions", "response": "javascript\n```javascript\nfunction indexOfSafe(nums, target) {\n  if (!Array.isArray(nums)) return -1;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === target) return i;\n  }\n  return -1;\n}\n```\n**Explanation:** Checks that input is an array, iterates with `i < nums.length`, and returns -1 only after scanning all elements. This avoids null/undefined dereferences and out-of-bounds access.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: nums = [1, 2, 3], target = 4\nOutput: -1\n**Notes:**\n- For repeated lookups, use a map to speed up searches.\n- Strict equality prevents type-coercion surprises; adjust if needed.\n- Empty arrays return -1 immediately.", "category": "bug_fix", "language": "javascript"}
{"prompt": "Find and fix the bug in this JavaScript code:\nfor i in range(len(nums)):\n    if nums[i] == target:\n        return i\n    return -1\nThe code should return correct value for missing elements", "response": "javascript\n```javascript\nfunction indexOfFixed(nums, target) {\n  if (!Array.isArray(nums)) return -1;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === target) return i;\n  }\n  return -1;\n}\n```\n**Explanation:** Ensures the loop scans all elements using `i < nums.length` and only returns -1 after the search is exhausted, fixing the premature return in the original snippet.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: nums = [5, 6], target = 7\nOutput: -1\n**Notes:**\n- Returns the first occurrence; adjust if last is needed.\n- Works for empty arrays safely.\n- Strict equality avoids coercion surprises.", "category": "bug_fix", "language": "javascript"}
{"prompt": "Find and fix the bug in this Java code:\ndef factorial(n):\n    if n == 1:\n        return 1\n    return n * factorial(n-1)\nThe code should not go out of bounds", "response": "java\n```java\npublic class Factorial {\n    public static long factorial(int n) {\n        if (n < 0) throw new IllegalArgumentException(\"n must be non-negative\");\n        long result = 1;\n        for (int i = 2; i <= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n}\n```\n**Explanation:** Replaces the erroneous recursive snippet with an iterative implementation that handles n=0 correctly and validates input. Avoids out-of-bounds recursion or missing base cases.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: factorial(5)\nOutput: 120\n**Notes:**\n- Use BigInteger for large n to avoid overflow.\n- Returns 1 for n=0/1 per definition.\n- Iterative approach is stack-safe.", "category": "bug_fix", "language": "java"}
{"prompt": "Find and fix the bug in this JavaScript code:\ndef factorial(n):\n    if n == 1:\n        return 1\n    return n * factorial(n-1)\nThe code should handle n=0 correctly", "response": "javascript\n```javascript\n// Fixed factorial with proper base case and validation\nfunction factorial(n) {\n  if (!Number.isInteger(n) || n < 0) throw new Error('n must be a non-negative integer');\n  if (n === 0 || n === 1) return 1;\n  let result = 1;\n  for (let i = 2; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n```\n**Explanation:** Rewrites the pseudo-Python snippet as valid JavaScript, adds input validation, and handles `n = 0` by returning 1. Uses an iterative loop to avoid recursion depth issues.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: `factorial(5)`\nOutput: `120`\n**Notes:**\n- Returns 1 for `n = 0` and `n = 1` per factorial definition.\n- Throws on negative or non-integer input to prevent undefined results.\n- Iterative form is stack-safe compared to deep recursion.", "category": "bug_fix", "language": "javascript"}
{"prompt": "Find and fix the bug in this Java code:\nfor i in range(len(nums)):\n    if nums[i] == target:\n        return i\n    return -1\nThe code should not go out of bounds", "response": "java\n```java\npublic class SafeSearch {\n    public static int indexOf(int[] nums, int target) {\n        if (nums == null) return -1;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == target) return i;\n        }\n        return -1;\n    }\n}\n```\n**Explanation:** Fixes the premature `return -1` inside the loop and iterates with `i < nums.length` to stay in bounds. Returns -1 only after scanning the entire array.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: [1,2,3], target=3\nOutput: 2\n**Notes:**\n- Handles null input by returning -1; adjust to throw if preferred.\n- For repeated lookups, consider a map for faster access.\n- Works safely for empty arrays.", "category": "bug_fix", "language": "java"}
{"prompt": "Find and fix the bug in this Python code:\nfor (let i = 0; i <= arr.length; i++) { console.log(arr[i]); }\nThe code should avoid null pointer exceptions", "response": "python\n```python\ndef print_array(arr):\n    if arr is None:\n        return\n    for i in range(len(arr)):\n        print(arr[i])\n```\n**Explanation:** Changes the erroneous `i <= arr.length` pattern to Python’s safe `range(len(arr))`, preventing out-of-bounds access. Guards against `None` input.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: [1, 2]\nOutput: prints 1 then 2\n**Notes:**\n- For empty arrays, the loop runs zero times without error.\n- Replace `print` with logging or accumulation if needed.\n- In JS, the analogous fix is `for (let i = 0; i < arr.length; i++)`.", "category": "bug_fix", "language": "python"}
{"prompt": "Find and fix the bug in this JavaScript code:\nfor (let i = 0; i <= arr.length; i++) { console.log(arr[i]); }\nThe code should handle n=0 correctly", "response": "javascript\n```javascript\nfunction printArray(arr = []) {\n  for (let i = 0; i < arr.length; i++) {\n    console.log(arr[i]);\n  }\n}\n```\n**Explanation:** Fixes the off-by-one error by iterating with `i < arr.length` and defaults to an empty array so n=0 is safe. Prevents accessing `arr[arr.length]` (undefined).\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: [1, 2]\nOutput: logs 1 then 2\n**Notes:**\n- Add null checks if the array argument may be non-array.\n- For large arrays, consider batching output to avoid console flooding.", "category": "bug_fix", "language": "javascript"}
{"prompt": "Find and fix the bug in this JavaScript code:\nif (head.next == null) return false;\nwhile (head) {\n    head = head.next.next;\n}\nThe code should handle n=0 correctly", "response": "javascript\n```javascript\nfunction hasCycle(head) {\n  let slow = head;\n  let fast = head;\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n    if (slow === fast) return true;\n  }\n  return false;\n}\n```\n**Explanation:** Adds null checks before advancing two steps to avoid dereferencing when the list is empty or length 1. Uses Floyd’s tortoise-hare to detect a cycle without risking null pointer errors.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: head = null\nOutput: false\n**Notes:**\n- Works for any list size safely.\n- To find cycle entry, apply the standard two-pointer reset after detection.\n- Leaves the list unmodified.", "category": "bug_fix", "language": "javascript"}
{"prompt": "Find and fix the bug in this Java code:\nif (head.next == null) return false;\nwhile (head) {\n    head = head.next.next;\n}\nThe code should not go out of bounds", "response": "java\n```java\npublic class SafeCycleCheck {\n    static class ListNode { int val; ListNode next; }\n\n    public static boolean hasCycle(ListNode head) {\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) return true;\n        }\n        return false;\n    }\n}\n```\n**Explanation:** Adds null checks before advancing `fast.next.next`, avoiding out-of-bounds when the list is short. Uses Floyd's tortoise-hare to detect cycles safely.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: 1->2->3->2\nOutput: true\n**Notes:**\n- Works for empty or single-node lists (returns false).\n- To locate cycle start, reset one pointer to head after detection and move both one step at a time.\n- Leaves list unchanged.", "category": "bug_fix", "language": "java"}
{"prompt": "Find and fix the bug in this Python code:\ndef factorial(n):\n    if n == 1:\n        return 1\n    return n * factorial(n-1)\nThe code should avoid null pointer exceptions", "response": "python\n```python\ndef factorial(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    if n == 0 or n == 1:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result\n```\n**Explanation:** Adds base cases for 0/1 and input validation, preventing recursive overflow or undefined behavior. Iterative multiplication is stack-safe.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: 5\nOutput: 120\n**Notes:**\n- Python ints are unbounded, but results grow quickly.\n- Raise on negatives instead of recursing infinitely.\n- Use math.prod(range(1, n+1)) for brevity if desired.", "category": "bug_fix", "language": "python"}
{"prompt": "Find and fix the bug in this Java code:\nif (head.next == null) return false;\nwhile (head) {\n    head = head.next.next;\n}\nThe code should handle n=0 correctly", "response": "java\n```java\npublic class SafeCycle {\n    static class ListNode { int val; ListNode next; }\n\n    public static boolean hasCycle(ListNode head) {\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) return true;\n        }\n        return false;\n    }\n}\n```\n**Explanation:** Adds null checks before advancing `fast.next.next` to avoid null-pointer errors when the list is empty (n=0) or short. Uses Floyd's algorithm to detect cycles safely.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: 1 -> 2 -> 3 -> 2\nOutput: true\n**Notes:**\n- Works for empty and single-node lists (returns false).\n- To find cycle entry, reset one pointer to head after detection and move both one step at a time.\n- Leaves list unchanged.", "category": "bug_fix", "language": "java"}
{"prompt": "Find and fix the bug in this Java code:\ndef factorial(n):\n    if n == 1:\n        return 1\n    return n * factorial(n-1)\nThe code should handle n=0 correctly", "response": "java\n```java\npublic class FactorialFix {\n    public static long factorial(int n) {\n        if (n < 0) throw new IllegalArgumentException(\"n must be non-negative\");\n        long result = 1;\n        for (int i = 2; i <= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n}\n```\n**Explanation:** Adds validation and handles n=0 by returning 1 (loop skips). Replaces the Python-like recursive snippet with a safe iterative Java implementation.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: 3\nOutput: 6\n**Notes:**\n- Use BigInteger for large n to avoid overflow.\n- Iterative approach avoids stack overflow.\n- Returns 1 for n=0/1 per factorial definition.", "category": "bug_fix", "language": "java"}
{"prompt": "Design and implement a disjoint set (union-find) in Java supporting bounded capacity with wrap-around semantics", "response": "java\n```java\npublic class UnionFind {\n    private final int[] parent;\n    private final int[] rank;\n\n    public UnionFind(int size) {\n        if (size <= 0) throw new IllegalArgumentException(\"size must be positive\");\n        parent = new int[size];\n        rank = new int[size];\n        for (int i = 0; i < size; i++) {\n            parent[i] = i;\n        }\n    }\n\n    public int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]); // path compression\n        }\n        return parent[x];\n    }\n\n    public void union(int a, int b) {\n        int ra = find(a), rb = find(b);\n        if (ra == rb) return;\n        if (rank[ra] < rank[rb]) {\n            int tmp = ra; ra = rb; rb = tmp;\n        }\n        parent[rb] = ra;\n        if (rank[ra] == rank[rb]) rank[ra]++;\n    }\n}\n```\n**Explanation:** Standard disjoint set with path compression and union by rank. Capacity is fixed at construction (bounded); indices outside `[0, size)` are invalid, matching the bounded requirement.\n**Complexity:** Time: Amortized ~O(α(n)) per operation; Space: O(n) for parent/rank arrays.\n**Example:**\nInput: size=5; union(0,1); union(3,4); find(1)\nOutput: root of set containing 1 (either 0 or 1 depending on unions)\n**Notes:**\n- Validate indices before access in production code.\n- Rank heuristic keeps trees shallow; path compression flattens on finds.\n- Resize is not supported; construct with the known maximum set size.", "category": "data_structure", "language": "java"}
{"prompt": "Design and implement a disjoint set (union-find) in Java supporting thread-safe operations", "response": "java\n```java\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class ConcurrentUnionFind {\n    private final int[] parent;\n    private final int[] rank;\n    private final ReentrantLock lock = new ReentrantLock();\n\n    public ConcurrentUnionFind(int size) {\n        parent = new int[size];\n        rank = new int[size];\n        for (int i = 0; i < size; i++) {\n            parent[i] = i;\n        }\n    }\n\n    public int find(int x) {\n        lock.lock();\n        try {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void union(int a, int b) {\n        lock.lock();\n        try {\n            int ra = find(a);\n            int rb = find(b);\n            if (ra == rb) return;\n            if (rank[ra] < rank[rb]) {\n                int tmp = ra; ra = rb; rb = tmp;\n            }\n            parent[rb] = ra;\n            if (rank[ra] == rank[rb]) rank[ra]++;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```\n**Explanation:** Wraps union-find operations with a `ReentrantLock` to serialize mutations, keeping path compression and union-by-rank heuristics. This provides thread safety for concurrent callers at the cost of coarse locking.\n**Complexity:** Time: Amortized ~O(α(n)) per op; Space: O(n).\n**Example:**\nInput: size=4; union(0,1); union(2,3); find(3)\nOutput: representative of set containing 3 (2 or 3 depending on unions)\n**Notes:**\n- Coarse-grained locking is simple but blocks concurrent ops; for higher concurrency, use disjoint-set forests with finer-grained locks or disjoint-set union by atomic CAS.\n- Validate indices in production code.\n- Path compression occurs under lock to maintain consistency.", "category": "data_structure", "language": "java"}
{"prompt": "Implement a heap in Java with insert, delete, and search operations", "response": "java\n```java\nimport java.util.Arrays;\n\npublic class ArrayHeap {\n    private int[] heap;\n    private int size = 0;\n\n    public ArrayHeap(int capacity) {\n        heap = new int[Math.max(1, capacity)];\n    }\n\n    public void insert(int val) {\n        ensureCapacity();\n        heap[size] = val;\n        bubbleUp(size);\n        size++;\n    }\n\n    public int deleteRoot() {\n        if (size == 0) throw new IllegalStateException(\"heap is empty\");\n        int root = heap[0];\n        heap[0] = heap[size - 1];\n        size--;\n        bubbleDown(0);\n        return root;\n    }\n\n    public int find(int target) {\n        for (int i = 0; i < size; i++) {\n            if (heap[i] == target) return i; // return index if found\n        }\n        return -1;\n    }\n\n    private void bubbleUp(int idx) {\n        while (idx > 0) {\n            int parent = (idx - 1) / 2;\n            if (heap[parent] <= heap[idx]) break;\n            swap(parent, idx);\n            idx = parent;\n        }\n    }\n\n    private void bubbleDown(int idx) {\n        while (true) {\n            int left = 2 * idx + 1;\n            int right = 2 * idx + 2;\n            int smallest = idx;\n            if (left < size && heap[left] < heap[smallest]) smallest = left;\n            if (right < size && heap[right] < heap[smallest]) smallest = right;\n            if (smallest == idx) break;\n            swap(idx, smallest);\n            idx = smallest;\n        }\n    }\n\n    private void ensureCapacity() {\n        if (size == heap.length) heap = Arrays.copyOf(heap, heap.length * 2);\n    }\n\n    private void swap(int i, int j) {\n        int tmp = heap[i];\n        heap[i] = heap[j];\n        heap[j] = tmp;\n    }\n}\n```\n**Explanation:** Implements a min-heap with array storage. `insert` places the new value at the end then restores heap order via `bubbleUp`; `deleteRoot` removes the smallest element, replaces it with the last element, and `bubbleDown`s to reheapify. `find` scans linearly to locate a target value.\n**Complexity:** Time: insert/deleteRoot O(log n); find O(n); Space: O(n).\n**Example:**\nInput: insert 5, insert 2, insert 8, deleteRoot\nOutput: deleteRoot returns 2, heap now contains [5, 8]\n**Notes:**\n- Dynamically resizes when capacity is reached.\n- For max-heap, flip comparisons.\n- `find` is linear; to support key lookup in O(log n), maintain an index map.", "category": "data_structure", "language": "java"}
{"prompt": "Implement a queue in Rust with efficient lookup and insertion", "response": "rust\n```rust\nuse std::collections::{HashSet, VecDeque};\n\npub struct FastQueue<T: Eq + std::hash::Hash + Clone> {\n    data: VecDeque<T>,\n    index: HashSet<T>, // for O(1) membership lookup\n}\n\nimpl<T: Eq + std::hash::Hash + Clone> FastQueue<T> {\n    pub fn new() -> Self {\n        Self { data: VecDeque::new(), index: HashSet::new() }\n    }\n\n    pub fn enqueue(&mut self, value: T) {\n        self.index.insert(value.clone());\n        self.data.push_back(value);\n    }\n\n    pub fn dequeue(&mut self) -> Option<T> {\n        let val = self.data.pop_front();\n        if let Some(ref v) = val {\n            self.index.remove(v);\n        }\n        val\n    }\n\n    pub fn contains(&self, value: &T) -> bool {\n        self.index.contains(value)\n    }\n\n    pub fn is_empty(&self) -> bool {\n        self.data.is_empty()\n    }\n}\n```\n**Explanation:** Wraps a `VecDeque` for O(1) head/tail operations and a `HashSet` mirror for O(1) membership tests, providing efficient insertion and lookup. Removing from the front also updates the index to keep structures in sync.\n**Complexity:** Time: O(1) average for enqueue, dequeue, and contains; Space: O(n).\n**Example:**\nInput: enqueue 1,2; contains(2); dequeue()\nOutput: `contains(2)` -> true, `dequeue()` -> 1\n**Notes:**\n- `contains` checks by value; if duplicates matter, store counts instead of a set.\n- For thread safety, wrap the struct in a Mutex/RwLock.\n- Generics require `Eq + Hash + Clone`; relax cloning by storing references or using interior mutability.", "category": "data_structure", "language": "rust"}
{"prompt": "Design and implement a circular buffer in C++ supporting bounded capacity with wrap-around semantics", "response": "c++\n```cpp\n#include <vector>\n#include <stdexcept>\n\n// Fixed-capacity circular buffer with wrap-around semantics\nclass CircularBuffer {\npublic:\n    explicit CircularBuffer(size_t capacity)\n        : buf_(capacity), head_(0), tail_(0), size_(0) {\n        if (capacity == 0) throw std::invalid_argument(\"capacity must be > 0\");\n    }\n\n    void push(int value) {\n        if (size_ == buf_.size()) throw std::overflow_error(\"buffer full\");\n        buf_[tail_] = value;\n        tail_ = (tail_ + 1) % buf_.size();\n        ++size_;\n    }\n\n    int pop() {\n        if (size_ == 0) throw std::underflow_error(\"buffer empty\");\n        int val = buf_[head_];\n        head_ = (head_ + 1) % buf_.size();\n        --size_;\n        return val;\n    }\n\n    bool empty() const { return size_ == 0; }\n    bool full() const { return size_ == buf_.size(); }\n    size_t size() const { return size_; }\n\nprivate:\n    std::vector<int> buf_;\n    size_t head_, tail_, size_;\n};\n```\n**Explanation:** Maintains head/tail indices modulo capacity to achieve wrap-around storage. `push` writes at tail and advances; `pop` reads at head and advances; size tracks occupancy to distinguish full vs empty.\n**Complexity:** Time: O(1) for push/pop; Space: O(capacity).\n**Example:**\nInput: capacity=3; push 1,2,3; pop() -> 1; push 4\nOutput: buffer now holds [2,3,4] in logical order\n**Notes:**\n- Throws on overflow/underflow; adjust to overwrite oldest on push if desired.\n- Template the value type for generality beyond `int`.\n- Not thread-safe; add locking for concurrent use.", "category": "data_structure", "language": "c++"}
{"prompt": "Implement a queue in Rust with O(1) get-min or get-max support", "response": "rust\n```rust\nuse std::collections::VecDeque;\n\n/// Monotonic queue supporting O(1) push/pop front and O(1) access to min.\npub struct MinQueue {\n    data: VecDeque<i32>,\n    mono: VecDeque<i32>,\n}\n\nimpl MinQueue {\n    pub fn new() -> Self {\n        Self { data: VecDeque::new(), mono: VecDeque::new() }\n    }\n\n    pub fn push(&mut self, x: i32) {\n        self.data.push_back(x);\n        while let Some(&back) = self.mono.back() {\n            if back <= x { break; }\n            self.mono.pop_back();\n        }\n        self.mono.push_back(x);\n    }\n\n    pub fn pop(&mut self) -> Option<i32> {\n        let val = self.data.pop_front();\n        if let Some(v) = val {\n            if self.mono.front() == Some(&v) {\n                self.mono.pop_front();\n            }\n        }\n        val\n    }\n\n    pub fn min(&self) -> Option<i32> {\n        self.mono.front().cloned()\n    }\n\n    pub fn is_empty(&self) -> bool {\n        self.data.is_empty()\n    }\n}\n```\n**Explanation:** Maintains the main queue plus a secondary deque (`mono`) that stores candidates in nondecreasing order. On push, it drops larger tail elements before appending the new value; on pop, it removes from `mono` if the popped value was the current minimum. This keeps `min()` in O(1).\n**Complexity:** Time: Amortized O(1) per push/pop; Space: O(n).\n**Example:**\nInput: push 3, push 1, push 2, min() -> 1, pop() -> 3, min() -> 1\nOutput: mins tracked as described\n**Notes:**\n- Use `max` variant by reversing comparisons.\n- Generic over ordered types with `T: Ord + Copy` if needed.\n- Not thread-safe; wrap in `Mutex` for concurrent use.", "category": "data_structure", "language": "rust"}
{"prompt": "Design and implement a priority queue in C++ supporting bounded capacity with wrap-around semantics", "response": "c++\n```cpp\n#include <vector>\n#include <queue>\n#include <stdexcept>\n\n// Capacity-limited min-heap priority queue; evicts lowest-priority when full by throwing\nclass BoundedPriorityQueue {\npublic:\n    explicit BoundedPriorityQueue(size_t capacity) : cap_(capacity) {\n        if (capacity == 0) throw std::invalid_argument(\"capacity must be > 0\");\n    }\n\n    void push(int value) {\n        if (pq_.size() == cap_) {\n            throw std::overflow_error(\"priority queue is full\");\n        }\n        pq_.push(value);\n    }\n\n    int pop() {\n        if (pq_.empty()) throw std::underflow_error(\"priority queue is empty\");\n        int top = pq_.top();\n        pq_.pop();\n        return top;\n    }\n\n    bool empty() const { return pq_.empty(); }\n    size_t size() const { return pq_.size(); }\n\nprivate:\n    // min-heap\n    struct MinComp { bool operator()(int a, int b) const { return a > b; } };\n    std::priority_queue<int, std::vector<int>, MinComp> pq_;\n    size_t cap_;\n};\n```\n**Explanation:** Wraps `std::priority_queue` configured as a min-heap with a fixed capacity. `push` inserts until capacity is reached, then throws; `pop` removes the smallest element. This keeps wrap-around semantics by bounding size without silent overwrites.\n**Complexity:** Time: O(log n) push/pop; Space: O(capacity).\n**Example:**\nInput: capacity=2; push 5; push 3; pop()\nOutput: returns 3 (smallest)\n**Notes:**\n- Swap to drop an element instead of throwing if you prefer overwriting/eviction behavior.\n- Template the value/compare types for general use.\n- Ensure callers handle overflow/underflow exceptions gracefully.", "category": "data_structure", "language": "c++"}
{"prompt": "Design and implement a circular buffer in C++ supporting O(1) eviction and retrieval", "response": "c++\n```cpp\n#include <vector>\n#include <stdexcept>\n\n// Circular buffer that evicts on pop and supports wrap-around\nclass EvictingCircularBuffer {\npublic:\n    explicit EvictingCircularBuffer(size_t capacity)\n        : buf_(capacity), head_(0), tail_(0), size_(0) {\n        if (capacity == 0) throw std::invalid_argument(\"capacity must be > 0\");\n    }\n\n    void push(int value) {\n        if (full()) throw std::overflow_error(\"buffer full\");\n        buf_[tail_] = value;\n        tail_ = (tail_ + 1) % buf_.size();\n        ++size_;\n    }\n\n    int pop() {\n        if (empty()) throw std::underflow_error(\"buffer empty\");\n        int v = buf_[head_];\n        head_ = (head_ + 1) % buf_.size();\n        --size_;\n        return v;\n    }\n\n    bool empty() const { return size_ == 0; }\n    bool full() const { return size_ == buf_.size(); }\n    size_t size() const { return size_; }\n\nprivate:\n    std::vector<int> buf_;\n    size_t head_, tail_, size_;\n};\n```\n**Explanation:** Similar to a standard ring buffer: head points to the next element to remove, tail to the next insert slot. Push advances tail, pop advances head, both modulo capacity. Size distinguishes full vs empty states.\n**Complexity:** Time: O(1) per push/pop; Space: O(capacity).\n**Example:**\nInput: capacity=2; push 10; push 20; pop -> 10; push 30\nOutput: buffer now logically contains [20, 30]\n**Notes:**\n- Throws on overflow/underflow; change to overwrite-on-full by moving head when full.\n- Template the type for general use.\n- Not thread-safe; guard with mutexes if sharing across threads.", "category": "data_structure", "language": "c++"}
{"prompt": "Design and implement a priority queue in Rust supporting thread-safe operations", "response": "rust\n```rust\nuse std::cmp::Reverse;\nuse std::collections::BinaryHeap;\nuse std::sync::{Arc, Mutex};\n\npub struct ThreadSafePriorityQueue<T: Ord> {\n    heap: Arc<Mutex<BinaryHeap<Reverse<T>>>>, // min-heap via Reverse\n}\n\nimpl<T: Ord> ThreadSafePriorityQueue<T> {\n    pub fn new() -> Self {\n        Self { heap: Arc::new(Mutex::new(BinaryHeap::new())) }\n    }\n\n    pub fn push(&self, value: T) {\n        let mut h = self.heap.lock().unwrap();\n        h.push(Reverse(value));\n    }\n\n    pub fn pop(&self) -> Option<T> {\n        let mut h = self.heap.lock().unwrap();\n        h.pop().map(|r| r.0)\n    }\n\n    pub fn peek(&self) -> Option<T> where T: Clone {\n        let h = self.heap.lock().unwrap();\n        h.peek().map(|r| r.0.clone())\n    }\n}\n```\n**Explanation:** Wraps a `BinaryHeap` in `Arc<Mutex<...>>` to synchronize concurrent access. `Reverse` turns the default max-heap into a min-heap. Each method locks briefly to perform push/pop/peek safely across threads.\n**Complexity:** Time: O(log n) for push/pop, O(1) for peek; Space: O(n).\n**Example:**\nInput: push 3, push 1, peek -> 1, pop -> 1\nOutput: min-heap behavior in a thread-safe wrapper\n**Notes:**\n- `Arc` lets you clone the queue handle and share across threads.\n- Beware of holding locks while doing long work; keep critical sections small.\n- Remove `Reverse` if you prefer max-heap semantics.", "category": "data_structure", "language": "rust"}
{"prompt": "Implement a stack in Go with iterators with lazy traversal", "response": "go\n```go\npackage main\n\n// Stack with lazy iterator using a channel\n// Push/Pop are O(1); Iter returns a channel that streams elements top-down.\ntype Stack[T any] struct {\n\tdata []T\n}\n\nfunc (s *Stack[T]) Push(v T) { s.data = append(s.data, v) }\n\nfunc (s *Stack[T]) Pop() (T, bool) {\n\tvar zero T\n\tif len(s.data) == 0 {\n\t\treturn zero, false\n\t}\n\tv := s.data[len(s.data)-1]\n\ts.data = s.data[:len(s.data)-1]\n\treturn v, true\n}\n\nfunc (s *Stack[T]) Iter() <-chan T {\n\tch := make(chan T)\n\tgo func() {\n\t\tfor i := len(s.data) - 1; i >= 0; i-- {\n\t\t\tch <- s.data[i]\n\t\t}\n\t\tclose(ch)\n\t}()\n\treturn ch\n}\n```\n**Explanation:** Stores elements in a slice. `Push`/`Pop` mutate the slice. `Iter` spawns a goroutine that lazily streams elements via a channel without materializing a copy.\n**Complexity:** Time: O(1) push/pop; Iter streaming O(n); Space: O(n) for stored items plus channel buffer (0 here).\n**Example:**\nInput: push 1,2,3; iterate -> 3,2,1\nOutput: values streamed in LIFO order\n**Notes:**\n- Close the channel after iteration; goroutine exits once done.\n- Add bounds checks or errors as preferred instead of booleans.\n- For concurrent producers/consumers, guard with a mutex.", "category": "data_structure", "language": "go"}
{"prompt": "Design and implement a priority queue in Rust supporting union and find with path compression", "response": "rust\n```rust\n/// Disjoint set union (union-find) with path compression and union by rank.\npub struct UnionFind {\n    parent: Vec<usize>,\n    rank: Vec<usize>,\n}\n\nimpl UnionFind {\n    pub fn new(n: usize) -> Self {\n        Self { parent: (0..n).collect(), rank: vec![0; n] }\n    }\n\n    pub fn find(&mut self, x: usize) -> usize {\n        if self.parent[x] != x {\n            let root = self.find(self.parent[x]);\n            self.parent[x] = root;\n        }\n        self.parent[x]\n    }\n\n    pub fn union(&mut self, a: usize, b: usize) {\n        let mut ra = self.find(a);\n        let mut rb = self.find(b);\n        if ra == rb { return; }\n        if self.rank[ra] < self.rank[rb] {\n            std::mem::swap(&mut ra, &mut rb);\n        }\n        self.parent[rb] = ra;\n        if self.rank[ra] == self.rank[rb] {\n            self.rank[ra] += 1;\n        }\n    }\n}\n```\n**Explanation:** Maintains parent/rank arrays; `find` flattens paths, `union` attaches the shallower tree under the deeper one. This yields near-constant amortized performance for connectivity checks.\n**Complexity:** Time: ~O(α(n)) per op; Space: O(n).\n**Example:**\nInput: uf.union(0,1); uf.union(1,2); uf.find(2)\nOutput: root index shared by 0,1,2\n**Notes:**\n- Index bounds should be validated in production.\n- Add a `connected(a,b)` helper to test membership quickly.\n- Fixed capacity; recreate if you need to grow beyond `n`.", "category": "data_structure", "language": "rust"}
{"prompt": "Design and implement a circular buffer in Python supporting O(1) eviction and retrieval", "response": "python\n```python\nfrom collections import deque\nfrom typing import Generic, TypeVar\n\nT = TypeVar(\"T\")\n\nclass CircularBuffer(Generic[T]):\n    def __init__(self, capacity: int):\n        if capacity <= 0:\n            raise ValueError(\"capacity must be positive\")\n        self.capacity = capacity\n        self.data: deque[T] = deque(maxlen=capacity)\n\n    def push(self, item: T) -> None:\n        if len(self.data) == self.capacity:\n            # evict oldest automatically via maxlen\n            self.data.popleft()\n        self.data.append(item)\n\n    def pop(self) -> T:\n        if not self.data:\n            raise IndexError(\"buffer is empty\")\n        return self.data.popleft()\n\n    def peek(self) -> T:\n        if not self.data:\n            raise IndexError(\"buffer is empty\")\n        return self.data[0]\n```\n**Explanation:** Wraps `deque` with a fixed `maxlen` to achieve O(1) eviction of the oldest element when full. `push` evicts automatically, `pop`/`peek` access the head.\n**Complexity:** Time: O(1) per operation; Space: O(capacity).\n**Example:**\nInput: capacity=2; push 1; push 2; push 3; pop()\nOutput: `pop()` returns 2 (1 was evicted when pushing 3)\n**Notes:**\n- To avoid eviction, raise on overflow instead of using `maxlen` semantics.\n- Add `__len__` for convenience if integrating with collections.\n- Thread-safety not provided; use locks in concurrent contexts.", "category": "data_structure", "language": "python"}
{"prompt": "Design and implement a disjoint set (union-find) in C++ supporting range queries and point updates", "response": "c++\n```cpp\n#include <vector>\n#include <numeric>\n\nclass DisjointSet {\npublic:\n    explicit DisjointSet(int n) : parent_(n), rank_(n, 0) {\n        std::iota(parent_.begin(), parent_.end(), 0);\n    }\n    int find(int x) {\n        if (parent_[x] != x) parent_[x] = find(parent_[x]);\n        return parent_[x];\n    }\n    bool unite(int a, int b) {\n        a = find(a); b = find(b);\n        if (a == b) return false;\n        if (rank_[a] < rank_[b]) std::swap(a, b);\n        parent_[b] = a;\n        if (rank_[a] == rank_[b]) rank_[a]++;\n        return true;\n    }\nprivate:\n    std::vector<int> parent_;\n    std::vector<int> rank_;\n};\n```\n**Explanation:** Implements union-find with path compression and union by rank to maintain shallow trees, enabling near-constant-time union/find operations.\n**Complexity:** Time: Amortized ~O(α(n)) per op; Space: O(n).\n**Example:**\nInput: unite(0,1); unite(2,3); find(3)\nOutput: representative of set containing 3\n**Notes:**\n- Fixed capacity set at construction; resize by creating a new instance.\n- Thread-safety not provided; wrap calls with locks if accessed concurrently.\n- Add `connected(a,b)` helper for convenience.", "category": "data_structure", "language": "c++"}
{"prompt": "Design and implement a disjoint set (union-find) in C++ supporting thread-safe operations", "response": "c++\n```cpp\n#include <vector>\n#include <numeric>\n#include <mutex>\n\nclass ThreadSafeDSU {\npublic:\n    explicit ThreadSafeDSU(int n) : parent_(n), rank_(n, 0) {\n        std::iota(parent_.begin(), parent_.end(), 0);\n    }\n\n    int find(int x) {\n        std::lock_guard<std::mutex> lg(mu_);\n        return findLocked(x);\n    }\n\n    void unite(int a, int b) {\n        std::lock_guard<std::mutex> lg(mu_);\n        a = findLocked(a);\n        b = findLocked(b);\n        if (a == b) return;\n        if (rank_[a] < rank_[b]) std::swap(a, b);\n        parent_[b] = a;\n        if (rank_[a] == rank_[b]) rank_[a]++;\n    }\n\nprivate:\n    int findLocked(int x) {\n        if (parent_[x] != x) parent_[x] = findLocked(parent_[x]);\n        return parent_[x];\n    }\n\n    std::vector<int> parent_;\n    std::vector<int> rank_;\n    std::mutex mu_;\n};\n```\n**Explanation:** Wraps standard union-find with a mutex to serialize access, ensuring thread-safe path compression and union-by-rank operations.\n**Complexity:** Time: Amortized ~O(α(n)) per op; Space: O(n).\n**Example:**\nInput: unite(0,1); unite(2,3); find(3)\nOutput: representative of set containing 3\n**Notes:**\n- Coarse-grained locking keeps it simple; finer-grained locks could allow more concurrency.\n- Validate indices in production.\n- Keep critical sections small to avoid contention.", "category": "data_structure", "language": "c++"}
{"prompt": "Implement a graph in Python with insert, delete, and search operations", "response": "python\n```python\nfrom collections import defaultdict\nfrom typing import Hashable, Iterable\n\nclass Graph:\n    def __init__(self) -> None:\n        self.adj: dict[Hashable, set[Hashable]] = defaultdict(set)\n\n    def insert(self, u: Hashable, v: Hashable, bidirectional: bool = False) -> None:\n        self.adj[u].add(v)\n        if bidirectional:\n            self.adj[v].add(u)\n\n    def delete(self, u: Hashable, v: Hashable, bidirectional: bool = False) -> None:\n        self.adj[u].discard(v)\n        if bidirectional:\n            self.adj[v].discard(u)\n\n    def search(self, u: Hashable, v: Hashable) -> bool:\n        return v in self.adj.get(u, ())\n```\n**Explanation:** Stores adjacency as sets for O(1) average insertion, deletion, and membership checks. Supports optional bidirectional edges for undirected graphs.\n**Complexity:** Time: O(1) average for insert/delete/search; Space: O(V + E).\n**Example:**\nInput: insert('A','B', True); search('B','A')\nOutput: True\n**Notes:**\n- Sets prevent duplicate edges; switch to lists if multiplicity matters.\n- Add node deletion by removing from adjacency and others’ neighbor sets if required.\n- For weighted graphs, map neighbors to weights instead of using a set.", "category": "data_structure", "language": "python"}
{"prompt": "Design and implement a segment tree in Python supporting union and find with path compression", "response": "python\n```python\nfrom typing import List\n\nclass SegmentTree:\n    \"\"\"Iterative segment tree for range sum queries and point updates.\"\"\"\n    def __init__(self, nums: List[int]):\n        self.n = len(nums)\n        self.tree = [0] * (2 * self.n)\n        # build leaves\n        self.tree[self.n:] = nums[:]\n        # build parents\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1]\n\n    def update(self, idx: int, val: int) -> None:\n        i = idx + self.n\n        self.tree[i] = val\n        while i > 1:\n            i //= 2\n            self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1]\n\n    def query(self, l: int, r: int) -> int:\n        l += self.n; r += self.n\n        res = 0\n        while l <= r:\n            if l % 2 == 1:\n                res += self.tree[l]; l += 1\n            if r % 2 == 0:\n                res += self.tree[r]; r -= 1\n            l //= 2; r //= 2\n        return res\n```\n**Explanation:** Stores the tree in a flat array. Leaves start at index `n`; parents are sums of children. `update` rewrites a leaf and walks up to refresh sums. `query` uses two pointers to accumulate contributions while climbing toward the root.\n**Complexity:** Time: O(log n) for update/query; Space: O(n).\n**Example:**\nInput: nums=[1,3,5], query(0,2)\nOutput: 9\n**Notes:**\n- Change the merge operation for min/max or other associative functions.\n- Ensure 0 <= idx,l,r < n; r is inclusive here.\n- For immutable updates, build new trees or use a persistent segment tree.", "category": "data_structure", "language": "python"}
{"prompt": "Implement a graph in Python with efficient lookup and insertion", "response": "python\n```python\nfrom collections import defaultdict\nfrom typing import Hashable, Any\n\nclass Graph:\n    def __init__(self) -> None:\n        self.adj: dict[Hashable, set[Hashable]] = defaultdict(set)\n\n    def add_edge(self, u: Hashable, v: Hashable, bidirectional: bool = False) -> None:\n        self.adj[u].add(v)\n        if bidirectional:\n            self.adj[v].add(u)\n\n    def remove_edge(self, u: Hashable, v: Hashable, bidirectional: bool = False) -> None:\n        self.adj[u].discard(v)\n        if bidirectional:\n            self.adj[v].discard(u)\n\n    def neighbors(self, u: Hashable) -> set[Hashable]:\n        return set(self.adj.get(u, ()))\n```\n**Explanation:** Uses a dict of sets for O(1) average insertion and neighbor lookup. Supports optional bidirectional edges and safe deletion.\n**Complexity:** Time: O(1) avg for insert/delete/lookup; Space: O(V + E).\n**Example:**\nInput: add_edge('A','B', True); neighbors('A')\nOutput: {'B'}\n**Notes:**\n- Sets deduplicate edges; switch to lists if duplicates matter.\n- Add node deletion to purge a vertex and its incident edges if needed.\n- For weighted graphs, store a dict of neighbor->weight instead of a set.", "category": "data_structure", "language": "python"}
{"prompt": "Implement a graph in JavaScript with all basic operations", "response": "javascript\n```javascript\nclass Graph {\n  constructor() {\n    this.adj = new Map();\n  }\n  addVertex(v) {\n    if (!this.adj.has(v)) this.adj.set(v, new Set());\n  }\n  addEdge(u, v, bidirectional = false) {\n    this.addVertex(u); this.addVertex(v);\n    this.adj.get(u).add(v);\n    if (bidirectional) this.adj.get(v).add(u);\n  }\n  removeEdge(u, v, bidirectional = false) {\n    this.adj.get(u)?.delete(v);\n    if (bidirectional) this.adj.get(v)?.delete(u);\n  }\n  neighbors(u) {\n    return Array.from(this.adj.get(u) ?? []);\n  }\n  hasEdge(u, v) {\n    return this.adj.get(u)?.has(v) ?? false;\n  }\n}\n```\n**Explanation:** Maintains adjacency as a `Map` of `Set`s for O(1) average insert/delete/lookup of edges. Supports bidirectional edge creation/removal and neighbor listing.\n**Complexity:** Time: O(1) average per edge update; Space: O(V + E).\n**Example:**\nInput: addEdge('A','B',true); neighbors('A')\nOutput: ['B']\n**Notes:**\n- Sets prevent duplicate edges; use arrays if multiplicity matters.\n- Add vertex/edge deletion cleanup as needed for your use case.\n- For weighted graphs, store objects `{v, w}` instead of bare vertices.", "category": "data_structure", "language": "javascript"}
{"prompt": "Implement a binary search tree in Java with all basic operations", "response": "java\n```java\nclass BST {\n    static class Node {\n        int val; Node left, right;\n        Node(int v) { val = v; }\n    }\n    private Node root;\n\n    public void insert(int val) { root = insert(root, val); }\n    private Node insert(Node node, int val) {\n        if (node == null) return new Node(val);\n        if (val < node.val) node.left = insert(node.left, val);\n        else if (val > node.val) node.right = insert(node.right, val);\n        return node;\n    }\n\n    public boolean search(int val) { return search(root, val); }\n    private boolean search(Node node, int val) {\n        if (node == null) return false;\n        if (node.val == val) return true;\n        return val < node.val ? search(node.left, val) : search(node.right, val);\n    }\n\n    public void delete(int val) { root = delete(root, val); }\n    private Node delete(Node node, int val) {\n        if (node == null) return null;\n        if (val < node.val) node.left = delete(node.left, val);\n        else if (val > node.val) node.right = delete(node.right, val);\n        else {\n            if (node.left == null) return node.right;\n            if (node.right == null) return node.left;\n            Node succ = node.right;\n            while (succ.left != null) succ = succ.left;\n            node.val = succ.val;\n            node.right = delete(node.right, succ.val);\n        }\n        return node;\n    }\n}\n```\n**Explanation:** Basic BST with insert, search, and delete. Deletion replaces a node with its in-order successor when it has two children; otherwise bypasses the single child or null.\n**Complexity:** Time: O(h) where h is tree height; Space: O(h) recursion stack.\n**Example:**\nInput: insert 5,3,7; search 3\nOutput: true\n**Notes:**\n- Unbalanced trees can degrade to O(n); use AVL/Red-Black for guaranteed balance.\n- Does not store duplicates; adjust policy as needed.\n- Add iterative traversals or balancing if performance is critical.", "category": "data_structure", "language": "java"}
{"prompt": "Design and implement a circular buffer in Java supporting union and find with path compression", "response": "java\n```java\npublic class CircularBuffer {\n    private final int[] data;\n    private int head = 0, tail = 0, size = 0;\n\n    public CircularBuffer(int capacity) {\n        if (capacity <= 0) throw new IllegalArgumentException(\"capacity>0\");\n        data = new int[capacity];\n    }\n\n    public void push(int val) {\n        if (size == data.length) throw new IllegalStateException(\"buffer full\");\n        data[tail] = val;\n        tail = (tail + 1) % data.length;\n        size++;\n    }\n\n    public int pop() {\n        if (size == 0) throw new IllegalStateException(\"buffer empty\");\n        int v = data[head];\n        head = (head + 1) % data.length;\n        size--;\n        return v;\n    }\n\n    public boolean isEmpty() { return size == 0; }\n    public boolean isFull() { return size == data.length; }\n}\n```\n**Explanation:** Fixed-size ring buffer with head/tail indices and a size counter. Push writes at tail and advances; pop reads at head and advances; modulo arithmetic wraps around.\n**Complexity:** Time: O(1) per op; Space: O(capacity).\n**Example:**\nInput: capacity=2; push 1; push 2; pop() -> 1; push 3\nOutput: buffer now holds 2,3 in logical order\n**Notes:**\n- Throws on overflow/underflow; change to overwrite-on-full if needed.\n- Generalize to generics for non-int payloads.\n- Not thread-safe; guard with locks for concurrent access.", "category": "data_structure", "language": "java"}
{"prompt": "Design and implement a segment tree in Python supporting range queries and point updates", "response": "python\n```python\nfrom typing import List\n\nclass SegmentTree:\n    def __init__(self, nums: List[int]):\n        self.n = len(nums)\n        self.tree = [0] * (2 * self.n)\n        self.tree[self.n:] = nums[:]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1]\n\n    def update(self, idx: int, val: int) -> None:\n        i = idx + self.n\n        self.tree[i] = val\n        while i > 1:\n            i //= 2\n            self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1]\n\n    def query(self, l: int, r: int) -> int:\n        l += self.n; r += self.n\n        res = 0\n        while l <= r:\n            if l & 1:\n                res += self.tree[l]; l += 1\n            if not (r & 1):\n                res += self.tree[r]; r -= 1\n            l //= 2; r //= 2\n        return res\n```\n**Explanation:** Iterative segment tree storing sums; supports point updates and inclusive range sum queries. Leaves live in the second half of the array; parent nodes combine children sums.\n**Complexity:** Time: O(log n) per update/query; Space: O(n).\n**Example:**\nInput: nums=[1,3,5], query(0,2)\nOutput: 9\n**Notes:**\n- Replace the sum operation for min/max as needed.\n- Ensure indices are within [0, n).\n- For immutable queries, leave tree unchanged and avoid in-place updates.", "category": "data_structure", "language": "python"}
{"prompt": "Implement a trie in Python with efficient lookup and insertion", "response": "python\n```python\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n        node.end = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.end\n\n    def starts_with(self, prefix: str) -> bool:\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n```\n**Explanation:** Each node holds a map of child characters and an end-of-word flag. Insert walks/creates nodes for each char; search follows links and checks the end flag; `starts_with` verifies prefix existence without needing the end flag.\n**Complexity:** Time: O(L) for insert/search on word length; Space: O(total characters stored).\n**Example:**\nInput: insert(\"cat\"), search(\"cat\"), search(\"car\")\nOutput: True, False\n**Notes:**\n- Case-sensitive; normalize input if needed.\n- To delete words, unset `end` and prune orphaned nodes.\n- Replace dict with arrays for fixed alphabets to improve performance.", "category": "data_structure", "language": "python"}
{"prompt": "Design and implement a segment tree in Python supporting bounded capacity with wrap-around semantics", "response": "python\n```python\nclass CircularSegmentBuffer:\n    \"\"\"Ring buffer that overwrites oldest entries when full.\"\"\"\n    def __init__(self, capacity: int):\n        if capacity <= 0:\n            raise ValueError(\"capacity must be positive\")\n        self.data = [None] * capacity\n        self.head = 0  # next write\n        self.size = 0\n\n    def push(self, value):\n        self.data[self.head] = value\n        self.head = (self.head + 1) % len(self.data)\n        self.size = min(self.size + 1, len(self.data))\n\n    def get(self, idx: int):\n        if idx < 0 or idx >= self.size:\n            raise IndexError(\"index out of range\")\n        start = (self.head - self.size) % len(self.data)\n        return self.data[(start + idx) % len(self.data)]\n```\n**Explanation:** Fixed-size ring buffer that wraps writes via modulo arithmetic. `push` overwrites the oldest entry when full. `get` accesses logical indices relative to the oldest element currently stored.\n**Complexity:** Time: O(1) for push/get; Space: O(capacity).\n**Example:**\nInput: capacity=3; push A,B,C,D; get(0)\nOutput: returns B (A overwritten by D)\n**Notes:**\n- If overwriting is undesirable, raise instead when size == capacity.\n- Add methods to iterate in logical order or to pop oldest/newest.\n- Thread-safety not included; guard with locks if accessed concurrently.", "category": "data_structure", "language": "python"}
{"prompt": "Design and implement a priority queue in Java supporting thread-safe operations", "response": "java\n```java\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\n\npublic class ConcurrentMinPQ<T> {\n    private final PriorityQueue<T> pq;\n\n    public ConcurrentMinPQ(Comparator<T> comp) {\n        this.pq = new PriorityQueue<>(comp);\n    }\n\n    public synchronized void offer(T item) {\n        pq.offer(item);\n    }\n\n    public synchronized T poll() {\n        return pq.poll();\n    }\n\n    public synchronized T peek() {\n        return pq.peek();\n    }\n\n    public synchronized int size() {\n        return pq.size();\n    }\n}\n```\n**Explanation:** Wraps `PriorityQueue` with synchronized methods to provide coarse-grained thread safety. Supports offer, poll, peek, and size operations using the provided comparator for ordering.\n**Complexity:** Time: O(log n) for offer/poll, O(1) for peek/size; Space: O(n).\n**Example:**\nInput: offer(3), offer(1), poll()\nOutput: returns 1\n**Notes:**\n- Coarse synchronization is simple but blocks concurrent access; consider `PriorityBlockingQueue` for more scalable concurrency.\n- Provide a comparator or ensure T is `Comparable` if using default constructor.\n- Add timeout/condition-based waits for blocking semantics if needed.", "category": "data_structure", "language": "java"}
{"prompt": "Design and implement a segment tree in Python supporting thread-safe operations", "response": "python\n```python\nimport threading\nfrom typing import List\n\nclass ThreadSafeSegmentTree:\n    def __init__(self, nums: List[int]):\n        self.n = len(nums)\n        self.tree = [0] * (2 * self.n)\n        self.lock = threading.Lock()\n        self.tree[self.n:] = nums[:]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1]\n\n    def update(self, idx: int, val: int) -> None:\n        with self.lock:\n            i = idx + self.n\n            self.tree[i] = val\n            i //= 2\n            while i:\n                self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1]\n                i //= 2\n\n    def query(self, l: int, r: int) -> int:\n        with self.lock:\n            l += self.n; r += self.n\n            res = 0\n            while l <= r:\n                if l & 1:\n                    res += self.tree[l]\n                    l += 1\n                if not (r & 1):\n                    res += self.tree[r]\n                    r -= 1\n                l //= 2; r //= 2\n            return res\n```\n**Explanation:** Builds an iterative segment tree for range sums and protects updates/queries with a mutex for thread safety. Point updates bubble changes upward; queries walk two pointers inward to aggregate contributions.\n**Complexity:** Time: O(log n) per update/query; Space: O(n).\n**Example:**\nInput: nums=[1,3,5], query(0,2)\nOutput: 9\n**Notes:**\n- Adjust the merge operation for min/max as needed.\n- Lock granularity is coarse; finer-grained locks can improve concurrency at extra complexity.\n- Ensure indices are within bounds before calling update/query.", "category": "data_structure", "language": "python"}
{"prompt": "Design and implement a priority queue in Python supporting bounded capacity with wrap-around semantics", "response": "python\n```python\nimport heapq\nfrom typing import List, Tuple\n\nclass BoundedPriorityQueue:\n    def __init__(self, capacity: int):\n        if capacity <= 0:\n            raise ValueError(\"capacity must be positive\")\n        self.capacity = capacity\n        self.heap: List[Tuple[int, object]] = []  # (priority, item)\n\n    def push(self, priority: int, item: object) -> None:\n        if len(self.heap) < self.capacity:\n            heapq.heappush(self.heap, (priority, item))\n        else:\n            # Evict the lowest priority if new priority is higher\n            if priority > self.heap[0][0]:\n                heapq.heapreplace(self.heap, (priority, item))\n            # else drop the new item silently\n\n    def pop(self):\n        if not self.heap:\n            raise IndexError(\"pop from empty priority queue\")\n        return heapq.heappop(self.heap)\n\n    def peek(self):\n        if not self.heap:\n            raise IndexError(\"peek from empty priority queue\")\n        return self.heap[0]\n```\n**Explanation:** Maintains a min-heap with fixed capacity. New items are pushed until full; once full, only items with priority higher than the current minimum replace it, keeping the top-k highest priorities.\n**Complexity:** Time: O(log k) for push/pop; Space: O(k) where k = capacity.\n**Example:**\nInput: capacity=2; push(1,'a'); push(5,'b'); push(3,'c')\nOutput: queue retains (3,'c') and (5,'b'), dropping (1,'a')\n**Notes:**\n- Change the replacement rule if you want to always drop new items on full instead.\n- For max-heap semantics, invert priorities.\n- No wrap-around indexes needed; capacity enforced via heap size.", "category": "data_structure", "language": "python"}
{"prompt": "Design and implement a circular buffer in C++ supporting range queries and point updates", "response": "c++\n```cpp\n#include <vector>\n#include <stdexcept>\n\n// Circular buffer with range-sum queries and point updates using a segment tree.\nclass CircularBuffer {\npublic:\n    explicit CircularBuffer(size_t capacity)\n        : n_(capacity), data_(capacity, 0), seg_(capacity * 2, 0), head_(0), size_(0) {\n        if (capacity == 0) throw std::invalid_argument(\"capacity must be > 0\");\n    }\n\n    void push(int value) {\n        size_t idx = (head_ + size_) % n_;\n        if (size_ == n_) { // overwrite oldest\n            updateInternal(idx, value);\n            head_ = (head_ + 1) % n_;\n        } else {\n            data_[idx] = value;\n            updateInternal(idx, value);\n            size_++;\n        }\n    }\n\n    // Range sum on logical indices [l, r] within current size, with wrap handled.\n    int rangeSum(size_t l, size_t r) const {\n        if (l > r || r >= size_) throw std::out_of_range(\"invalid range\");\n        // map logical indices to physical positions\n        size_t start = (head_ + l) % n_;\n        size_t end = (head_ + r) % n_;\n        if (start <= end) return query(start, end);\n        // wrapped: sum start..n-1 plus 0..end\n        return query(start, n_ - 1) + query(0, end);\n    }\n\n    void updateLogical(size_t idx, int value) {\n        if (idx >= size_) throw std::out_of_range(\"invalid index\");\n        size_t pos = (head_ + idx) % n_;\n        updateInternal(pos, value);\n    }\n\nprivate:\n    size_t n_;\n    std::vector<int> data_;\n    std::vector<int> seg_;\n    size_t head_, size_;\n\n    void build() {\n        for (size_t i = 0; i < n_; i++) seg_[n_ + i] = data_[i];\n        for (size_t i = n_ - 1; i > 0; i--) seg_[i] = seg_[i << 1] + seg_[i << 1 | 1];\n    }\n\n    void updateInternal(size_t pos, int value) {\n        data_[pos] = value;\n        size_t i = n_ + pos;\n        seg_[i] = value;\n        while (i > 1) {\n            i >>= 1;\n            seg_[i] = seg_[i << 1] + seg_[(i << 1) | 1];\n        }\n    }\n\n    int query(size_t l, size_t r) const {\n        int res = 0;\n        for (l += n_, r += n_; l <= r; l >>= 1, r >>= 1) {\n            if (l & 1) res += seg_[l++];\n            if (!(r & 1)) res += seg_[r--];\n        }\n        return res;\n    }\n};\n```\n**Explanation:** Maintains a fixed-size ring buffer and a segment tree for point updates and range-sum queries. Logical indices are offset by the head pointer to support wrap-around; queries split into up to two ranges when they wrap the physical array.\n**Complexity:** Time: O(log n) for push (overwrite/update), updateLogical, and rangeSum; Space: O(n) for storage and tree.\n**Example:**\nInput: capacity=4; push 1,2,3,4; rangeSum(1,3)\nOutput: 9 (2+3+4)\n**Notes:**\n- Push overwrites the oldest element when full; adjust policy if eviction should fail instead.\n- Initialization builds the segment tree lazily via updates; call build() if bulk-loading data.\n- Convert to other aggregate functions by changing the merge operation.", "category": "data_structure", "language": "c++"}
{"prompt": "Implement a binary search tree in JavaScript with efficient lookup and insertion", "response": "javascript\n```javascript\nclass Node {\n  constructor(val) {\n    this.val = val;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nclass BST {\n  constructor() {\n    this.root = null;\n  }\n  insert(val) {\n    this.root = this._insert(this.root, val);\n  }\n  _insert(node, val) {\n    if (!node) return new Node(val);\n    if (val < node.val) node.left = this._insert(node.left, val);\n    else if (val > node.val) node.right = this._insert(node.right, val);\n    return node;\n  }\n  search(val) {\n    let cur = this.root;\n    while (cur) {\n      if (cur.val === val) return true;\n      cur = val < cur.val ? cur.left : cur.right;\n    }\n    return false;\n  }\n  remove(val) {\n    this.root = this._remove(this.root, val);\n  }\n  _remove(node, val) {\n    if (!node) return null;\n    if (val < node.val) node.left = this._remove(node.left, val);\n    else if (val > node.val) node.right = this._remove(node.right, val);\n    else {\n      if (!node.left) return node.right;\n      if (!node.right) return node.left;\n      let succ = node.right;\n      while (succ.left) succ = succ.left;\n      node.val = succ.val;\n      node.right = this._remove(node.right, succ.val);\n    }\n    return node;\n  }\n}\n```\n**Explanation:** Implements BST insertion, search, and deletion. Insert recurses to place the value; search walks iteratively; delete handles 0/1-child cases and uses the in-order successor when two children exist.\n**Complexity:** Time: O(h) per op (h = height); Space: O(h) recursion in insert/remove.\n**Example:**\nInput: insert 5,3,7; search 3\nOutput: true\n**Notes:**\n- Unbalanced trees can degrade to O(n); use a balanced tree for guaranteed performance.\n- Duplicate inserts are ignored; change policy if duplicates should be stored.\n- Convert to iterative insert/delete to avoid recursion depth issues.", "category": "data_structure", "language": "javascript"}
{"prompt": "Implement a queue in Rust with insert, delete, and search operations", "response": "rust\n```rust\npub struct Queue<T> {\n    data: std::collections::VecDeque<T>,\n}\n\nimpl<T> Queue<T> {\n    pub fn new() -> Self {\n        Self { data: std::collections::VecDeque::new() }\n    }\n\n    pub fn insert(&mut self, item: T) {\n        self.data.push_back(item);\n    }\n\n    pub fn delete(&mut self) -> Option<T> {\n        self.data.pop_front()\n    }\n\n    pub fn search(&self, target: &T) -> Option<usize>\n    where\n        T: PartialEq,\n    {\n        self.data.iter().position(|x| x == target)\n    }\n\n    pub fn is_empty(&self) -> bool {\n        self.data.is_empty()\n    }\n}\n```\n**Explanation:** Wraps `VecDeque` to provide enqueue (`insert`), dequeue (`delete`), and linear search. Maintains FIFO ordering with O(1) head/tail operations.\n**Complexity:** Time: O(1) for insert/delete, O(n) for search; Space: O(n).\n**Example:**\nInput: enqueue 1,2; search 2; delete()\nOutput: search -> 1 (index), delete -> 1\n**Notes:**\n- `search` returns the zero-based position; return bool if only existence matters.\n- For thread safety, wrap in `Mutex`/`RwLock` as needed.\n- Accepts any type; requires `PartialEq` only when searching.", "category": "data_structure", "language": "rust"}
{"prompt": "Design and implement a LRU cache in Python supporting thread-safe operations", "response": "python\n```python\nimport threading\nfrom collections import OrderedDict\n\nclass ThreadSafeLRU:\n    def __init__(self, capacity: int):\n        if capacity <= 0:\n            raise ValueError(\"capacity must be positive\")\n        self.cap = capacity\n        self.cache: OrderedDict[int, int] = OrderedDict()\n        self.lock = threading.Lock()\n\n    def get(self, key):\n        with self.lock:\n            if key not in self.cache:\n                return -1\n            self.cache.move_to_end(key)\n            return self.cache[key]\n\n    def put(self, key, value):\n        with self.lock:\n            if key in self.cache:\n                self.cache.move_to_end(key)\n            self.cache[key] = value\n            if len(self.cache) > self.cap:\n                self.cache.popitem(last=False)\n```\n**Explanation:** Wraps `OrderedDict` operations with a mutex. `get` updates recency, `put` inserts/updates and evicts the least recently used when exceeding capacity.\n**Complexity:** Time: O(1) average per operation; Space: O(capacity).\n**Example:**\nInput: cap=2; put(1,1); put(2,2); get(1); put(3,3); get(2)\nOutput: get(1)=1, get(2)=-1 (evicted)\n**Notes:**\n- Returns -1 on misses; adjust to raise if preferred.\n- For high contention, consider finer-grained or lock-free structures, but OrderedDict access is simple and reliable.\n- Ensure keys are hashable; change types as needed.", "category": "data_structure", "language": "python"}
{"prompt": "Implement a heap in JavaScript with efficient lookup and insertion", "response": "javascript\n```javascript\nclass MinHeap {\n  constructor() {\n    this.data = [];\n  }\n  push(x) {\n    this.data.push(x);\n    this._siftUp(this.data.length - 1);\n  }\n  pop() {\n    if (this.data.length === 0) return undefined;\n    const root = this.data[0];\n    const last = this.data.pop();\n    if (this.data.length && last !== undefined) {\n      this.data[0] = last;\n      this._siftDown(0);\n    }\n    return root;\n  }\n  peek() {\n    return this.data[0];\n  }\n  _siftUp(i) {\n    while (i > 0) {\n      const p = (i - 1) >> 1;\n      if (this.data[p] <= this.data[i]) break;\n      [this.data[p], this.data[i]] = [this.data[i], this.data[p]];\n      i = p;\n    }\n  }\n  _siftDown(i) {\n    const n = this.data.length;\n    while (true) {\n      let smallest = i;\n      const l = 2 * i + 1, r = 2 * i + 2;\n      if (l < n && this.data[l] < this.data[smallest]) smallest = l;\n      if (r < n && this.data[r] < this.data[smallest]) smallest = r;\n      if (smallest === i) break;\n      [this.data[i], this.data[smallest]] = [this.data[smallest], this.data[i]];\n      i = smallest;\n    }\n  }\n}\n```\n**Explanation:** Implements a binary min-heap with array storage. `push` appends then sifts up; `pop` removes root, replaces with last, then sifts down to restore heap order. `peek` inspects the minimum without removal.\n**Complexity:** Time: O(log n) for push/pop; O(1) for peek; Space: O(n).\n**Example:**\nInput: push 3, push 1, push 2, pop()\nOutput: pop returns 1\n**Notes:**\n- Works for numbers; supply a comparator if you need custom ordering.\n- No capacity limit; add one if needed to bound memory.\n- Ensure stability if storing objects by wrapping with priority values.", "category": "data_structure", "language": "javascript"}
{"prompt": "Implement a trie in JavaScript with all basic operations", "response": "javascript\n```javascript\nclass TrieNode {\n  constructor() {\n    this.children = new Map();\n    this.end = false;\n  }\n}\n\nclass Trie {\n  constructor() {\n    this.root = new TrieNode();\n  }\n  insert(word) {\n    let node = this.root;\n    for (const ch of word) {\n      if (!node.children.has(ch)) node.children.set(ch, new TrieNode());\n      node = node.children.get(ch);\n    }\n    node.end = true;\n  }\n  search(word) {\n    let node = this.root;\n    for (const ch of word) {\n      if (!node.children.has(ch)) return false;\n      node = node.children.get(ch);\n    }\n    return node.end;\n  }\n  startsWith(prefix) {\n    let node = this.root;\n    for (const ch of prefix) {\n      if (!node.children.has(ch)) return false;\n      node = node.children.get(ch);\n    }\n    return true;\n  }\n}\n```\n**Explanation:** Each node holds a map of children and an end-of-word flag. Insertion walks/creates nodes for each character; search follows the path and returns true only if the end flag is set; `startsWith` checks prefix existence regardless of the end flag.\n**Complexity:** Time: O(L) per insert/search; Space: O(total characters stored).\n**Example:**\nInput: insert('car'), search('car'), startsWith('ca')\nOutput: true, true\n**Notes:**\n- Case-sensitive; normalize input if needed.\n- For deletion, unset end and prune childless nodes.\n- Replace Map with array indexed by character for fixed alphabets to improve speed.", "category": "data_structure", "language": "javascript"}
{"prompt": "Design and implement a LRU cache in Java supporting thread-safe operations", "response": "java\n```java\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\npublic class ConcurrentLRU<K, V> {\n    private final int capacity;\n    private final Map<K, V> map;\n\n    public ConcurrentLRU(int capacity) {\n        this.capacity = capacity;\n        this.map = new LinkedHashMap<>(capacity, 0.75f, true) {\n            @Override\n            protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {\n                return size() > ConcurrentLRU.this.capacity;\n            }\n        };\n    }\n\n    public synchronized V get(K key) {\n        return map.getOrDefault(key, null);\n    }\n\n    public synchronized void put(K key, V value) {\n        map.put(key, value);\n    }\n}\n```\n**Explanation:** Uses a synchronized wrapper around an access-ordered `LinkedHashMap` with overridden `removeEldestEntry` to evict the least recently used entry once capacity is exceeded.\n**Complexity:** Time: O(1) average for get/put; Space: O(capacity).\n**Example:**\nInput: cap=2; put(1,\"a\"); put(2,\"b\"); get(1); put(3,\"c\")\nOutput: key 2 is evicted; map holds keys 1 and 3\n**Notes:**\n- Coarse-grained synchronization is simple; for higher throughput use `ConcurrentLinkedHashMap`-style structures.\n- Returns null on miss; adjust to throw or return Optional.\n- Ensure capacity > 0; otherwise eviction policy misbehaves.", "category": "data_structure", "language": "java"}
{"prompt": "Implement a queue in JavaScript with all basic operations", "response": "javascript\n```javascript\nclass Queue {\n  constructor() {\n    this.data = [];\n    this.head = 0;\n  }\n  enqueue(x) {\n    this.data.push(x);\n  }\n  dequeue() {\n    if (this.isEmpty()) return undefined;\n    const val = this.data[this.head++];\n    // trim occasionally to avoid unbounded growth\n    if (this.head > 50 && this.head * 2 > this.data.length) {\n      this.data = this.data.slice(this.head);\n      this.head = 0;\n    }\n    return val;\n  }\n  peek() {\n    return this.isEmpty() ? undefined : this.data[this.head];\n  }\n  isEmpty() {\n    return this.head >= this.data.length;\n  }\n}\n```\n**Explanation:** Implements a simple queue using an array with a moving head index to achieve O(1) amortized dequeues. Periodically compacts the array to reclaim space.\n**Complexity:** Time: O(1) amortized for enqueue/dequeue; Space: O(n).\n**Example:**\nInput: enqueue 1,2; dequeue -> 1; peek -> 2\nOutput: as shown\n**Notes:**\n- For guaranteed O(1) without slicing, use a ring buffer.\n- Returns undefined on empty operations; adjust to throw if preferred.\n- Not thread-safe; coordinate access if used concurrently.", "category": "data_structure", "language": "javascript"}
{"prompt": "Implement a graph in C++ with efficient lookup and insertion", "response": "c++\n```cpp\n#include <unordered_map>\n#include <vector>\n\nclass Graph {\npublic:\n    void addEdge(int u, int v, bool bidirectional = false) {\n        adj_[u].push_back(v);\n        if (bidirectional) adj_[v].push_back(u);\n    }\n\n    const std::vector<int>& neighbors(int u) const {\n        static const std::vector<int> empty;\n        auto it = adj_.find(u);\n        return it == adj_.end() ? empty : it->second;\n    }\n\nprivate:\n    std::unordered_map<int, std::vector<int>> adj_;\n};\n```\n**Explanation:** Uses an adjacency list backed by an unordered_map for O(1) average insertions and neighbor lookups. Supports optional bidirectional edges and returns neighbor vectors by reference.\n**Complexity:** Time: O(1) average for addEdge; Space: O(V + E).\n**Example:**\nInput: addEdge(1,2,true); neighbors(1)\nOutput: [2]\n**Notes:**\n- Extend with edge weights by storing pairs (v, w).\n- Add node deletion by removing keys and pruning neighbor lists if required.\n- Keys are ints here; template the class for other key types.", "category": "data_structure", "language": "c++"}
{"prompt": "Design and implement a segment tree in Java supporting bounded capacity with wrap-around semantics", "response": "java\n```java\npublic class CircularSegmentTree {\n    private final int n;\n    private final int[] tree;\n    private int head = 0; // next write position\n    private int size = 0;\n\n    public CircularSegmentTree(int capacity) {\n        if (capacity <= 0) throw new IllegalArgumentException(\"capacity must be positive\");\n        this.n = capacity;\n        this.tree = new int[2 * n];\n    }\n\n    public void push(int value) {\n        int pos = (head + size) % n;\n        if (size == n) {\n            // overwrite oldest at head\n            pos = head;\n            head = (head + 1) % n;\n        } else {\n            size++;\n        }\n        updatePhysical(pos, value);\n    }\n\n    public void updateLogical(int idx, int value) {\n        if (idx < 0 || idx >= size) throw new IndexOutOfBoundsException();\n        int pos = (head + idx) % n;\n        updatePhysical(pos, value);\n    }\n\n    public int rangeSum(int l, int r) {\n        if (l < 0 || r >= size || l > r) throw new IndexOutOfBoundsException();\n        int start = (head + l) % n;\n        int end = (head + r) % n;\n        if (start <= end) return query(start, end);\n        return query(start, n - 1) + query(0, end);\n    }\n\n    private void updatePhysical(int pos, int value) {\n        int i = pos + n;\n        tree[i] = value;\n        while (i > 1) {\n            i >>= 1;\n            tree[i] = tree[i << 1] + tree[i << 1 | 1];\n        }\n    }\n\n    private int query(int l, int r) {\n        l += n; r += n;\n        int res = 0;\n        while (l <= r) {\n            if ((l & 1) == 1) res += tree[l++];\n            if ((r & 1) == 0) res += tree[r--];\n            l >>= 1; r >>= 1;\n        }\n        return res;\n    }\n}\n```\n**Explanation:** Fixed-capacity ring buffer backed by a segment tree for range sums. `push` overwrites the oldest when full. Logical indices offset from `head` map to physical positions for updates and queries; wrapped ranges are split into two queries.\n**Complexity:** Time: O(log n) for push/update/query; Space: O(n) for the tree.\n**Example:**\nInput: capacity=3; push 1,2,3; rangeSum(0,2)=6; push 4 (overwrites 1); rangeSum(0,2)=9\nOutput: sums as shown\n**Notes:**\n- Adjust merge operation for min/max as needed.\n- If overwriting is undesirable, throw when size==capacity instead.\n- Ensure callers respect current `size` when querying logical indices.", "category": "data_structure", "language": "java"}
{"prompt": "Design and implement a priority queue in Python supporting thread-safe operations", "response": "python\n```python\nimport heapq\nimport threading\nfrom typing import Any, Tuple\n\nclass ThreadSafePriorityQueue:\n    def __init__(self):\n        self._heap: list[Tuple[int, Any]] = []\n        self._lock = threading.Lock()\n\n    def push(self, priority: int, item: Any) -> None:\n        with self._lock:\n            heapq.heappush(self._heap, (priority, item))\n\n    def pop(self) -> Tuple[int, Any] | None:\n        with self._lock:\n            if not self._heap:\n                return None\n            return heapq.heappop(self._heap)\n\n    def peek(self) -> Tuple[int, Any] | None:\n        with self._lock:\n            return self._heap[0] if self._heap else None\n```\n**Explanation:** Wraps a min-heap with a mutex to serialize access. Supports push, pop, and peek operations on prioritized items.\n**Complexity:** Time: O(log n) for push/pop; O(1) for peek; Space: O(n).\n**Example:**\nInput: push(2,'b'); push(1,'a'); pop()\nOutput: (1, 'a')\n**Notes:**\n- Tuple ordering uses priority first; ensure priorities are comparable.\n- For blocking semantics, add condition variables to wait for items.\n- Priorities can be inverted to represent max-heap behavior.", "category": "data_structure", "language": "python"}
{"prompt": "Design and implement a disjoint set (union-find) in C++ supporting O(1) eviction and retrieval", "response": "c++\n```cpp\n#include <vector>\n#include <numeric>\n\nclass UnionFind {\npublic:\n    explicit UnionFind(int n) : parent_(n), rank_(n, 0) {\n        std::iota(parent_.begin(), parent_.end(), 0);\n    }\n    int find(int x) {\n        if (parent_[x] != x) parent_[x] = find(parent_[x]);\n        return parent_[x];\n    }\n    void unite(int a, int b) {\n        a = find(a); b = find(b);\n        if (a == b) return;\n        if (rank_[a] < rank_[b]) std::swap(a, b);\n        parent_[b] = a;\n        if (rank_[a] == rank_[b]) rank_[a]++;\n    }\nprivate:\n    std::vector<int> parent_;\n    std::vector<int> rank_;\n};\n```\n**Explanation:** Classic disjoint-set union with path compression and union by rank to keep trees shallow, delivering near-constant-time operations for connectivity queries.\n**Complexity:** Time: Amortized ~O(α(n)); Space: O(n).\n**Example:**\nInput: unite(0,1); unite(2,3); find(3)\nOutput: representative of set containing 3\n**Notes:**\n- Capacity fixed at construction; recreate to expand.\n- Add `connected(a,b)` helper for convenience.\n- Not thread-safe; add synchronization if shared across threads.", "category": "data_structure", "language": "c++"}
{"prompt": "Implement a hash table in C++ with efficient lookup and insertion", "response": "c++\n```cpp\n#include <vector>\n#include <list>\n#include <utility>\n#include <stdexcept>\n\nclass HashTable {\npublic:\n    explicit HashTable(size_t capacity = 16) : buckets_(capacity) {}\n\n    void put(const std::string& key, const std::string& value) {\n        auto& bucket = buckets_[index(key)];\n        for (auto& [k, v] : bucket) {\n            if (k == key) { v = value; return; }\n        }\n        bucket.emplace_back(key, value);\n    }\n\n    std::string get(const std::string& key) const {\n        const auto& bucket = buckets_[index(key)];\n        for (const auto& [k, v] : bucket) if (k == key) return v;\n        throw std::out_of_range(\"key not found\");\n    }\n\n    bool contains(const std::string& key) const {\n        const auto& bucket = buckets_[index(key)];\n        for (const auto& [k, _] : bucket) if (k == key) return true;\n        return false;\n    }\n\nprivate:\n    std::vector<std::list<std::pair<std::string, std::string>>> buckets_;\n\n    size_t index(const std::string& key) const {\n        return std::hash<std::string>{}(key) % buckets_.size();\n    }\n};\n```\n**Explanation:** Separate-chaining hash table using a vector of lists. `put` inserts or updates, `get` retrieves or throws on miss, and `contains` checks existence. Hashes keys to bucket indices via `std::hash`.\n**Complexity:** Time: O(1) average per op; Space: O(n) for entries.\n**Example:**\nInput: put(\"a\",\"1\"); get(\"a\")\nOutput: \"1\"\n**Notes:**\n- Resize when load factor grows to keep performance consistent.\n- Replace `std::string` with templates for generic keys/values if needed.\n- Not thread-safe; wrap in locks for concurrent access.", "category": "data_structure", "language": "c++"}
{"prompt": "Design and implement a priority queue in Java supporting range queries and point updates", "response": "java\n```java\nimport java.util.function.BiFunction;\n\npublic class SegmentTree {\n    private final int n;\n    private final int[] tree;\n\n    public SegmentTree(int[] nums) {\n        this.n = nums.length;\n        this.tree = new int[2 * n];\n        System.arraycopy(nums, 0, tree, n, n);\n        for (int i = n - 1; i > 0; i--) {\n            tree[i] = tree[2 * i] + tree[2 * i + 1];\n        }\n    }\n\n    public synchronized void update(int idx, int val) {\n        int i = idx + n;\n        tree[i] = val;\n        for (i >>= 1; i > 0; i >>= 1) {\n            tree[i] = tree[2 * i] + tree[2 * i + 1];\n        }\n    }\n\n    public synchronized int rangeSum(int l, int r) {\n        l += n; r += n;\n        int res = 0;\n        while (l <= r) {\n            if ((l & 1) == 1) res += tree[l++];\n            if ((r & 1) == 0) res += tree[r--];\n            l >>= 1; r >>= 1;\n        }\n        return res;\n    }\n}\n```\n**Explanation:** Coarse-grained synchronized segment tree supporting point updates and range sum queries. Leaves start at `n`; parents aggregate child sums upward.\n**Complexity:** Time: O(log n) per update/query; Space: O(n).\n**Example:**\nInput: nums=[1,3,5], rangeSum(0,2)\nOutput: 9\n**Notes:**\n- Replace sum with another associative operation if needed.\n- Synchronization is simple but blocks concurrent reads/writes; use finer locks if necessary.\n- Validate indices in production code.", "category": "data_structure", "language": "java"}
{"prompt": "Implement a heap in JavaScript with O(1) get-min or get-max support", "response": "javascript\n```javascript\nclass MinHeap {\n  constructor() {\n    this.data = [];\n  }\n  push(x) {\n    this.data.push(x);\n    this._up(this.data.length - 1);\n  }\n  pop() {\n    if (!this.data.length) return undefined;\n    const root = this.data[0];\n    const last = this.data.pop();\n    if (this.data.length && last !== undefined) {\n      this.data[0] = last;\n      this._down(0);\n    }\n    return root;\n  }\n  peek() {\n    return this.data[0]; // O(1) get-min\n  }\n  _up(i) {\n    while (i > 0) {\n      const p = (i - 1) >> 1;\n      if (this.data[p] <= this.data[i]) break;\n      [this.data[p], this.data[i]] = [this.data[i], this.data[p]];\n      i = p;\n    }\n  }\n  _down(i) {\n    const n = this.data.length;\n    while (true) {\n      let smallest = i;\n      const l = 2 * i + 1, r = 2 * i + 2;\n      if (l < n && this.data[l] < this.data[smallest]) smallest = l;\n      if (r < n && this.data[r] < this.data[smallest]) smallest = r;\n      if (smallest === i) break;\n      [this.data[i], this.data[smallest]] = [this.data[smallest], this.data[i]];\n      i = smallest;\n    }\n  }\n}\n```\n**Explanation:** Implements a binary min-heap with O(1) `peek()` to retrieve the minimum. Insertion and removal restore heap order via sift-up/sift-down.\n**Complexity:** Time: O(log n) push/pop; Space: O(n).\n**Example:**\nInput: push 3, push 1, peek -> 1, pop -> 1\nOutput: correct min operations\n**Notes:**\n- For max-heap, invert comparisons.\n- No capacity bound; add if you need O(1) eviction semantics.\n- Ensure comparisons suit your element type; wrap objects with priorities if needed.", "category": "data_structure", "language": "javascript"}
{"prompt": "Design and implement a disjoint set (union-find) in C++ supporting union and find with path compression", "response": "c++\n```cpp\n#include <vector>\n#include <numeric>\n\nclass UnionFind {\npublic:\n    explicit UnionFind(int n) : parent_(n), rank_(n, 0) {\n        std::iota(parent_.begin(), parent_.end(), 0);\n    }\n    int find(int x) {\n        if (parent_[x] != x) parent_[x] = find(parent_[x]);\n        return parent_[x];\n    }\n    void unite(int a, int b) {\n        a = find(a); b = find(b);\n        if (a == b) return;\n        if (rank_[a] < rank_[b]) std::swap(a, b);\n        parent_[b] = a;\n        if (rank_[a] == rank_[b]) rank_[a]++;\n    }\nprivate:\n    std::vector<int> parent_;\n    std::vector<int> rank_;\n};\n```\n**Explanation:** Standard disjoint set with path compression in `find` and union by rank to keep trees shallow, enabling near-constant-time connectivity checks.\n**Complexity:** Time: Amortized ~O(α(n)) per op; Space: O(n).\n**Example:**\nInput: unite(0,1); unite(1,2); find(2)\nOutput: representative of set containing 0,1,2\n**Notes:**\n- No dynamic resizing; create with known capacity.\n- Add a `connected(a,b)` helper for clarity.\n- Not thread-safe; add synchronization for concurrent use.", "category": "data_structure", "language": "c++"}
{"prompt": "Design and implement a LRU cache in C++ supporting union and find with path compression", "response": "c++\n```cpp\n#include <list>\n#include <unordered_map>\n#include <stdexcept>\n\ntemplate <typename K, typename V>\nclass LRUCache {\npublic:\n    explicit LRUCache(size_t capacity) : cap_(capacity) {\n        if (capacity == 0) throw std::invalid_argument(\"capacity must be > 0\");\n    }\n\n    V get(const K& key) {\n        auto it = map_.find(key);\n        if (it == map_.end()) throw std::out_of_range(\"key not found\");\n        touch(it);\n        return it->second.first;\n    }\n\n    void put(const K& key, const V& value) {\n        auto it = map_.find(key);\n        if (it != map_.end()) {\n            it->second.first = value;\n            touch(it);\n            return;\n        }\n        if (map_.size() == cap_) {\n            auto lru = order_.back();\n            map_.erase(lru);\n            order_.pop_back();\n        }\n        order_.push_front(key);\n        map_[key] = {value, order_.begin()};\n    }\n\nprivate:\n    void touch(typename std::unordered_map<K, std::pair<V, typename std::list<K>::iterator>>::iterator it) {\n        order_.erase(it->second.second);\n        order_.push_front(it->first);\n        it->second.second = order_.begin();\n    }\n\n    size_t cap_;\n    std::list<K> order_;\n    std::unordered_map<K, std::pair<V, typename std::list<K>::iterator>> map_;\n};\n```\n**Explanation:** Stores cache entries in a map for O(1) lookups and a list to track recency. `get` moves the accessed key to the front; `put` updates existing entries or evicts the least recently used when capacity is reached.\n**Complexity:** Time: O(1) average for get/put; Space: O(capacity).\n**Example:**\nInput: capacity=2; put(1,\"a\"); put(2,\"b\"); get(1); put(3,\"c\")\nOutput: key 2 is evicted, cache holds keys 1 and 3\n**Notes:**\n- Exceptions signal missing keys; adjust to return sentinel values if preferred.\n- Template works for hashable keys; provide custom hash/equality if needed.\n- Not thread-safe; wrap in locks for concurrent access.", "category": "data_structure", "language": "c++"}
{"prompt": "Implement a binary search tree in Go with iterators with lazy traversal", "response": "go\n```go\npackage main\n\nimport \"container/list\"\n\ntype BSTNode struct {\n\tVal         int\n\tLeft, Right *BSTNode\n}\n\n// Iterator lazily yields nodes in-order over a channel.\nfunc Iterate(root *BSTNode) <-chan int {\n\tch := make(chan int)\n\tgo func() {\n\t\tvar stack list.List\n\t\tcur := root\n\t\tfor cur != nil || stack.Len() > 0 {\n\t\t\tfor cur != nil {\n\t\t\t\tstack.PushBack(cur)\n\t\t\t\tcur = cur.Left\n\t\t\t}\n\t\t\te := stack.Back()\n\t\t\tstack.Remove(e)\n\t\t\tnode := e.Value.(*BSTNode)\n\t\t\tch <- node.Val\n\t\t\tcur = node.Right\n\t\t}\n\t\tclose(ch)\n\t}()\n\treturn ch\n}\n```\n**Explanation:** Basic BST node definition and a lazy in-order iterator implemented with an explicit stack and a goroutine producing values on a channel. Consumes O(h) stack space and yields nodes without materializing a list.\n**Complexity:** Time: O(n) total iteration; Space: O(h) for stack.\n**Example:**\nInput: BST with values 2<-3->4\nOutput: channel yields 3,2,4\n**Notes:**\n- Insert/search/delete not shown; add standard BST ops as needed.\n- Caller must range over the channel to drain the goroutine.\n- For concurrency, ensure consumers handle the channel lifecycle properly.", "category": "data_structure", "language": "go"}
{"prompt": "Design and implement a priority queue in Java supporting O(1) eviction and retrieval", "response": "java\n```java\nimport java.util.NoSuchElementException;\n\npublic class BoundedQueue {\n    private final int[] data;\n    private int head = 0, tail = 0, size = 0;\n\n    public BoundedQueue(int capacity) {\n        if (capacity <= 0) throw new IllegalArgumentException(\"capacity>0\");\n        data = new int[capacity];\n    }\n\n    // O(1) eviction: overwrite oldest when full\n    public void offer(int val) {\n        if (size == data.length) {\n            data[tail] = val;\n            tail = (tail + 1) % data.length;\n            head = tail; // oldest evicted\n        } else {\n            data[tail] = val;\n            tail = (tail + 1) % data.length;\n            size++;\n        }\n    }\n\n    public int poll() {\n        if (size == 0) throw new NoSuchElementException(\"empty\");\n        int v = data[head];\n        head = (head + 1) % data.length;\n        size--;\n        return v;\n    }\n\n    public boolean isEmpty() { return size == 0; }\n}\n```\n**Explanation:** Implements a fixed-capacity circular queue where insertion is O(1) and evicts the oldest element when full. `poll` removes the head in O(1); wrap-around handled via modulo indices.\n**Complexity:** Time: O(1) per op; Space: O(capacity).\n**Example:**\nInput: capacity=2; offer 1; offer 2; offer 3 (evicts 1); poll() -> 2\nOutput: 2\n**Notes:**\n- Adjust eviction policy to throw instead of overwrite if desired.\n- Uses ints; generalize with generics for other types.\n- Not thread-safe; add synchronization for concurrent access.", "category": "data_structure", "language": "java"}
{"prompt": "Implement a trie in JavaScript with O(1) get-min or get-max support", "response": "javascript\n```javascript\nclass TrieNode {\n  constructor() {\n    this.children = new Map();\n    this.end = false;\n    this.minChar = null;\n    this.maxChar = null;\n  }\n}\n\nclass Trie {\n  constructor() {\n    this.root = new TrieNode();\n  }\n  insert(word) {\n    let node = this.root;\n    for (const ch of word) {\n      if (!node.children.has(ch)) node.children.set(ch, new TrieNode());\n      if (node.minChar === null || ch < node.minChar) node.minChar = ch;\n      if (node.maxChar === null || ch > node.maxChar) node.maxChar = ch;\n      node = node.children.get(ch);\n    }\n    node.end = true;\n  }\n  contains(word) {\n    let node = this.root;\n    for (const ch of word) {\n      if (!node.children.has(ch)) return false;\n      node = node.children.get(ch);\n    }\n    return node.end;\n  }\n  // O(1) access to min/max starting chars stored at root\n  minStart() { return this.root.minChar; }\n  maxStart() { return this.root.maxChar; }\n}\n```\n**Explanation:** Standard trie storing children per node. Tracks minimum and maximum starting characters at each node during insertion, allowing O(1) retrieval of min/max starting edges. Supports word insertion and membership checks.\n**Complexity:** Time: O(L) per insert/lookup; Space: O(total characters).\n**Example:**\nInput: insert('cat'), insert('dog'); minStart() -> 'c', maxStart() -> 'd'\nOutput: min/max reflect lexicographic extremes of stored words.\n**Notes:**\n- Extend min/max tracking deeper if you need prefix-specific extremes.\n- Replace Map with arrays for fixed alphabets for speed.\n- Add delete and prefix search as needed.", "category": "data_structure", "language": "javascript"}
{"prompt": "Design and implement a LRU cache in Rust supporting union and find with path compression", "response": "rust\n```rust\nuse std::collections::HashMap;\nuse std::collections::VecDeque;\n\npub struct LRUCache {\n    cap: usize,\n    map: HashMap<i32, i32>,\n    order: VecDeque<i32>,\n}\n\nimpl LRUCache {\n    pub fn new(capacity: usize) -> Self {\n        Self { cap: capacity, map: HashMap::new(), order: VecDeque::new() }\n    }\n\n    pub fn get(&mut self, key: i32) -> Option<i32> {\n        if let Some(&val) = self.map.get(&key) {\n            self.touch(key);\n            return Some(val);\n        }\n        None\n    }\n\n    pub fn put(&mut self, key: i32, value: i32) {\n        if self.map.contains_key(&key) {\n            self.map.insert(key, value);\n            self.touch(key);\n            return;\n        }\n        if self.map.len() == self.cap {\n            if let Some(lru) = self.order.pop_back() {\n                self.map.remove(&lru);\n            }\n        }\n        self.order.push_front(key);\n        self.map.insert(key, value);\n    }\n\n    fn touch(&mut self, key: i32) {\n        self.order.retain(|&k| k != key);\n        self.order.push_front(key);\n    }\n}\n```\n**Explanation:** Stores key/value pairs in a HashMap and tracks recency in a deque. `get`/`put` move keys to the front; when capacity is exceeded, evicts the least recently used from the back.\n**Complexity:** Time: O(1) average for get/put (touch uses retain O(n); for tighter bounds, use linked list + map of pointers); Space: O(capacity).\n**Example:**\nInput: cap=2; put(1,1); put(2,2); get(1); put(3,3)\nOutput: key 2 evicted; get(1) -> 1\n**Notes:**\n- For strict O(1) updates, replace retain with a linked list and key->node map.\n- Assumes small capacities where retain cost is acceptable.\n- Keys/values typed as i32 for simplicity; generalize as needed.", "category": "data_structure", "language": "rust"}
{"prompt": "Implement a graph in Python with O(1) get-min or get-max support", "response": "python\n```python\nfrom collections import defaultdict\n\n\nclass Graph:\n    def __init__(self):\n        self.adj = defaultdict(list)\n        self.min_edge = None\n        self.max_edge = None\n\n    def add_edge(self, u, v, w=0, bidirectional=False):\n        self.adj[u].append((v, w))\n        if bidirectional:\n            self.adj[v].append((u, w))\n        if self.min_edge is None or w < self.min_edge[2]:\n            self.min_edge = (u, v, w)\n        if self.max_edge is None or w > self.max_edge[2]:\n            self.max_edge = (u, v, w)\n\n    def neighbors(self, u):\n        return list(self.adj.get(u, ()))\n\n    def get_min_edge(self):\n        return self.min_edge\n\n    def get_max_edge(self):\n        return self.max_edge\n```\n**Explanation:** Adjacency list graph with O(1) access to the current minimum and maximum edge weights by tracking them on insertion. Supports optional bidirectional edges and neighbor lookup.\n**Complexity:** Time: O(1) to add edges/lookup neighbors; Space: O(V + E).\n**Example:**\nInput: add_edge('A','B',5); add_edge('B','C',2)\nOutput: get_min_edge() -> ('B','C',2), get_max_edge() -> ('A','B',5)\n**Notes:**\n- For dynamic edge deletions, recompute min/max or maintain heaps.\n- For unweighted graphs, ignore weight and min/max tracking.\n- Add node/edge removal as needed.", "category": "data_structure", "language": "python"}
{"prompt": "Implement a trie in Rust with O(1) get-min or get-max support", "response": "rust\n```rust\nuse std::collections::BTreeMap;\n\npub struct TrieNode {\n    children: BTreeMap<char, TrieNode>,\n    end: bool,\n}\n\nimpl TrieNode {\n    fn new() -> Self { Self { children: BTreeMap::new(), end: false } }\n}\n\npub struct Trie {\n    root: TrieNode,\n}\n\nimpl Trie {\n    pub fn new() -> Self { Self { root: TrieNode::new() } }\n\n    pub fn insert(&mut self, word: &str) {\n        let mut node = &mut self.root;\n        for ch in word.chars() {\n            node = node.children.entry(ch).or_insert_with(TrieNode::new);\n        }\n        node.end = true;\n    }\n\n    pub fn contains(&self, word: &str) -> bool {\n        let mut node = &self.root;\n        for ch in word.chars() {\n            if let Some(next) = node.children.get(&ch) {\n                node = next;\n            } else {\n                return false;\n            }\n        }\n        node.end\n    }\n\n    pub fn min_char(&self) -> Option<char> {\n        self.root.children.keys().next().copied()\n    }\n    pub fn max_char(&self) -> Option<char> {\n        self.root.children.keys().next_back().copied()\n    }\n}\n```\n**Explanation:** Standard trie backed by ordered `BTreeMap` for children, enabling O(1) access (via first/last key) to the minimum/maximum starting character. Supports insertion and membership checks.\n**Complexity:** Time: O(L) per insert/lookup; Space: O(total characters stored).\n**Example:**\nInput: insert(\"cat\"), insert(\"dog\"); min_char()->'c', max_char()->'d'\nOutput: min/max starting characters\n**Notes:**\n- For deeper min/max per prefix, descend storing additional metadata.\n- Replace `BTreeMap` with arrays for fixed alphabets to improve speed and memory.\n- Add delete and prefix search as needed.", "category": "data_structure", "language": "rust"}
{"prompt": "Design and implement a disjoint set (union-find) in Python supporting range queries and point updates", "response": "python\n```python\nclass UnionFind:\n    def __init__(self, n: int):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, x: int) -> int:\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, a: int, b: int) -> None:\n        ra, rb = self.find(a), self.find(b)\n        if ra == rb:\n            return\n        if self.rank[ra] < self.rank[rb]:\n            ra, rb = rb, ra\n        self.parent[rb] = ra\n        if self.rank[ra] == self.rank[rb]:\n            self.rank[ra] += 1\n```\n**Explanation:** Disjoint set union with path compression and union by rank for near-constant-time connectivity operations.\n**Complexity:** Time: Amortized ~O(α(n)) per op; Space: O(n).\n**Example:**\nInput: uf.union(0,1); uf.union(1,2); uf.find(2)\nOutput: representative of {0,1,2}\n**Notes:**\n- No range queries inherently; to support extra metadata per set, store additional arrays keyed by roots.\n- Validate indices before use in production.\n- Add a `connected(a,b)` helper for convenience.", "category": "data_structure", "language": "python"}
{"prompt": "Implement a hash table in Java with all basic operations", "response": "java\n```java\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class HashTable<K, V> {\n    private static final double LOAD_FACTOR = 0.75;\n    private List<Entry<K, V>>[] buckets;\n    private int size = 0;\n\n    @SuppressWarnings(\"unchecked\")\n    public HashTable(int capacity) {\n        buckets = new List[Math.max(1, capacity)];\n    }\n\n    public V get(K key) {\n        Entry<K, V> e = findEntry(key);\n        return e == null ? null : e.value;\n    }\n\n    public void put(K key, V value) {\n        ensureCapacity();\n        int idx = index(key);\n        if (buckets[idx] == null) buckets[idx] = new LinkedList<>();\n        for (Entry<K, V> e : buckets[idx]) {\n            if (Objects.equals(e.key, key)) { e.value = value; return; }\n        }\n        buckets[idx].add(new Entry<>(key, value));\n        size++;\n    }\n\n    public V remove(K key) {\n        int idx = index(key);\n        List<Entry<K, V>> bucket = buckets[idx];\n        if (bucket == null) return null;\n        for (var it = bucket.iterator(); it.hasNext();) {\n            Entry<K, V> e = it.next();\n            if (Objects.equals(e.key, key)) {\n                it.remove();\n                size--;\n                return e.value;\n            }\n        }\n        return null;\n    }\n\n    private Entry<K, V> findEntry(K key) {\n        List<Entry<K, V>> bucket = buckets[index(key)];\n        if (bucket == null) return null;\n        for (Entry<K, V> e : bucket) if (Objects.equals(e.key, key)) return e;\n        return null;\n    }\n\n    private int index(K key) {\n        return (key == null ? 0 : (key.hashCode() & 0x7fffffff)) % buckets.length;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void ensureCapacity() {\n        if (size >= buckets.length * LOAD_FACTOR) {\n            List<Entry<K, V>>[] old = buckets;\n            buckets = new List[old.length * 2];\n            size = 0;\n            for (List<Entry<K, V>> bucket : old) {\n                if (bucket == null) continue;\n                for (Entry<K, V> e : bucket) put(e.key, e.value);\n            }\n        }\n    }\n\n    private static class Entry<K, V> {\n        final K key; V value;\n        Entry(K k, V v) { key = k; value = v; }\n    }\n}\n```\n**Explanation:** Separate-chaining hash table with dynamic resizing. Supports put/get/remove, rehashing when load factor is exceeded, and handles null keys by mapping them to bucket 0.\n**Complexity:** Time: O(1) average for operations; Space: O(n).\n**Example:**\nInput: put(\"a\",1); get(\"a\")\nOutput: 1\n**Notes:**\n- Customize `LOAD_FACTOR` for different memory/performance trade-offs.\n- Not thread-safe; synchronize if used concurrently.\n- For better iteration order, use LinkedHashMap instead.", "category": "data_structure", "language": "java"}
{"prompt": "Implement a heap in C++ with efficient lookup and insertion", "response": "c++\n```cpp\n#include <vector>\n\nclass MinHeap {\npublic:\n    void push(int x) {\n        data_.push_back(x);\n        siftUp(data_.size() - 1);\n    }\n    int pop() {\n        int root = data_.front();\n        data_.front() = data_.back();\n        data_.pop_back();\n        if (!data_.empty()) siftDown(0);\n        return root;\n    }\n    int peek() const { return data_.front(); }\n    bool empty() const { return data_.empty(); }\n\nprivate:\n    std::vector<int> data_;\n    void siftUp(size_t i) {\n        while (i > 0) {\n            size_t p = (i - 1) / 2;\n            if (data_[p] <= data_[i]) break;\n            std::swap(data_[p], data_[i]);\n            i = p;\n        }\n    }\n    void siftDown(size_t i) {\n        size_t n = data_.size();\n        while (true) {\n            size_t l = 2 * i + 1, r = 2 * i + 2, smallest = i;\n            if (l < n && data_[l] < data_[smallest]) smallest = l;\n            if (r < n && data_[r] < data_[smallest]) smallest = r;\n            if (smallest == i) break;\n            std::swap(data_[i], data_[smallest]);\n            i = smallest;\n        }\n    }\n};\n```\n**Explanation:** Binary min-heap with push/pop/peek operations. Sift-up restores heap after insertion; sift-down fixes the heap after removal.\n**Complexity:** Time: O(log n) push/pop; O(1) peek; Space: O(n).\n**Example:**\nInput: push 3,1,2 then pop()\nOutput: 1\n**Notes:**\n- For custom ordering, parameterize the comparator.\n- Add bounds checks if popping from an empty heap is possible.\n- Use std::priority_queue for a built-in alternative.", "category": "data_structure", "language": "c++"}
{"prompt": "Design and implement a circular buffer in Python supporting thread-safe operations", "response": "python\n```python\nimport threading\n\nclass ThreadSafeCircularBuffer:\n    def __init__(self, capacity: int):\n        if capacity <= 0:\n            raise ValueError(\"capacity must be positive\")\n        self.data = [None] * capacity\n        self.head = 0  # next write\n        self.size = 0\n        self.lock = threading.Lock()\n\n    def push(self, item):\n        with self.lock:\n            self.data[(self.head + self.size) % len(self.data)] = item\n            if self.size == len(self.data):\n                self.head = (self.head + 1) % len(self.data)  # overwrite oldest\n            else:\n                self.size += 1\n\n    def pop(self):\n        with self.lock:\n            if self.size == 0:\n                raise IndexError(\"buffer empty\")\n            idx = self.head\n            val = self.data[idx]\n            self.head = (self.head + 1) % len(self.data)\n            self.size -= 1\n            return val\n```\n**Explanation:** Implements a ring buffer with mutex protection. Push overwrites the oldest when full; pop removes the oldest element. Head/size track logical order with wrap-around via modulo arithmetic.\n**Complexity:** Time: O(1) per push/pop; Space: O(capacity).\n**Example:**\nInput: capacity=2; push 1; push 2; push 3 (evicts 1); pop() -> 2\nOutput: 2\n**Notes:**\n- Change policy to raise on overflow instead of overwrite if desired.\n- Add peek/len helpers for convenience.\n- Locking is coarse but simple; refine if higher concurrency is needed.", "category": "data_structure", "language": "python"}
{"prompt": "Design and implement a LRU cache in C++ supporting O(1) eviction and retrieval", "response": "c++\n```cpp\n#include <list>\n#include <unordered_map>\n#include <stdexcept>\n\ntemplate <typename K, typename V>\nclass LRUCache {\npublic:\n    explicit LRUCache(size_t capacity) : cap_(capacity) {\n        if (capacity == 0) throw std::invalid_argument(\"capacity must be > 0\");\n    }\n\n    V get(const K& key) {\n        auto it = map_.find(key);\n        if (it == map_.end()) throw std::out_of_range(\"miss\");\n        touch(it);\n        return it->second.first;\n    }\n\n    void put(const K& key, const V& value) {\n        auto it = map_.find(key);\n        if (it != map_.end()) {\n            it->second.first = value;\n            touch(it);\n            return;\n        }\n        if (map_.size() == cap_) {\n            K lru = order_.back();\n            order_.pop_back();\n            map_.erase(lru);\n        }\n        order_.push_front(key);\n        map_[key] = {value, order_.begin()};\n    }\n\nprivate:\n    void touch(typename std::unordered_map<K, std::pair<V, typename std::list<K>::iterator>>::iterator it) {\n        order_.erase(it->second.second);\n        order_.push_front(it->first);\n        it->second.second = order_.begin();\n    }\n\n    size_t cap_;\n    std::list<K> order_;\n    std::unordered_map<K, std::pair<V, typename std::list<K>::iterator>> map_;\n};\n```\n**Explanation:** Combines an unordered_map for O(1) lookups with a list for recency tracking. On get/put, moves the key to the front; when capacity is exceeded, evicts the least-recently used key from the back.\n**Complexity:** Time: O(1) average per op; Space: O(capacity).\n**Example:**\nInput: cap=2; put(1,\"a\"); put(2,\"b\"); get(1); put(3,\"c\")\nOutput: key 2 evicted; cache holds 1,3\n**Notes:**\n- Throws on misses; return sentinel if preferred.\n- Thread-safety not provided; add locks for concurrent use.\n- Template supports any hashable key type.", "category": "data_structure", "language": "c++"}
{"prompt": "Implement a trie in Rust with iterators with lazy traversal", "response": "rust\n```rust\nuse std::collections::BTreeMap;\n\npub struct TrieNode {\n    children: BTreeMap<char, TrieNode>,\n    end: bool,\n}\n\nimpl TrieNode {\n    fn new() -> Self { Self { children: BTreeMap::new(), end: false } }\n}\n\npub struct Trie {\n    root: TrieNode,\n}\n\nimpl Trie {\n    pub fn new() -> Self { Self { root: TrieNode::new() } }\n\n    pub fn insert(&mut self, word: &str) {\n        let mut node = &mut self.root;\n        for ch in word.chars() {\n            node = node.children.entry(ch).or_insert_with(TrieNode::new);\n        }\n        node.end = true;\n    }\n\n    pub fn iter<'a>(&'a self) -> impl Iterator<Item = String> + 'a {\n        let mut stack: Vec<(String, &TrieNode)> = Vec::new();\n        stack.push((String::new(), &self.root));\n        std::iter::from_fn(move || {\n            while let Some((prefix, node)) = stack.pop() {\n                if node.end {\n                    return Some(prefix);\n                }\n                for (&ch, child) in node.children.iter().rev() {\n                    let mut next = prefix.clone();\n                    next.push(ch);\n                    stack.push((next, child));\n                }\n            }\n            None\n        })\n    }\n}\n```\n**Explanation:** Implements a trie with insertion and a lazy iterator that yields stored words via an explicit stack. Uses `BTreeMap` for ordered children; iterator clones prefixes as it traverses.\n**Complexity:** Time: O(L) insert; iteration O(total characters); Space: O(total characters) for storage plus O(h) stack during iteration.\n**Example:**\nInput: insert(\"cat\"), insert(\"car\"); iter() yields \"car\", \"cat\" (order depends on iteration order)\nOutput: as described\n**Notes:**\n- Adjust iteration order by changing the traversal of `children`.\n- For memory efficiency, yield references to characters with lifetimes instead of owning Strings, at the cost of ergonomics.\n- Add search/prefix methods as needed.", "category": "data_structure", "language": "rust"}
{"prompt": "Design and implement a segment tree in C++ supporting range queries and point updates", "response": "c++\n```cpp\n#include <vector>\n#include <stdexcept>\n\nclass SegmentTree {\npublic:\n    explicit SegmentTree(const std::vector<int>& nums) : n_(nums.size()), tree_(2 * nums.size()) {\n        for (size_t i = 0; i < n_; ++i) tree_[n_ + i] = nums[i];\n        for (size_t i = n_ - 1; i > 0; --i) tree_[i] = tree_[i << 1] + tree_[i << 1 | 1];\n    }\n\n    void update(size_t idx, int val) {\n        if (idx >= n_) throw std::out_of_range(\"index\");\n        size_t i = idx + n_;\n        tree_[i] = val;\n        while (i > 1) {\n            i >>= 1;\n            tree_[i] = tree_[i << 1] + tree_[i << 1 | 1];\n        }\n    }\n\n    int query(size_t l, size_t r) const {\n        if (l > r || r >= n_) throw std::out_of_range(\"range\");\n        l += n_; r += n_;\n        int res = 0;\n        while (l <= r) {\n            if (l & 1) res += tree_[l++];\n            if (!(r & 1)) res += tree_[r--];\n            l >>= 1; r >>= 1;\n        }\n        return res;\n    }\n\nprivate:\n    size_t n_;\n    std::vector<int> tree_;\n};\n```\n**Explanation:** Iterative segment tree for range sums with point updates. Leaves start at offset n; parents store child sums. Updates refresh ancestors; queries walk two pointers inward to accumulate sums.\n**Complexity:** Time: O(log n) per update/query; Space: O(n).\n**Example:**\nInput: nums=[1,3,5], query(0,2)\nOutput: 9\n**Notes:**\n- Adjust merge function for min/max as needed.\n- Include bounds checks (provided) to avoid invalid access.\n- Use larger integer types if sums may overflow int.", "category": "data_structure", "language": "c++"}
{"prompt": "Implement a queue in JavaScript with O(1) get-min or get-max support", "response": "javascript\n```javascript\n// Monotonic queue supporting O(1) retrieval of min\nclass MinQueue {\n  constructor() {\n    this.q = [];\n    this.mono = [];\n  }\n  enqueue(x) {\n    this.q.push(x);\n    while (this.mono.length && this.mono[this.mono.length - 1] > x) {\n      this.mono.pop();\n    }\n    this.mono.push(x);\n  }\n  dequeue() {\n    if (!this.q.length) return undefined;\n    const val = this.q.shift();\n    if (val === this.mono[0]) this.mono.shift();\n    return val;\n  }\n  getMin() {\n    return this.mono.length ? this.mono[0] : undefined;\n  }\n}\n```\n**Explanation:** Maintains the main queue and a secondary deque (`mono`) that stores candidates in nondecreasing order. Enqueue removes larger tail elements; dequeue pops from `mono` if it matches the removed head, keeping `getMin` O(1).\n**Complexity:** Time: Amortized O(1) per op; Space: O(n).\n**Example:**\nInput: enqueue 3,1,2; getMin()->1; dequeue()->3; getMin()->1\nOutput: min values as shown\n**Notes:**\n- For max support, invert comparisons.\n- Uses shift for simplicity; replace with head index for stricter O(1).\n- Not thread-safe; coordinate access if shared.", "category": "data_structure", "language": "javascript"}
{"prompt": "Implement a graph in Java with iterators with lazy traversal", "response": "java\n```java\nimport java.util.*;\n\npublic class Graph {\n    private final Map<Integer, Set<Integer>> adj = new HashMap<>();\n\n    public void addEdge(int u, int v, boolean bidirectional) {\n        adj.computeIfAbsent(u, k -> new LinkedHashSet<>()).add(v);\n        if (bidirectional) adj.computeIfAbsent(v, k -> new LinkedHashSet<>()).add(u);\n    }\n\n    public Iterable<Integer> neighbors(int u) {\n        return adj.getOrDefault(u, Collections.emptySet());\n    }\n\n    public Iterable<Integer> vertices() {\n        return adj.keySet();\n    }\n}\n```\n**Explanation:** Adjacency-list graph with iterable neighbors/vertices. Uses LinkedHashSet to provide deterministic traversal order and lazy iteration via the collections views.\n**Complexity:** Time: O(1) average for edge insert; Space: O(V + E).\n**Example:**\nInput: addEdge(1,2,true); neighbors(1)\nOutput: [2]\n**Notes:**\n- Extend with weights by storing neighbor-weight pairs.\n- Add removal methods as needed.\n- Not thread-safe; synchronize if used concurrently.", "category": "data_structure", "language": "java"}
{"prompt": "Implement a stack in Java with efficient lookup and insertion", "response": "java\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class FastStack<T> {\n    private final List<T> data = new ArrayList<>();\n\n    public void push(T val) {\n        data.add(val);\n    }\n\n    public T pop() {\n        if (data.isEmpty()) throw new IllegalStateException(\"empty stack\");\n        return data.remove(data.size() - 1);\n    }\n\n    public T peek() {\n        if (data.isEmpty()) throw new IllegalStateException(\"empty stack\");\n        return data.get(data.size() - 1);\n    }\n\n    public boolean contains(T val) {\n        return data.contains(val);\n    }\n}\n```\n**Explanation:** ArrayList-backed stack with O(1) push/pop/peek and O(n) lookup via `contains`, giving basic stack operations with optional membership check.\n**Complexity:** Time: O(1) push/pop/peek, O(n) contains; Space: O(n).\n**Example:**\nInput: push 1, push 2, peek -> 2, pop -> 2\nOutput: stack now [1]\n**Notes:**\n- Add capacity hints for large workloads to reduce reallocations.\n- Throws on empty peek/pop; adjust to return null if preferred.\n- Not synchronized; wrap if accessed by multiple threads.", "category": "data_structure", "language": "java"}
{"prompt": "Design and implement a priority queue in Python supporting range queries and point updates", "response": "python\n```python\nclass SegmentTree:\n    \"\"\"Segment tree supporting range sum queries and point updates.\"\"\"\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.tree = [0] * (2 * self.n)\n        self.tree[self.n:] = nums[:]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1]\n\n    def update(self, idx, val):\n        i = idx + self.n\n        self.tree[i] = val\n        i //= 2\n        while i:\n            self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1]\n            i //= 2\n\n    def query(self, l, r):\n        l += self.n; r += self.n\n        res = 0\n        while l <= r:\n            if l & 1:\n                res += self.tree[l]; l += 1\n            if not (r & 1):\n                res += self.tree[r]; r -= 1\n            l //= 2; r //= 2\n        return res\n```\n**Explanation:** Stores data in a flat array: leaves start at index n, parents combine children. Point updates refresh ancestors; range queries walk two pointers inward to accumulate sums.\n**Complexity:** Time: O(log n) for update/query; Space: O(n).\n**Example:**\nInput: nums=[1,3,5], query(0,2)\nOutput: 9\n**Notes:**\n- Replace sum with min/max by changing the merge operation.\n- Indices are zero-based and inclusive for queries.\n- Add bounds checks in production code.", "category": "data_structure", "language": "python"}
{"prompt": "Design and implement a segment tree in Java supporting range queries and point updates", "response": "java\n```java\npublic class SegmentTree {\n    private final int n;\n    private final int[] tree;\n\n    public SegmentTree(int[] nums) {\n        this.n = nums.length;\n        this.tree = new int[2 * n];\n        System.arraycopy(nums, 0, tree, n, n);\n        for (int i = n - 1; i > 0; i--) {\n            tree[i] = tree[2 * i] + tree[2 * i + 1];\n        }\n    }\n\n    public void update(int idx, int val) {\n        int i = idx + n;\n        tree[i] = val;\n        for (i >>= 1; i > 0; i >>= 1) {\n            tree[i] = tree[2 * i] + tree[2 * i + 1];\n        }\n    }\n\n    public int query(int l, int r) {\n        l += n; r += n;\n        int res = 0;\n        while (l <= r) {\n            if ((l & 1) == 1) res += tree[l++];\n            if ((r & 1) == 0) res += tree[r--];\n            l >>= 1; r >>= 1;\n        }\n        return res;\n    }\n}\n```\n**Explanation:** Builds an iterative segment tree for range sums. Leaves are at offset n; internal nodes store child sums. Point updates refresh ancestors; range queries walk two pointers inward to accumulate sums.\n**Complexity:** Time: O(log n) per update/query; Space: O(n).\n**Example:**\nInput: nums=[1,3,5], query(0,2)\nOutput: 9\n**Notes:**\n- Adapt merge operation for min/max or other associative functions.\n- Ensure indices are validated in production code.\n- Thread-safety not included; add synchronization if needed.", "category": "data_structure", "language": "java"}
{"prompt": "Design and implement a disjoint set (union-find) in Python supporting thread-safe operations", "response": "python\n```python\nimport threading\n\nclass ThreadSafeUnionFind:\n    def __init__(self, n: int):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.lock = threading.Lock()\n\n    def find(self, x: int) -> int:\n        with self.lock:\n            if self.parent[x] != x:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n    def union(self, a: int, b: int) -> None:\n        with self.lock:\n            ra, rb = self.find(a), self.find(b)\n            if ra == rb:\n                return\n            if self.rank[ra] < self.rank[rb]:\n                ra, rb = rb, ra\n            self.parent[rb] = ra\n            if self.rank[ra] == self.rank[rb]:\n                self.rank[ra] += 1\n```\n**Explanation:** Disjoint set union with path compression and union by rank, guarded by a lock for thread safety. `find` flattens paths; `union` attaches the shallower tree under the deeper one.\n**Complexity:** Time: Amortized ~O(α(n)) per op; Space: O(n).\n**Example:**\nInput: union(0,1); union(1,2); find(2)\nOutput: representative of merged set\n**Notes:**\n- Recursion under lock could re-enter; for large n, use iterative find to avoid deep recursion.\n- Coarse-grained lock keeps it simple; fine-grained locking can improve concurrency.\n- No resizing; initialize with known capacity.", "category": "data_structure", "language": "python"}
{"prompt": "Implement a graph in JavaScript with O(1) get-min or get-max support", "response": "javascript\n```javascript\nclass Graph {\n  constructor() {\n    this.adj = new Map();\n    this.minEdge = null;\n    this.maxEdge = null;\n  }\n  addEdge(u, v, weight = 0, bidirectional = false) {\n    if (!this.adj.has(u)) this.adj.set(u, []);\n    this.adj.get(u).push({ v, weight });\n    if (bidirectional) {\n      if (!this.adj.has(v)) this.adj.set(v, []);\n      this.adj.get(v).push({ v: u, weight });\n    }\n    if (this.minEdge === null || weight < this.minEdge.weight) this.minEdge = { u, v, weight };\n    if (this.maxEdge === null || weight > this.maxEdge.weight) this.maxEdge = { u, v, weight };\n  }\n  neighbors(u) {\n    return this.adj.get(u) || [];\n  }\n  getMinEdge() { return this.minEdge; }\n  getMaxEdge() { return this.maxEdge; }\n}\n```\n**Explanation:** Adjacency-list graph with O(1) access to current min/max edge weights by tracking them on insertion. Supports optional bidirectional edges and neighbor retrieval.\n**Complexity:** Time: O(1) average for insert/lookup; Space: O(V + E).\n**Example:**\nInput: addEdge('A','B',5); addEdge('B','C',2)\nOutput: getMinEdge() -> {u:'B', v:'C', weight:2}\n**Notes:**\n- For deletions, recompute min/max or maintain heaps.\n- Unweighted graphs can ignore weight/min/max fields.\n- Ensure vertices exist before querying neighbors to avoid undefined.", "category": "data_structure", "language": "javascript"}
{"prompt": "Design and implement a disjoint set (union-find) in Java supporting range queries and point updates", "response": "java\n```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class RangeUnionFind {\n    private final int[] parent;\n    private final int[] rank;\n\n    public RangeUnionFind(int n) {\n        parent = new int[n];\n        rank = new int[n];\n        for (int i = 0; i < n; i++) parent[i] = i;\n    }\n\n    public int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n\n    public void union(int a, int b) {\n        int ra = find(a), rb = find(b);\n        if (ra == rb) return;\n        if (rank[ra] < rank[rb]) { int t = ra; ra = rb; rb = t; }\n        parent[rb] = ra;\n        if (rank[ra] == rank[rb]) rank[ra]++;\n    }\n\n    public boolean sameRange(int a, int b) {\n        return find(a) == find(b);\n    }\n}\n```\n**Explanation:** Standard union-find with path compression and union by rank to support connectivity queries (\"range queries\" here interpreted as connectivity). `sameRange` checks if two indices are in the same set.\n**Complexity:** Time: Amortized ~O(α(n)) per op; Space: O(n).\n**Example:**\nInput: union(0,1); union(2,3); sameRange(1,2)\nOutput: false\n**Notes:**\n- If true range-sum/segment operations are needed, use a segment tree instead; this structure handles connectivity.\n- Not thread-safe; add synchronization if used concurrently.\n- Capacity fixed at construction.", "category": "data_structure", "language": "java"}
{"prompt": "Implement a trie in C++ with efficient lookup and insertion", "response": "c++\n```cpp\n#include <map>\n#include <string>\n\nclass Trie {\n    struct Node {\n        std::map<char, Node*> children;\n        bool end = false;\n    };\n    Node* root;\npublic:\n    Trie() : root(new Node()) {}\n    void insert(const std::string& word) {\n        Node* cur = root;\n        for (char ch : word) {\n            if (!cur->children.count(ch)) cur->children[ch] = new Node();\n            cur = cur->children[ch];\n        }\n        cur->end = true;\n    }\n    bool search(const std::string& word) const {\n        const Node* cur = root;\n        for (char ch : word) {\n            auto it = cur->children.find(ch);\n            if (it == cur->children.end()) return false;\n            cur = it->second;\n        }\n        return cur->end;\n    }\n};\n```\n**Explanation:** Trie with ordered children via `std::map`, supporting insertion and exact-word search. Nodes are dynamically allocated and marked when a word ends.\n**Complexity:** Time: O(L) per insert/search; Space: O(total characters stored).\n**Example:**\nInput: insert(\"cat\"); search(\"cat\")\nOutput: true\n**Notes:**\n- Add destructor to free nodes in production.\n- Replace `std::map` with `std::unordered_map` or array for performance.\n- Add prefix search, delete, or min/max retrieval as needed.", "category": "data_structure", "language": "c++"}
{"prompt": "Design and implement a circular buffer in Rust supporting union and find with path compression", "response": "rust\n```rust\npub struct CircularBuffer<T> {\n    data: Vec<Option<T>>,\n    head: usize,\n    size: usize,\n}\n\nimpl<T> CircularBuffer<T> {\n    pub fn new(capacity: usize) -> Self {\n        Self { data: vec![None; capacity], head: 0, size: 0 }\n    }\n\n    pub fn push(&mut self, value: T) {\n        let idx = (self.head + self.size) % self.data.len();\n        self.data[idx] = Some(value);\n        if self.size == self.data.len() {\n            self.head = (self.head + 1) % self.data.len(); // overwrite oldest\n        } else {\n            self.size += 1;\n        }\n    }\n\n    pub fn pop(&mut self) -> Option<T> {\n        if self.size == 0 { return None; }\n        let idx = self.head;\n        self.head = (self.head + 1) % self.data.len();\n        self.size -= 1;\n        self.data[idx].take()\n    }\n}\n```\n**Explanation:** Fixed-size ring buffer using a Vec of Options. `push` overwrites the oldest when full (advancing head); `pop` removes the oldest element. Head/size track logical order with wrap-around indexing.\n**Complexity:** Time: O(1) per op; Space: O(capacity).\n**Example:**\nInput: capacity=2; push 1; push 2; push 3 (evicts 1); pop() -> 2\nOutput: 2\n**Notes:**\n- If overwriting is undesirable, return an error when full instead of advancing head.\n- Add peek/len as needed for convenience.\n- Not thread-safe; wrap in Mutex for concurrent access.", "category": "data_structure", "language": "rust"}
{"prompt": "Implement a graph in Go with efficient lookup and insertion", "response": "go\n```go\npackage main\n\n// Graph with adjacency lists\ntype Graph struct {\n\tadj map[int][]int\n}\n\nfunc NewGraph() *Graph {\n\treturn &Graph{adj: make(map[int][]int)}\n}\n\nfunc (g *Graph) AddEdge(u, v int, bidirectional bool) {\n\tg.adj[u] = append(g.adj[u], v)\n\tif bidirectional {\n\t\tg.adj[v] = append(g.adj[v], u)\n\t}\n}\n\nfunc (g *Graph) Neighbors(u int) []int {\n\treturn g.adj[u]\n}\n```\n**Explanation:** Uses a map of slices for adjacency to support efficient edge insertions and neighbor lookups; optional bidirectional insertion for undirected graphs.\n**Complexity:** Time: O(1) average for add/lookup; Space: O(V+E).\n**Example:**\nInput: AddEdge(1,2,true); Neighbors(1)\nOutput: [2]\n**Notes:**\n- Deduplicate edges if needed; current code allows duplicates.\n- For weighted graphs, store structs with weights.\n- Add bounds/exists checks if accessing arbitrary keys.", "category": "data_structure", "language": "go"}
{"prompt": "Implement a binary search tree in Python with all basic operations", "response": "python\n```python\nclass BSTNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass BST:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, val):\n        self.root = self._insert(self.root, val)\n\n    def _insert(self, node, val):\n        if node is None:\n            return BSTNode(val)\n        if val < node.val:\n            node.left = self._insert(node.left, val)\n        elif val > node.val:\n            node.right = self._insert(node.right, val)\n        return node\n\n    def search(self, val):\n        node = self.root\n        while node:\n            if node.val == val:\n                return True\n            node = node.left if val < node.val else node.right\n        return False\n\n    def delete(self, val):\n        self.root = self._delete(self.root, val)\n\n    def _delete(self, node, val):\n        if not node:\n            return None\n        if val < node.val:\n            node.left = self._delete(node.left, val)\n        elif val > node.val:\n            node.right = self._delete(node.right, val)\n        else:\n            if not node.left:\n                return node.right\n            if not node.right:\n                return node.left\n            succ = node.right\n            while succ.left:\n                succ = succ.left\n            node.val = succ.val\n            node.right = self._delete(node.right, succ.val)\n        return node\n```\n**Explanation:** Basic BST with insert, search, and delete. Deletion handles 0/1-child cases directly and uses the in-order successor when two children exist.\n**Complexity:** Time: O(h) per op where h is height; Space: O(h) recursion.\n**Example:**\nInput: insert 5,3,7; search 3\nOutput: True\n**Notes:**\n- Unbalanced trees degrade to O(n); use a balanced tree for guarantees.\n- Does not store duplicates; change policy as needed.\n- Add traversal methods or balancing if required for your use case.", "category": "data_structure", "language": "python"}
{"prompt": "Design and implement a priority queue in Rust supporting bounded capacity with wrap-around semantics", "response": "rust\n```rust\nuse std::cmp::Reverse;\nuse std::collections::BinaryHeap;\n\npub struct BoundedMinPQ {\n    cap: usize,\n    heap: BinaryHeap<Reverse<i32>>, // stores smallest at top via Reverse\n}\n\nimpl BoundedMinPQ {\n    pub fn new(capacity: usize) -> Self {\n        Self { cap: capacity, heap: BinaryHeap::new() }\n    }\n\n    pub fn push(&mut self, val: i32) {\n        if self.heap.len() < self.cap {\n            self.heap.push(Reverse(val));\n        } else if let Some(&Reverse(min)) = self.heap.peek() {\n            if val > min {\n                self.heap.pop();\n                self.heap.push(Reverse(val));\n            }\n        }\n    }\n\n    pub fn pop(&mut self) -> Option<i32> {\n        self.heap.pop().map(|r| r.0)\n    }\n\n    pub fn peek(&self) -> Option<i32> {\n        self.heap.peek().map(|r| r.0)\n    }\n}\n```\n**Explanation:** Capacity-limited min-priority queue keeping the top-K largest values: insert until full, then replace the smallest only if the new value is larger. Uses `Reverse` to implement a min-heap atop `BinaryHeap`.\n**Complexity:** Time: O(log k) per push/pop; Space: O(k).\n**Example:**\nInput: cap=2; push 1,5,3\nOutput: heap contains {3,5}; peek -> 3\n**Notes:**\n- For different eviction policy, adjust the push logic.\n- Replace `i32` with a generic type and comparator as needed.\n- Not thread-safe; wrap in Mutex for shared use.", "category": "data_structure", "language": "rust"}
{"prompt": "Design and implement a priority queue in Rust supporting range queries and point updates", "response": "rust\n```rust\npub struct SegmentTree {\n    n: usize,\n    tree: Vec<i64>,\n}\n\nimpl SegmentTree {\n    pub fn new(nums: &[i64]) -> Self {\n        let n = nums.len();\n        let mut tree = vec![0; 2 * n];\n        tree[n..n + n].copy_from_slice(nums);\n        for i in (1..n).rev() {\n            tree[i] = tree[i << 1] + tree[i << 1 | 1];\n        }\n        Self { n, tree }\n    }\n\n    pub fn update(&mut self, idx: usize, val: i64) {\n        let mut i = idx + self.n;\n        self.tree[i] = val;\n        i >>= 1;\n        while i > 0 {\n            self.tree[i] = self.tree[i << 1] + self.tree[i << 1 | 1];\n            i >>= 1;\n        }\n    }\n\n    pub fn query(&self, l: usize, r: usize) -> i64 {\n        let (mut l, mut r) = (l + self.n, r + self.n);\n        let mut res = 0;\n        while l <= r {\n            if l & 1 == 1 { res += self.tree[l]; l += 1; }\n            if r & 1 == 0 { res += self.tree[r]; r -= 1; }\n            l >>= 1; r >>= 1;\n        }\n        res\n    }\n}\n```\n**Explanation:** Iterative segment tree for range sums with point updates. Leaves at offset n; parents store child sums. Updates bubble changes up; queries walk two pointers inward to accumulate results.\n**Complexity:** Time: O(log n) per update/query; Space: O(n).\n**Example:**\nInput: nums=[1,3,5], query(0,2)\nOutput: 9\n**Notes:**\n- Change merge op for min/max as needed.\n- Indices are zero-based and inclusive for queries.\n- Ensure bounds checking in production code.", "category": "data_structure", "language": "rust"}
{"prompt": "Implement a hash table in Python with efficient lookup and insertion", "response": "python\n```python\nclass HashTable:\n    def __init__(self, capacity: int = 16):\n        self.buckets = [[] for _ in range(capacity)]\n\n    def _idx(self, key) -> int:\n        return hash(key) % len(self.buckets)\n\n    def put(self, key, value) -> None:\n        bucket = self.buckets[self._idx(key)]\n        for i, (k, _) in enumerate(bucket):\n            if k == key:\n                bucket[i] = (k, value)\n                return\n        bucket.append((key, value))\n\n    def get(self, key):\n        bucket = self.buckets[self._idx(key)]\n        for k, v in bucket:\n            if k == key:\n                return v\n        return None\n```\n**Explanation:** Separate-chaining hash table using a list of buckets. Put updates existing keys or appends new pairs; get scans the bucket for a matching key.\n**Complexity:** Time: O(1) average per op; Space: O(n).\n**Example:**\nInput: put('a',1); get('a')\nOutput: 1\n**Notes:**\n- Resize when load factor grows to maintain performance.\n- Return None on miss; adjust to raise if preferred.\n- Keys must be hashable; behavior on collisions is handled by chaining.", "category": "data_structure", "language": "python"}
{"prompt": "Implement a stack in Python with O(1) get-min or get-max support", "response": "python\n```python\nclass MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, x: int) -> None:\n        self.stack.append(x)\n        if not self.min_stack or x <= self.min_stack[-1]:\n            self.min_stack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack:\n            raise IndexError(\"pop from empty stack\")\n        val = self.stack.pop()\n        if val == self.min_stack[-1]:\n            self.min_stack.pop()\n        return val\n\n    def top(self) -> int:\n        return self.stack[-1]\n\n    def get_min(self) -> int:\n        return self.min_stack[-1]\n```\n**Explanation:** Maintains a primary stack and an auxiliary min_stack to track the current minimum. On push, also push to min_stack when the new value is <= current min; on pop, pop from min_stack when the popped value equals the min.\n**Complexity:** Time: O(1) per operation; Space: O(n).\n**Example:**\nInput: push 3, push 1, get_min()->1, pop()->1, get_min()->3\nOutput: mins as shown\n**Notes:**\n- Add emptiness checks before top/get_min if needed.\n- For max support, maintain a max_stack similarly.\n- Works for duplicate minima by using <= on push and equality on pop.", "category": "data_structure", "language": "python"}
{"prompt": "Implement a heap in JavaScript with iterators with lazy traversal", "response": "javascript\n```javascript\nclass Heap {\n  constructor(compare = (a, b) => a - b) {\n    this.data = [];\n    this.compare = compare;\n  }\n  push(x) { this.data.push(x); this._up(this.data.length - 1); }\n  pop() {\n    if (!this.data.length) return undefined;\n    const root = this.data[0];\n    const last = this.data.pop();\n    if (this.data.length && last !== undefined) { this.data[0] = last; this._down(0); }\n    return root;\n  }\n  peek() { return this.data[0]; }\n  _up(i) {\n    while (i > 0) {\n      const p = (i - 1) >> 1;\n      if (this.compare(this.data[p], this.data[i]) <= 0) break;\n      [this.data[p], this.data[i]] = [this.data[i], this.data[p]];\n      i = p;\n    }\n  }\n  _down(i) {\n    const n = this.data.length;\n    while (true) {\n      let s = i;\n      const l = 2 * i + 1, r = 2 * i + 2;\n      if (l < n && this.compare(this.data[l], this.data[s]) < 0) s = l;\n      if (r < n && this.compare(this.data[r], this.data[s]) < 0) s = r;\n      if (s === i) break;\n      [this.data[i], this.data[s]] = [this.data[s], this.data[i]];\n      i = s;\n    }\n  }\n  *[Symbol.iterator]() {\n    for (const x of this.data) yield x;\n  }\n}\n```\n**Explanation:** Generic binary heap with customizable comparator. Supports push/pop/peek and iteration over internal array (not sorted order). Default comparator yields a min-heap.\n**Complexity:** Time: O(log n) push/pop; O(1) peek; Space: O(n).\n**Example:**\nInput: push 3,1,2; pop() -> 1\nOutput: min-heap behavior with default comparator\n**Notes:**\n- Iteration yields heap array order, not sorted; copy and sort if you need sorted iteration.\n- For max-heap, pass `(a,b) => b - a`.\n- No capacity limit; add if desired.", "category": "data_structure", "language": "javascript"}
{"prompt": "Design and implement a priority queue in Java supporting union and find with path compression", "response": "java\n```java\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\n\npublic class PriorityQueueWithUnion {\n    private final PriorityQueue<Integer> pq;\n\n    public PriorityQueueWithUnion() {\n        pq = new PriorityQueue<>(Comparator.naturalOrder());\n    }\n\n    public void insert(int val) { pq.add(val); }\n    public Integer deleteRoot() { return pq.poll(); }\n    public Integer peek() { return pq.peek(); }\n\n    // Union: merge another PQ's elements into this one\n    public void union(PriorityQueueWithUnion other) {\n        while (!other.pq.isEmpty()) {\n            this.pq.add(other.pq.poll());\n        }\n    }\n}\n```\n**Explanation:** Wraps Java's `PriorityQueue` to provide insert, deleteRoot, and peek, plus a `union` method that merges another queue's contents. Uses natural ordering for a min-heap.\n**Complexity:** Time: O(log n) insert/delete; union O(m log(n+m)); Space: O(n+m).\n**Example:**\nInput: insert 3,1; peek()->1\nOutput: min-heap behavior\n**Notes:**\n- Union drains the other queue; adjust if you want to preserve it.\n- For thread safety, synchronize methods.\n- Change comparator for max-heap or custom ordering.", "category": "data_structure", "language": "java"}
{"prompt": "Design and implement a disjoint set (union-find) in Java supporting O(1) eviction and retrieval", "response": "java\n```java\npublic class UnionFindLRU {\n    private final int[] parent;\n    private final int[] rank;\n\n    public UnionFindLRU(int n) {\n        parent = new int[n];\n        rank = new int[n];\n        for (int i = 0; i < n; i++) parent[i] = i;\n    }\n\n    public int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n\n    public void union(int a, int b) {\n        int ra = find(a), rb = find(b);\n        if (ra == rb) return;\n        if (rank[ra] < rank[rb]) { int t = ra; ra = rb; rb = t; }\n        parent[rb] = ra;\n        if (rank[ra] == rank[rb]) rank[ra]++;\n    }\n}\n```\n**Explanation:** Union-find with path compression and union by rank for near-constant-time connectivity operations. LRU mention is not relevant; this provides disjoint-set functionality.\n**Complexity:** Time: Amortized ~O(α(n)); Space: O(n).\n**Example:**\nInput: union(0,1); union(2,3); find(3)\nOutput: representative of set containing 3\n**Notes:**\n- Add `connected(a,b)` helper for clarity.\n- No resizing; construct with known capacity.\n- Not thread-safe; synchronize if shared across threads.", "category": "data_structure", "language": "java"}
{"prompt": "Explain the time and space complexity of topological sort", "response": "plaintext\n```text\nTopological sort produces an ordering of directed acyclic graph nodes where every edge (u -> v) places u before v.\n```\n**Explanation:** Kahn’s algorithm repeatedly removes zero-indegree nodes, while DFS-based approaches post-order nodes; both detect cycles when all nodes cannot be ordered. A cycle means no valid topological order.\n**Complexity:** Time: O(V + E); Space: O(V + E) for adjacency, indegrees/stack.\n**Example:**\nInput: edges = [(0,1),(1,2)]\nOutput: [0,1,2]\n**Notes:**\n- Presence of a cycle leaves nodes with nonzero indegree (Kahn) or revisits on DFS; report error.\n- Multiple valid orders may exist depending on edge structure.\n- Useful for scheduling tasks with dependencies or resolving build orders.", "category": "explanation", "language": "unknown"}
{"prompt": "Explain what this Python code does and how it works:\n[x for x in range(100) if x % 3 == 0 and x % 5 == 0]", "response": "python\n```python\n[x for x in range(100) if x % 3 == 0 and x % 5 == 0]\n```\n**Explanation:** List comprehension iterates numbers 0–99 and keeps those divisible by both 3 and 5 (i.e., multiples of 15), producing a list of such numbers.\n**Complexity:** Time: O(n) over the range; Space: O(k) for the resulting list.\n**Example:**\nInput: range(0, 31)\nOutput: [0, 15, 30]\n**Notes:**\n- Replace `range(100)` with any iterable to change scope.\n- Using `% 15 == 0` yields the same result and can be marginally faster.\n- For generator behavior, wrap with parentheses instead of brackets to produce values lazily.", "category": "explanation", "language": "python"}
{"prompt": "Explain the time and space complexity of quicksort", "response": "plaintext\n```text\nQuicksort partitions the array around a pivot so smaller elements move left and larger move right, then recursively sorts the subarrays.\n```\n**Explanation:** Each partition step reorders elements in-place, typically choosing a pivot and sweeping once with swaps. Average performance relies on balanced partitions; poor pivots can degrade to quadratic time.\n**Complexity:** Time: O(n log n) average, O(n²) worst case; Space: O(log n) for recursion stack (in-place partitioning).\n**Example:**\nInput: [3, 1, 4, 1]\nOutput: [1, 1, 3, 4]\n**Notes:**\n- Randomize or median-of-three pivot selection to avoid worst cases.\n- Tail-call optimize or switch to insertion sort on tiny partitions for speed.\n- Quicksort is unstable in its classic in-place form; use variants if stability is required.", "category": "explanation", "language": "unknown"}
{"prompt": "Explain the time and space complexity of merge sort", "response": "plaintext\n```text\nMerge sort divides the array in half recursively, then merges the sorted halves into a single sorted array.\n```\n**Explanation:** Splitting continues until subarrays of size 1, which are inherently sorted. The merge step walks two sorted lists, repeatedly taking the smaller front element to build a sorted result. This guarantees stable, predictable performance regardless of input order.\n**Complexity:** Time: O(n log n); Space: O(n) for merge buffers (plus O(log n) recursion stack).\n**Example:**\nInput: [5, 2, 4, 6, 1, 3]\nOutput: [1, 2, 3, 4, 5, 6]\n**Notes:**\n- Merge sort is stable; equal elements preserve order.\n- For limited memory, use iterative bottom-up merges or in-place variants at higher complexity.\n- Switch to insertion sort for tiny subarrays to improve constants.", "category": "explanation", "language": "unknown"}
{"prompt": "Explain what this Java code does and how it works:\nreduce((acc, x) => acc + x, [1, 2, 3, 4], 0)", "response": "java\n```java\nreduce((acc, x) => acc + x, [1, 2, 3, 4], 0)\n```\n**Explanation:** This pseudocode folds the array [1,2,3,4] with an addition callback starting from accumulator 0, producing the sum 10. In Java streams, the equivalent is `Stream.of(1,2,3,4).reduce(0, Integer::sum)`.\n**Complexity:** Time: O(n); Space: O(1) auxiliary.\n**Example:**\nInput: [1,2,3,4]\nOutput: 10\n**Notes:**\n- Always supply an identity value (0 here) to define behavior on empty collections.\n- Replace the lambda to compute other reductions (product, min, concatenation).\n- In parallel streams, ensure the accumulator and combiner are associative.", "category": "explanation", "language": "javascript"}
{"prompt": "Explain the time and space complexity of binary search", "response": "plaintext\n```text\nBinary search halves the search interval each iteration when locating a target in a sorted collection.\n```\n**Explanation:** Repeatedly compare the middle element to the target; discard the lower or upper half accordingly. Stop when found or interval is empty. Requires sorted data for correctness.\n**Complexity:** Time: O(log n); Space: O(1) for iterative form (O(log n) if recursive due to call stack).\n**Example:**\nInput: nums=[1,3,5,7], target=5\nOutput: index 2\n**Notes:**\n- For duplicates, adjust bounds to find first/last occurrence.\n- Avoid overflow by computing mid as `lo + (hi - lo)/2` in languages with fixed-size ints.\n- If data is unsorted, sort first (O(n log n)) or use hash-based lookup instead.", "category": "explanation", "language": "unknown"}
{"prompt": "Explain what this Python code does and how it works:\nreduce((acc, x) => acc + x, [1, 2, 3, 4], 0)", "response": "python\n```python\nfrom functools import reduce\nresult = reduce((lambda acc, x: acc + x), [1, 2, 3, 4], 0)\n```\n**Explanation:** `reduce` starts with accumulator `0` and applies `acc + x` for each list element, producing a running sum: (((0+1)+2)+3)+4 = 10. The final value is assigned to `result`.\n**Complexity:** Time: O(n); Space: O(1) auxiliary.\n**Example:**\nInput: [1, 2, 3, 4]\nOutput: 10\n**Notes:**\n- Without an initial value, the first list element would become the initial accumulator.\n- For summing numbers, `sum([1,2,3,4])` is clearer, but `reduce` generalizes to other fold operations.\n- On empty lists, always provide an initial value to avoid `TypeError`.", "category": "explanation", "language": "javascript"}
{"prompt": "Explain what this Python code does and how it works:\nlist(map(lambda x: x**2, filter(lambda x: x % 2 == 0, range(10))))", "response": "python\n```python\nlist(map(lambda x: x**2, filter(lambda x: x % 2 == 0, range(10))))\n```\n**Explanation:** Filters numbers 0 through 9 to keep even values, then maps each to its square, finally materializing the results in a list. The result is the squares of even numbers in the range.\n**Complexity:** Time: O(n) over the range; Space: O(n) for the output list.\n**Example:**\nInput: range(10)\nOutput: [0, 4, 16, 36, 64]\n**Notes:**\n- Equivalent list comprehension: `[x*x for x in range(10) if x % 2 == 0]`.\n- For lazy evaluation, keep as a map/filter pipeline without wrapping in list.\n- Replace the lambda bodies to perform different filtering/mapping tasks.", "category": "explanation", "language": "python"}
{"prompt": "Explain the time and space complexity of Dijkstra's algorithm", "response": "plaintext\n```text\nDijkstra's algorithm relaxes edges in order of current shortest distance using a priority queue, expanding outward from the source.\n```\n**Explanation:** Initialize all distances to infinity except the source (0). Pop the closest node from the min-heap, skip if stale, relax its outgoing edges, and push improved distances back onto the heap. Distances never increase, so the first time a node is finalized its shortest path is known.\n**Complexity:** Time: O((V + E) log V) with a binary heap; Space: O(V) for distance and heap entries.\n**Example:**\nInput: graph with edges A-B:2, B-C:1, A-C:5; source A\nOutput: dist(A)=0, dist(B)=2, dist(C)=3\n**Notes:**\n- Requires non-negative edge weights; fails on negative edges.\n- Use a Fibonacci heap for O(E + V log V) theoretically, though constants are higher.\n- Track predecessors to reconstruct shortest paths, not just distances.", "category": "explanation", "language": "unknown"}
{"prompt": "Explain what this JavaScript code does and how it works:\nlist(map(lambda x: x**2, filter(lambda x: x % 2 == 0, range(10))))", "response": "javascript\n```javascript\nlist(map(lambda x: x**2, filter(lambda x: x % 2 == 0, range(10))))\n```\n**Explanation:** Filters numbers 0..9 to keep evens, then maps each to its square, collecting the results. In JavaScript the equivalent is `Array.from({length:10}, (_,i)=>i).filter(x => x % 2 === 0).map(x => x * x)`.\n**Complexity:** Time: O(n); Space: O(n) for the output list.\n**Example:**\nInput: 0..9\nOutput: [0, 4, 16, 36, 64]\n**Notes:**\n- Order of operations matters: filtering first avoids extra work.\n- Replace `range(10)` with your desired iterable length.\n- Use lazy generators if the dataset is large to avoid holding all results in memory.", "category": "explanation", "language": "javascript"}
{"prompt": "Explain the time and space complexity of DFS and BFS", "response": "plaintext\n```text\nDFS explores a branch as deep as possible before backtracking; BFS explores neighbors level by level using a queue.\n```\n**Explanation:** DFS uses a stack (explicit or recursion) to dive down paths, marking visited nodes to avoid cycles. BFS uses a queue to expand the frontier uniformly by distance from the start, visiting all nodes at depth d before depth d+1.\n**Complexity:** Time: O(V + E) for both; Space: O(V) for visited plus O(V) recursion stack (DFS) or queue (BFS).\n**Example:**\nInput: graph = {0:[1,2], 1:[3], 2:[3], 3:[]}, start = 0\nOutput: DFS order [0,1,3,2]; BFS order [0,1,2,3]\n**Notes:**\n- BFS yields shortest paths in unweighted graphs; DFS does not guarantee shortest distances.\n- Recursive DFS can overflow on very deep graphs; use an explicit stack if needed.\n- Both require visited tracking on cyclic graphs to terminate.", "category": "explanation", "language": "unknown"}
{"prompt": "Explain what this Java code does and how it works:\nlist(map(lambda x: x**2, filter(lambda x: x % 2 == 0, range(10))))", "response": "java\n```java\nlist(map(lambda x: x**2, filter(lambda x: x % 2 == 0, range(10))))\n```\n**Explanation:** This pseudocode filters the numbers 0..9 to keep even values, then maps each to its square, finally materializing the results in a list. In Java terms, it mirrors `IntStream.range(0,10).filter(x -> x % 2 == 0).map(x -> x * x).boxed().toList()`.\n**Complexity:** Time: O(n) over the input range; Space: O(n) for the resulting list.\n**Example:**\nInput: numbers 0..9\nOutput: [0, 4, 16, 36, 64]\n**Notes:**\n- Order matters: filtering first avoids unnecessary squaring.\n- Replace with streams or loops in real Java code; the given syntax is Pythonic.\n- For lazy evaluation, keep as a stream rather than collecting immediately.", "category": "explanation", "language": "java"}
{"prompt": "Explain what this Java code does and how it works:\n[x for x in range(100) if x % 3 == 0 and x % 5 == 0]", "response": "java\n```java\n[x for x in range(100) if x % 3 == 0 and x % 5 == 0]\n```\n**Explanation:** This Python-style comprehension collects numbers from 0 to 99 divisible by both 3 and 5 (i.e., multiples of 15). In Java stream form: `IntStream.range(0,100).filter(x -> x % 15 == 0).boxed().toList();`.\n**Complexity:** Time: O(n); Space: O(k) for the resulting list.\n**Example:**\nInput: range 0..30\nOutput: [0, 15, 30]\n**Notes:**\n- Using `% 15` is equivalent and simpler.\n- Replace the range to change the search interval.\n- For lazy evaluation in Java, keep it as a stream instead of collecting.", "category": "explanation", "language": "python"}
{"prompt": "Explain what this JavaScript code does and how it works:\nreduce((acc, x) => acc + x, [1, 2, 3, 4], 0)", "response": "javascript\n```javascript\nreduce((acc, x) => acc + x, [1, 2, 3, 4], 0)\n```\n**Explanation:** Folds the array `[1,2,3,4]` with addition starting from 0, producing 10. `reduce` passes the accumulator and current element to the callback for each item.\n**Complexity:** Time: O(n); Space: O(1) auxiliary.\n**Example:**\nInput: [1,2,3,4]\nOutput: 10\n**Notes:**\n- Without the initial `0`, the first element becomes the starting accumulator.\n- Replace the callback to compute products, min/max, or other aggregates.\n- On empty arrays, an initial value is required to avoid a TypeError.", "category": "explanation", "language": "javascript"}
{"prompt": "Explain what this JavaScript code does and how it works:\n[x for x in range(100) if x % 3 == 0 and x % 5 == 0]", "response": "javascript\n```javascript\n[x for x in range(100) if x % 3 == 0 and x % 5 == 0]\n```\n**Explanation:** In Python-like syntax, this builds a list of numbers from 0 to 99 divisible by both 3 and 5 (multiples of 15). JavaScript equivalent: `Array.from({length:100}, (_,i)=>i).filter(x => x % 15 === 0)`.\n**Complexity:** Time: O(n); Space: O(k) for the resulting list.\n**Example:**\nInput: range 0..20\nOutput: [0, 15]\n**Notes:**\n- Replace `range(100)` with desired bounds.\n- Filtering by `% 15` is simpler than two modulo checks.\n- For lazy evaluation, use a generator in Python or a stream in JS.", "category": "explanation", "language": "python"}
{"prompt": "Explain the time and space complexity of two-pointer techniques", "response": "plaintext\n```text\nTwo-pointer techniques move one or two indices through a collection to exploit order or structure, often reducing nested loops to linear scans.\n```\n**Explanation:** By starting pointers at the same end (slow/fast) or opposite ends (lo/hi), you can shrink or expand a window, skip work, or detect conditions (e.g., sums, palindromes, cycle detection). Movement rules encode the problem logic, avoiding reprocessing elements.\n**Complexity:** Time: Typically O(n); Space: O(1) extra.\n**Example:**\nInput: nums = [-2, -1, 0, 3, 5], target = 4 (two-sum on sorted array)\nOutput: pointers at 1 and 4 yield -1 + 5 = 4\n**Notes:**\n- Works best on sorted or structured data; otherwise, sorting may be needed first.\n- Watch for infinite loops—ensure pointers move each iteration.\n- For sliding windows, maintain counts/invariants as pointers move.", "category": "explanation", "language": "unknown"}
{"prompt": "Implement a JavaScript function to transform given a stream of log lines", "response": "javascript\n```javascript\n/**\n * Transform a stream of log lines into structured objects.\n * Each line format: \"<timestamp> <level> <message>\".\n */\nfunction transformLogLines(lines) {\n  return lines\n    .filter(Boolean)\n    .map((line) => {\n      const [timestamp, level, ...msgParts] = line.trim().split(/\\s+/);\n      return {\n        timestamp,\n        level: level ? level.toUpperCase() : 'INFO',\n        message: msgParts.join(' '),\n      };\n    });\n}\n```\n**Explanation:** Cleans empty lines, splits each log line into timestamp, level, and message tokens, normalizes the level to upper-case, and returns structured objects for downstream processing.\n**Complexity:** Time: O(n * m) where n is line count and m average tokens; Space: O(n) for the output array.\n**Example:**\nInput: `[\"2024-01-01T00:00:00Z info started\", \"2024-01-01T00:01:00Z warn high load\"]`\nOutput: `[{timestamp: \"2024-01-01T00:00:00Z\", level: \"INFO\", message: \"started\"}, {timestamp: \"2024-01-01T00:01:00Z\", level: \"WARN\", message: \"high load\"}]`\n**Notes:**\n- Adjust parsing if timestamps contain spaces; use regex capture groups for richer formats.\n- Add validation to skip malformed lines or emit errors as needed.\n- Extend with JSON parsing when logs are structured JSON lines.", "category": "function_implementation", "language": "javascript"}
{"prompt": "Implement a C++ function to validate given a dictionary", "response": "c++\n```cpp\n#include <map>\n#include <string>\n#include <vector>\n\n// Validate that required keys exist and have non-empty values.\nbool validateDict(const std::map<std::string, std::string>& dict,\n                  const std::vector<std::string>& requiredKeys) {\n    for (const auto& key : requiredKeys) {\n        auto it = dict.find(key);\n        if (it == dict.end() || it->second.empty()) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n**Explanation:** Treats the dictionary as a `std::map` of string keys/values and checks that every required key is present and maps to a non-empty string. Returns `false` on any missing or empty required entry.\n**Complexity:** Time: O(k log n) where k is required keys and n map size; Space: O(1).\n**Example:**\nInput: dict = {\"name\":\"Ada\",\"role\":\"dev\"}, required = [\"name\",\"role\"]\nOutput: true\n**Notes:**\n- Extend validation to enforce patterns (e.g., regex) or type coercion.\n- Swap `std::map` for `std::unordered_map` if you prefer average O(1) lookups.\n- Optional keys can be omitted from `requiredKeys` and validated separately.", "category": "function_implementation", "language": "c++"}
{"prompt": "Implement a Go function to normalize given a string", "response": "go\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n\t\"strings\"\n)\n\n// Normalize trims, lowercases, and collapses internal whitespace.\nfunc Normalize(input string) string {\n\ts := strings.TrimSpace(input)\n\ts = strings.ToLower(s)\n\tspace := regexp.MustCompile(`\\s+`)\n\treturn space.ReplaceAllString(s, \" \")\n}\n\nfunc main() {\n\tfmt.Println(Normalize(\"  Hello\\tWorld  \")) // \"hello world\"\n}\n```\n**Explanation:** Trims leading/trailing whitespace, lowercases the string, and collapses consecutive whitespace to single spaces using a regex.\n**Complexity:** Time: O(n); Space: O(n) for the normalized copy.\n**Example:**\nInput: \"  Hello\\nWORLD  \"\nOutput: \"hello world\"\n**Notes:**\n- Adjust to remove punctuation or accents if needed.\n- For ASCII-only performance, replace regex with manual scanning.\n- If preserving case is desired, skip the `ToLower` step.", "category": "function_implementation", "language": "go"}
{"prompt": "Implement a JavaScript function to aggregate given a matrix", "response": "javascript\n```javascript\n/**\n * Aggregate a numeric matrix by summing each row and returning the grand total.\n */\nfunction aggregateMatrix(matrix) {\n  let total = 0;\n  for (const row of matrix) {\n    for (const val of row) {\n      const num = Number(val);\n      if (Number.isNaN(num)) throw new Error('Non-numeric value in matrix');\n      total += num;\n    }\n  }\n  return total;\n}\n```\n**Explanation:** Iterates through every row and element, coerces to numbers, and accumulates a running sum. Throws if any value is non-numeric to keep results predictable.\n**Complexity:** Time: O(r * c); Space: O(1) extra.\n**Example:**\nInput: [[1, 2], [3, 4]]\nOutput: 10\n**Notes:**\n- Adapt to return row/column sums by collecting into arrays instead of a single total.\n- For sparse matrices, iterate only non-zero entries to reduce work.\n- Validate rectangular shape if downstream code assumes consistent column counts.", "category": "function_implementation", "language": "javascript"}
{"prompt": "Create a JavaScript utility that generates paginated results from a collection with proper error handling", "response": "javascript\n```javascript\n/**\n * Paginate a collection with bounds checking and error handling.\n * Returns an object containing items for the requested page and metadata.\n */\nfunction paginate(items, page = 1, pageSize = 10) {\n  if (!Array.isArray(items)) throw new Error('items must be an array');\n  if (page <= 0 || pageSize <= 0) throw new Error('page and pageSize must be positive');\n\n  const total = items.length;\n  const totalPages = Math.max(1, Math.ceil(total / pageSize));\n  const currentPage = Math.min(page, totalPages);\n  const start = (currentPage - 1) * pageSize;\n  const end = Math.min(start + pageSize, total);\n  return {\n    items: items.slice(start, end),\n    page: currentPage,\n    pageSize,\n    total,\n    totalPages,\n  };\n}\n```\n**Explanation:** Validates inputs, computes total pages, clamps the requested page within range, slices the items for that page, and returns pagination metadata alongside the data slice.\n**Complexity:** Time: O(k) where k = pageSize for the slice; Space: O(k) for the returned items.\n**Example:**\nInput: items = [1,2,3,4,5], page = 2, pageSize = 2\nOutput: `{items:[3,4], page:2, pageSize:2, total:5, totalPages:3}`\n**Notes:**\n- Customize behavior when `page` exceeds `totalPages` (e.g., throw instead of clamp).\n- For huge lists, paginate at the data source rather than slicing in memory.\n- Add sorting/filtering before pagination as needed.", "category": "function_implementation", "language": "javascript"}
{"prompt": "Implement a Python function to summarize given a list of numbers", "response": "python\n```python\nfrom typing import Iterable, NamedTuple\n\nclass Summary(NamedTuple):\n    count: int\n    total: float\n    minimum: float\n    maximum: float\n    average: float\n\n\ndef summarize(numbers: Iterable[float]) -> Summary:\n    nums = list(numbers)\n    if not nums:\n        return Summary(0, 0.0, float('inf'), float('-inf'), 0.0)\n    total = sum(nums)\n    return Summary(\n        count=len(nums),\n        total=total,\n        minimum=min(nums),\n        maximum=max(nums),\n        average=total / len(nums),\n    )\n```\n**Explanation:** Materializes the iterable to reuse values for sum/min/max, then returns a `NamedTuple` containing count, total, min, max, and average. Handles an empty input by returning sentinel min/max and zero totals.\n**Complexity:** Time: O(n); Space: O(n) due to list materialization (reduce to O(1) by streaming once and tracking aggregates).\n**Example:**\nInput: [2, 4, 6]\nOutput: Summary(count=3, total=12, minimum=2, maximum=6, average=4.0)\n**Notes:**\n- For large streams, iterate once while tracking running min/max/total to avoid full materialization.\n- Adjust empty-case behavior (e.g., raise ValueError) if sentinels are undesirable.\n- Convert inputs to Decimal if you need exact decimal arithmetic.", "category": "function_implementation", "language": "python"}
{"prompt": "Create a Go utility that debounces an async function call with proper error handling", "response": "go\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// Debounce wraps fn so it runs only after wait elapses without a new call.\nfunc Debounce(wait time.Duration, fn func() error) func() error {\n\tvar mu sync.Mutex\n\tvar timer *time.Timer\n\treturn func() error {\n\t\tmu.Lock()\n\t\tdefer mu.Unlock()\n\t\tif timer != nil {\n\t\t\ttimer.Stop()\n\t\t}\n\t\tdone := make(chan error, 1)\n\t\ttimer = time.AfterFunc(wait, func() {\n\t\t\tdone <- fn()\n\t\t})\n\t\treturn <-done\n\t}\n}\n\nfunc main() {\n\tdebounced := Debounce(200*time.Millisecond, func() error {\n\t\tfmt.Println(\"executed\")\n\t\treturn nil\n\t})\n\t_ = debounced()\n\t_ = debounced() // resets timer\n\ttime.Sleep(300 * time.Millisecond)\n}\n```\n**Explanation:** `Debounce` returns a closure that resets a timer on each call; the wrapped function executes only after `wait` passes without further invocations. A mutex guards the shared timer for thread safety, and errors propagate via a channel.\n**Complexity:** Time: O(1) per call; Space: O(1) for timer state.\n**Example:**\nInput: Rapid successive calls to the debounced function\nOutput: Underlying `fn` runs once after 200ms of silence\n**Notes:**\n- In production, handle potential timer leaks; discard the channel receive if you don't need synchronous behavior.\n- For asynchronous fire-and-forget, drop the `done` channel and return immediately.\n- Ensure `fn` itself is thread-safe if multiple goroutines may call the wrapper.", "category": "function_implementation", "language": "go"}
{"prompt": "Create a TypeScript utility that debounces an async function call with proper error handling", "response": "typescript\n```typescript\n// Debounce an async function; returns a wrapper that resolves with the inner result\nfunction debounceAsync<T extends (...args: any[]) => Promise<any>>(fn: T, wait: number) {\n  let timer: NodeJS.Timeout | null = null;\n  let pendingReject: ((reason?: any) => void) | null = null;\n\n  return (...args: Parameters<T>): Promise<ReturnType<T>> => {\n    if (timer) clearTimeout(timer);\n    if (pendingReject) {\n      pendingReject(new Error('debounced'));\n      pendingReject = null;\n    }\n    return new Promise((resolve, reject) => {\n      pendingReject = reject;\n      timer = setTimeout(async () => {\n        timer = null;\n        pendingReject = null;\n        try {\n          const result = await fn(...args);\n          resolve(result as ReturnType<T>);\n        } catch (err) {\n          reject(err);\n        }\n      }, wait);\n    });\n  };\n}\n```\n**Explanation:** Returns a wrapper that resets a timer on each call; only the final call within the `wait` window executes `fn`. Previous pending promises are rejected to signal cancellation. Errors from `fn` propagate via promise rejection.\n**Complexity:** Time: O(1) per call; Space: O(1) for timer state.\n**Example:**\nInput: Rapid calls to `debounceAsync(fetchData, 300)`\nOutput: Only the last invocation triggers `fetchData`; earlier calls reject with `debounced`.\n**Notes:**\n- Adjust cancellation behavior if you prefer silent drops instead of rejection.\n- Works in Node; swap timer types for browser if needed.\n- Ensure `fn` is idempotent if multiple callers may race.", "category": "function_implementation", "language": "typescript"}
{"prompt": "Implement a Java function to summarize given an array of objects", "response": "java\n```java\nimport java.util.List;\nimport java.util.function.ToDoubleFunction;\n\npublic class ObjectSummarizer {\n    /**\n     * Sum a numeric property across a list of objects.\n     */\n    public static <T> double summarize(List<T> items, ToDoubleFunction<T> getter) {\n        double total = 0.0;\n        for (T item : items) {\n            total += getter.applyAsDouble(item);\n        }\n        return total;\n    }\n}\n```\n**Explanation:** Accepts a list and a lambda extracting a numeric field. Iterates once, accumulating the extracted values into a running total.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: items = [{price: 10}, {price: 15}], getter = item -> item.price\nOutput: 25.0\n**Notes:**\n- Replace `double` with `BigDecimal` for currency to avoid floating-point drift.\n- Validate input list for null before iterating.\n- Extend to return count/avg/min/max by tracking additional aggregates.", "category": "function_implementation", "language": "java"}
{"prompt": "Implement a Go function to summarize given a string", "response": "go\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// Summarize a string: length, word count, and normalized lowercase form.\ntype Summary struct {\n\tLength int\n\tWords  int\n\tLower  string\n}\n\nfunc Summarize(input string) Summary {\n\ttrimmed := strings.TrimSpace(input)\n\twords := 0\n\tif trimmed != \"\" {\n\t\twords = len(strings.Fields(trimmed))\n\t}\n\treturn Summary{\n\t\tLength: len(trimmed),\n\t\tWords:  words,\n\t\tLower:  strings.ToLower(trimmed),\n\t}\n}\n\nfunc main() {\n\tfmt.Println(Summarize(\" Hello World \"))\n}\n```\n**Explanation:** Trims whitespace, counts words via `Fields`, records trimmed length, and stores a lowercase version. Returns a `Summary` struct with the aggregated metadata.\n**Complexity:** Time: O(n); Space: O(n) for the lowercase copy.\n**Example:**\nInput: \" Hello World \"\nOutput: Summary{Length:11, Words:2, Lower:\"hello world\"}\n**Notes:**\n- Adjust to include character frequency or other metrics as needed.\n- If empty input is allowed, word count is zero and length reflects trimmed size.\n- For very large strings, avoid multiple passes by combining scans if performance critical.", "category": "function_implementation", "language": "go"}
{"prompt": "Implement a JavaScript function to transform given a list of numbers", "response": "javascript\n```javascript\n/**\n * Transform a list of numbers by normalizing (z-score) and returning a new array.\n */\nfunction transformNumbers(nums) {\n  if (!Array.isArray(nums) || nums.length === 0) return [];\n  const mean = nums.reduce((s, n) => s + n, 0) / nums.length;\n  const variance = nums.reduce((s, n) => s + (n - mean) ** 2, 0) / nums.length;\n  const std = Math.sqrt(variance) || 1;\n  return nums.map((n) => (n - mean) / std);\n}\n```\n**Explanation:** Computes mean and standard deviation, then maps each number to its z-score, producing a transformed array without mutating the input.\n**Complexity:** Time: O(n); Space: O(n) for output.\n**Example:**\nInput: [1, 2, 3]\nOutput: [-1.2247, 0, 1.2247] (approx)\n**Notes:**\n- If variance is zero, std is coerced to 1 to avoid division by zero.\n- Adjust transformation (e.g., scaling, clipping) to your needs.\n- Validate elements are numeric to avoid NaN propagation.", "category": "function_implementation", "language": "javascript"}
{"prompt": "Write a Python function that flattens a nested list of numbers", "response": "python\n```python\nfrom typing import Iterable, Union, List\n\nNested = Union[int, Iterable['Nested']]\n\ndef flatten(nested: Nested) -> List[int]:\n    out: List[int] = []\n    def dfs(item: Nested) -> None:\n        if isinstance(item, Iterable) and not isinstance(item, (str, bytes)):\n            for val in item:\n                dfs(val)\n        else:\n            out.append(int(item))\n    dfs(nested)\n    return out\n```\n**Explanation:** Recursively traverses arbitrarily nested iterables, skipping string/bytes as atomic, and appends leaf elements to an output list, converting to int for uniformity.\n**Complexity:** Time: O(n) elements; Space: O(n) for output plus recursion depth.\n**Example:**\nInput: [1, [2, [3, 4]], 5]\nOutput: [1, 2, 3, 4, 5]\n**Notes:**\n- For very deep nesting, switch to an explicit stack to avoid recursion depth errors.\n- Remove `int()` cast if non-integer leaves should be preserved.\n- Treat strings differently if you want to iterate characters instead of keeping whole string.", "category": "function_implementation", "language": "python"}
{"prompt": "Implement a Go function to transform given an array of objects", "response": "go\n```go\npackage main\n\ntype Item map[string]interface{}\n\ntype TransformFn func(Item) Item\n\n// TransformObjects applies fn to each object and returns a new slice.\nfunc TransformObjects(items []Item, fn TransformFn) []Item {\n\tout := make([]Item, 0, len(items))\n\tfor _, it := range items {\n\t\tout = append(out, fn(it))\n\t}\n\treturn out\n}\n```\n**Explanation:** Defines a generic transformer over a slice of map-like objects. Applies the provided function to each element, building a new slice so the original data is unchanged.\n**Complexity:** Time: O(n); Space: O(n) for the new slice.\n**Example:**\nInput: items=[{\"count\":1}], fn adds 10 -> count\nOutput: [{\"count\":11}]\n**Notes:**\n- Replace `map[string]interface{}` with a struct for type safety and performance.\n- If in-place mutation is acceptable, modify elements directly and return the same slice.\n- Handle nil slices gracefully (returns empty slice).", "category": "function_implementation", "language": "go"}
{"prompt": "Implement a Rust function to filter given an array of objects", "response": "rust\n```rust\n#[derive(Clone, Debug)]\npub struct Item {\n    pub value: i32,\n    pub active: bool,\n}\n\npub fn filter_active(items: &[Item]) -> Vec<Item> {\n    items.iter().cloned().filter(|i| i.active).collect()\n}\n```\n**Explanation:** Defines a simple `Item` struct and returns a new vector containing only elements where `active` is true, cloning to avoid borrowing issues.\n**Complexity:** Time: O(n); Space: O(n) for the filtered vector.\n**Example:**\nInput: [{value:1, active:true}, {value:2, active:false}]\nOutput: [{value:1, active:true}]\n**Notes:**\n- Adjust predicate to match real filtering criteria (e.g., thresholds).\n- If ownership isn’t needed, collect references instead of cloning.\n- For large data, consider streaming with iterators to avoid intermediate storage.", "category": "function_implementation", "language": "rust"}
{"prompt": "Create a TypeScript utility that streams large files without loading into memory with proper error handling", "response": "typescript\n```typescript\nimport * as fs from 'fs';\nimport { ReadStream } from 'fs';\n\n// Stream a file in chunks, invoking a handler per chunk with error handling.\nexport function streamFile(path: string, onChunk: (chunk: Buffer) => void): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const stream: ReadStream = fs.createReadStream(path);\n    stream.on('data', onChunk);\n    stream.on('error', reject);\n    stream.on('end', resolve);\n  });\n}\n```\n**Explanation:** Uses Node’s `createReadStream` to read the file incrementally. Attaches listeners for data, error, and end events, exposing a promise that resolves when streaming finishes or rejects on errors.\n**Complexity:** Time: O(file_size); Space: O(chunk_size) buffered by the stream.\n**Example:**\nInput: `await streamFile('large.log', (c) => console.log(c.length))`\nOutput: Logs chunk sizes until EOF\n**Notes:**\n- Pass `highWaterMark` in `createReadStream` options to tune chunk size.\n- Ensure the handler is fast; otherwise, pause/resume the stream to apply backpressure.\n- Wrap in try/catch when awaiting to surface errors.", "category": "function_implementation", "language": "typescript"}
{"prompt": "Write a Rust function that implements a simple calculator", "response": "rust\n```rust\npub fn calculate(lhs: f64, op: char, rhs: f64) -> Result<f64, String> {\n    match op {\n        '+' => Ok(lhs + rhs),\n        '-' => Ok(lhs - rhs),\n        '*' => Ok(lhs * rhs),\n        '/' => {\n            if rhs == 0.0 {\n                Err(\"division by zero\".into())\n            } else {\n                Ok(lhs / rhs)\n            }\n        }\n        _ => Err(\"unsupported operator\".into()),\n    }\n}\n```\n**Explanation:** Dispatches on the operator to perform arithmetic, returning a `Result` for error reporting (unsupported op or division by zero).\n**Complexity:** Time: O(1); Space: O(1).\n**Example:**\nInput: calculate(6.0, '/', 3.0)\nOutput: Ok(2.0)\n**Notes:**\n- Extend with more operators or parentheses by adding parsing logic.\n- Consider using `f64::EPSILON` comparisons for floating-point equality.\n- Propagate errors rather than panicking for robustness.", "category": "function_implementation", "language": "rust"}
{"prompt": "Write a Python function that evaluates a postfix expression", "response": "python\n```python\ndef eval_postfix(tokens: list[str]) -> int:\n    if not tokens:\n        raise ValueError(\"empty expression\")\n    stack: list[int] = []\n    for t in tokens:\n        if t in {\"+\", \"-\", \"*\", \"/\"}:\n            b = stack.pop(); a = stack.pop()\n            if t == \"+\": stack.append(a + b)\n            elif t == \"-\": stack.append(a - b)\n            elif t == \"*\": stack.append(a * b)\n            else: stack.append(int(a / b))  # truncate toward zero\n        else:\n            stack.append(int(t))\n    if len(stack) != 1:\n        raise ValueError(\"invalid postfix expression\")\n    return stack[0]\n```\n**Explanation:** Scans tokens left to right, pushing operands to a stack; on an operator, pops the top two operands, applies the operation, and pushes the result. After processing, the stack should contain exactly one result.\n**Complexity:** Time: O(n); Space: O(n) for the stack.\n**Example:**\nInput: [\"2\", \"1\", \"+\", \"3\", \"*\"]\nOutput: 9\n**Notes:**\n- Integer division uses truncation toward zero; adjust for floor division if needed.\n- Validate token lists to avoid `pop` from an empty stack.\n- Extend to support unary operators or exponentiation as required.", "category": "function_implementation", "language": "python"}
{"prompt": "Write a Java function that sorts an array using quicksort", "response": "java\n```java\npublic class QuickSort {\n    public static void quicksort(int[] arr) {\n        sort(arr, 0, arr.length - 1);\n    }\n    private static void sort(int[] arr, int lo, int hi) {\n        if (lo >= hi) return;\n        int p = partition(arr, lo, hi);\n        sort(arr, lo, p - 1);\n        sort(arr, p + 1, hi);\n    }\n    private static int partition(int[] arr, int lo, int hi) {\n        int pivot = arr[hi];\n        int i = lo;\n        for (int j = lo; j < hi; j++) {\n            if (arr[j] <= pivot) {\n                swap(arr, i, j);\n                i++;\n            }\n        }\n        swap(arr, i, hi);\n        return i;\n    }\n    private static void swap(int[] arr, int i, int j) {\n        int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp;\n    }\n}\n```\n**Explanation:** Lomuto partition quicksort: choose the last element as pivot, partition the array around it, then recursively sort subarrays left/right of the pivot index.\n**Complexity:** Time: O(n log n) average, O(n²) worst case; Space: O(log n) recursion stack.\n**Example:**\nInput: [3, 7, 2, 5]\nOutput: [2, 3, 5, 7]\n**Notes:**\n- Randomize pivot to reduce worst-case likelihood on sorted input.\n- For tiny partitions, switching to insertion sort can improve constants.\n- Not stable; equal elements may reorder.", "category": "function_implementation", "language": "java"}
{"prompt": "Write a C++ function that flattens a nested list of numbers", "response": "c++\n```cpp\n#include <variant>\n#include <vector>\n\nusing Nested = std::variant<int, std::vector<std::variant<int, std::vector<std::variant<int, std::vector<std::variant<int, std::vector<std::variant<int, std::vector<std::variant<int, std::vector<std::variant<int,std::vector<int>>>>>>>>>>>>; // simplified below in code usage\n// For clarity, we'll use a recursive helper on a generic nested structure represented as std::vector of std::variant<int, nested>.\n\nusing Node = std::variant<int, std::vector<Node>>;\n\nvoid flatten(const Node& node, std::vector<int>& out) {\n    if (std::holds_alternative<int>(node)) {\n        out.push_back(std::get<int>(node));\n    } else {\n        for (const auto& child : std::get<std::vector<Node>>(node)) {\n            flatten(child, out);\n        }\n    }\n}\n\nstd::vector<int> flattenNested(const Node& root) {\n    std::vector<int> result;\n    flatten(root, result);\n    return result;\n}\n```\n**Explanation:** Represents a nested list as `Node = variant<int, vector<Node>>`. The recursive helper walks the structure: if it's an int, append to output; if it's a list, recurse on each element. Collects results in a flat vector.\n**Complexity:** Time: O(n) elements; Space: O(n) for output plus recursion depth.\n**Example:**\nInput: Node { std::vector<Node>{ 1, std::vector<Node>{2,3} } }\nOutput: [1,2,3]\n**Notes:**\n- Adjust representation to your actual nested type; for production, define a proper nested list class rather than deep variant aliases.\n- Use an explicit stack if recursion depth might overflow.\n- Preserve order; duplicates are kept as-is.", "category": "function_implementation", "language": "c++"}
{"prompt": "Write a C++ function that finds the longest common substring", "response": "c++\n```cpp\n#include <string>\n#include <vector>\n\nint longestCommonSubstring(const std::string& a, const std::string& b) {\n    int m = a.size(), n = b.size();\n    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1, 0));\n    int best = 0;\n    for (int i = 1; i <= m; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            if (a[i - 1] == b[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n                best = std::max(best, dp[i][j]);\n            }\n        }\n    }\n    return best;\n}\n```\n**Explanation:** Uses dynamic programming where `dp[i][j]` stores the length of the longest common suffix ending at `a[i-1]` and `b[j-1]`. Matching characters extend the previous diagonal; non-matches leave the cell at 0. Track the maximum seen.\n**Complexity:** Time: O(mn); Space: O(mn) (reduce to O(n) with rolling rows).\n**Example:**\nInput: a=\"abcdxyz\", b=\"xyzabcd\"\nOutput: 4 (\"abcd\")\n**Notes:**\n- For memory savings, keep only two rows.\n- Substring requires contiguity; for subsequence use a different DP.\n- Returns length; to retrieve the substring, store the end position when updating `best`.", "category": "function_implementation", "language": "c++"}
{"prompt": "Write a C++ function that checks if a string is a palindrome", "response": "c++\n```cpp\n#include <string>\n#include <cctype>\n\nbool isPalindrome(const std::string& s) {\n    int i = 0, j = static_cast<int>(s.size()) - 1;\n    while (i < j) {\n        while (i < j && !std::isalnum(static_cast<unsigned char>(s[i]))) i++;\n        while (i < j && !std::isalnum(static_cast<unsigned char>(s[j]))) j--;\n        if (std::tolower(static_cast<unsigned char>(s[i])) != std::tolower(static_cast<unsigned char>(s[j]))) {\n            return false;\n        }\n        i++; j--;\n    }\n    return true;\n}\n```\n**Explanation:** Two-pointer scan from both ends, skipping non-alphanumeric characters and comparing case-insensitively. Returns false on the first mismatch.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: \"A man, a plan, a canal: Panama\"\nOutput: true\n**Notes:**\n- Remove skipping/normalization if punctuation/case should be considered.\n- Works for empty or single-character strings (palindromes by definition).\n- Cast to unsigned char before `std::tolower`/`std::isalnum` to avoid UB.", "category": "function_implementation", "language": "c++"}
{"prompt": "Implement a Rust function to summarize given a string", "response": "rust\n```rust\npub struct Summary {\n    pub length: usize,\n    pub words: usize,\n    pub lowercase: String,\n}\n\npub fn summarize(text: &str) -> Summary {\n    let trimmed = text.trim();\n    let words = if trimmed.is_empty() { 0 } else { trimmed.split_whitespace().count() };\n    Summary {\n        length: trimmed.chars().count(),\n        words,\n        lowercase: trimmed.to_lowercase(),\n    }\n}\n```\n**Explanation:** Trims the input, counts characters and whitespace-delimited words, and produces a lowercase copy packaged in a `Summary` struct.\n**Complexity:** Time: O(n); Space: O(n) for the lowercase string.\n**Example:**\nInput: \" Hello Rust \"\nOutput: Summary { length: 10, words: 2, lowercase: \"hello rust\" }\n**Notes:**\n- Use `trim_matches` to customize which characters are trimmed.\n- `chars().count()` counts Unicode scalar values; for bytes, use `len()`.\n- Extend with additional stats like frequency counts if needed.", "category": "function_implementation", "language": "rust"}
{"prompt": "Implement a Python function to aggregate given a string", "response": "python\n```python\nfrom collections import Counter\n\ndef aggregate_string(s: str) -> dict[str, int]:\n    \"\"\"Count character frequencies in the string.\"\"\"\n    return dict(Counter(s))\n```\n**Explanation:** Uses `Counter` to tally occurrences of each character, returning a plain dict mapping characters to counts.\n**Complexity:** Time: O(n); Space: O(k) for k distinct characters.\n**Example:**\nInput: \"banana\"\nOutput: {'b': 1, 'a': 3, 'n': 2}\n**Notes:**\n- Normalize case or strip whitespace before counting if desired.\n- For word-level aggregation, split on whitespace instead of iterating characters.\n- Counter supports addition/subtraction if merging multiple strings.", "category": "function_implementation", "language": "python"}
{"prompt": "Implement a Python function to normalize given a stream of log lines", "response": "python\n```python\nfrom typing import Iterable, List, Dict\n\ndef normalize_logs(lines: Iterable[str]) -> List[Dict[str, str]]:\n    records = []\n    for line in lines:\n        line = line.strip()\n        if not line:\n            continue\n        parts = line.split(maxsplit=2)\n        if len(parts) == 3:\n            ts, level, msg = parts\n        elif len(parts) == 2:\n            ts, msg = parts; level = \"INFO\"\n        else:\n            ts, level, msg = line, \"INFO\", \"\"\n        records.append({\n            \"timestamp\": ts,\n            \"level\": level.upper(),\n            \"message\": msg,\n        })\n    return records\n```\n**Explanation:** Iterates log lines, trims whitespace, skips blanks, splits into timestamp/level/message (with sensible defaults), and returns structured dictionaries.\n**Complexity:** Time: O(n * m) where m is avg line length; Space: O(n) for parsed records.\n**Example:**\nInput: [\"2024-01-01 INFO started\", \"2024-01-01 WARN high load\"]\nOutput: [{timestamp:\"2024-01-01\", level:\"INFO\", message:\"started\"}, ...]\n**Notes:**\n- Adjust parsing if timestamps contain spaces; use regex for richer formats.\n- Validate log levels against an allowlist if needed.\n- Add error handling/logging for malformed lines instead of defaulting.", "category": "function_implementation", "language": "python"}
{"prompt": "Create a TypeScript utility that memoizes expensive computations with proper error handling", "response": "typescript\n```typescript\n// Memoize a pure function with error handling for non-hashable arguments\nexport function memoize<T extends (...args: any[]) => any>(fn: T) {\n  const cache = new Map<string, ReturnType<T>>();\n  return (...args: Parameters<T>): ReturnType<T> => {\n    let key: string;\n    try {\n      key = JSON.stringify(args);\n    } catch (err) {\n      throw new Error('Arguments must be serializable for memoization');\n    }\n    if (cache.has(key)) return cache.get(key)!;\n    const result = fn(...args);\n    cache.set(key, result);\n    return result;\n  };\n}\n```\n**Explanation:** Builds a string key from the argument list, caches results in a Map, and returns cached values on repeat calls. Throws when arguments cannot be serialized, keeping behavior explicit.\n**Complexity:** Time: O(1) average cache access plus cost of `fn`; Space: O(m) for m cached entries.\n**Example:**\nInput: `const fib = memoize((n:number)=> n<2?n:fib(n-1)+fib(n-2)); fib(10);`\nOutput: 55\n**Notes:**\n- JSON serialization is simple but limited; use a better hash for complex structures.\n- Cache can grow unbounded; add eviction if needed.\n- Works best for pure, deterministic functions.", "category": "function_implementation", "language": "typescript"}
{"prompt": "Write a TypeScript function that evaluates a postfix expression", "response": "typescript\n```typescript\nexport function evalPostfix(tokens: string[]): number {\n  if (!tokens.length) throw new Error('empty expression');\n  const stack: number[] = [];\n  for (const t of tokens) {\n    if (['+', '-', '*', '/'].includes(t)) {\n      const b = stack.pop();\n      const a = stack.pop();\n      if (a === undefined || b === undefined) throw new Error('invalid expression');\n      switch (t) {\n        case '+': stack.push(a + b); break;\n        case '-': stack.push(a - b); break;\n        case '*': stack.push(a * b); break;\n        case '/': stack.push((a / b) | 0); break; // truncate toward 0\n      }\n    } else {\n      stack.push(Number(t));\n    }\n  }\n  if (stack.length !== 1) throw new Error('invalid expression');\n  return stack[0];\n}\n```\n**Explanation:** Processes tokens left-to-right, using a stack for operands; operators pop the top two operands, apply the operation, and push the result. Valid postfix expressions end with exactly one value on the stack.\n**Complexity:** Time: O(n); Space: O(n) for the stack.\n**Example:**\nInput: ['2','1','+','3','*']\nOutput: 9\n**Notes:**\n- Division uses integer truncation via bitwise-or; replace with `a / b` for floating results.\n- Validate tokens to avoid `NaN` inputs.\n- Extend with additional operators by adding cases.", "category": "function_implementation", "language": "typescript"}
{"prompt": "Create a Go utility that memoizes expensive computations with proper error handling", "response": "go\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype MemoizedFunc[T any] func(args ...any) (T, error)\n\n// Memoize wraps a function that returns (T, error) using JSON-serialized args as key.\nfunc Memoize[T any](fn func(args ...any) (T, error)) MemoizedFunc[T] {\n\tcache := make(map[string]T)\n\treturn func(args ...any) (T, error) {\n\t\tvar zero T\n\t\tkeyBytes, err := json.Marshal(args)\n\t\tif err != nil {\n\t\t\treturn zero, fmt.Errorf(\"cannot memoize args: %w\", err)\n\t\t}\n\t\tkey := string(keyBytes)\n\t\tif val, ok := cache[key]; ok {\n\t\t\treturn val, nil\n\t\t}\n\t\tval, err := fn(args...)\n\t\tif err != nil {\n\t\t\treturn zero, err\n\t\t}\n\t\tcache[key] = val\n\t\treturn val, nil\n\t}\n}\n```\n**Explanation:** Wraps a variadic function, hashing arguments via JSON, and caches successful results in a map. Returns cached values on repeat calls; bubbles errors without caching them.\n**Complexity:** Time: O(1) average for cache hits plus serialization cost; Space: O(m) for m cached entries.\n**Example:**\nInput: memoized fib-like function called multiple times\nOutput: Subsequent calls reuse cached results\n**Notes:**\n- Serialization fails on non-JSONable arguments; we surface that as an error.\n- Cache is unbounded; add eviction if needed.\n- Not concurrency-safe; guard with a mutex for concurrent use.", "category": "function_implementation", "language": "go"}
{"prompt": "Implement a Rust function to transform given a stream of log lines", "response": "rust\n```rust\npub struct LogRecord {\n    pub timestamp: String,\n    pub level: String,\n    pub message: String,\n}\n\npub fn transform_logs(lines: &[String]) -> Vec<LogRecord> {\n    let mut out = Vec::new();\n    for line in lines {\n        let trimmed = line.trim();\n        if trimmed.is_empty() { continue; }\n        let mut parts = trimmed.splitn(3, ' ');\n        let ts = parts.next().unwrap_or(\"\").to_string();\n        let level = parts.next().unwrap_or(\"INFO\").to_uppercase();\n        let message = parts.next().unwrap_or(\"\").to_string();\n        out.push(LogRecord { timestamp: ts, level, message });\n    }\n    out\n}\n```\n**Explanation:** Parses each log line into timestamp, level, and message using `splitn(3, ' ')`, defaulting to INFO when no level is provided. Skips blank lines and returns structured records.\n**Complexity:** Time: O(n * m) over lines and average length; Space: O(n) for the output.\n**Example:**\nInput: [\"2024-01-01 info started\", \"2024-01-01 warn high load\"]\nOutput: records with normalized uppercase levels and parsed fields\n**Notes:**\n- Adjust splitting if timestamps contain spaces; use regex for richer formats.\n- Consider parsing level into an enum to validate allowed levels.\n- For streaming, yield records via an iterator instead of materializing a Vec.", "category": "function_implementation", "language": "rust"}
{"prompt": "Write a Go function that validates an email address", "response": "go\n```go\npackage main\n\nimport \"regexp\"\n\nvar emailRx = regexp.MustCompile(`^[\\w.+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$`)\n\n// IsValidEmail returns true when the string matches a simple email pattern.\nfunc IsValidEmail(email string) bool {\n\treturn emailRx.MatchString(email)\n}\n```\n**Explanation:** Precompiles a regex that matches common email forms (local@domain.tld) and checks the input string against it.\n**Complexity:** Time: O(n) for regex match; Space: O(1) auxiliary.\n**Example:**\nInput: \"user@example.com\"\nOutput: true\n**Notes:**\n- Regex is intentionally simple, not RFC-complete.\n- Trim surrounding whitespace before validation if inputs may contain it.\n- Reuse the compiled regex to avoid recompilation overhead.", "category": "function_implementation", "language": "go"}
{"prompt": "Create a Python utility that memoizes expensive computations with proper error handling", "response": "python\n```python\nfrom functools import wraps\nfrom typing import Callable, TypeVar, Dict, Tuple, Any\n\nT = TypeVar('T')\n\n\ndef memoize(func: Callable[..., T]) -> Callable[..., T]:\n    cache: Dict[Tuple[Any, ...], T] = {}\n\n    @wraps(func)\n    def wrapper(*args: Any) -> T:\n        if args in cache:\n            return cache[args]\n        result = func(*args)\n        cache[args] = result\n        return result\n\n    return wrapper\n```\n**Explanation:** Decorator storing results in a dictionary keyed by the argument tuple. Returns cached values on repeated calls to avoid recomputation.\n**Complexity:** Time: O(1) average cache access plus the cost of `func` on misses; Space: O(m) for m cached entries.\n**Example:**\nInput: \n```python\n@memoize\ndef fib(n):\n    return n if n < 2 else fib(n-1) + fib(n-2)\n```\nOutput: fib(10) -> 55 with far fewer recursive calls\n**Notes:**\n- Arguments must be hashable; for unhashable args, serialize or convert to tuples.\n- Cache grows unbounded; add eviction if necessary.\n- For thread safety, wrap cache access with a lock.", "category": "function_implementation", "language": "python"}
{"prompt": "Create a JavaScript utility that streams large files without loading into memory with proper error handling", "response": "javascript\n```javascript\nimport fs from 'fs';\nimport { pipeline } from 'stream/promises';\n\n// Stream a file to a writable destination without loading it all into memory\nexport async function streamFile(srcPath, destPath) {\n  const src = fs.createReadStream(srcPath);\n  const dest = fs.createWriteStream(destPath);\n  await pipeline(src, dest);\n}\n```\n**Explanation:** Uses Node's `pipeline` to pipe a readable stream to a writable stream with built-in backpressure and error propagation, preventing full file buffering.\n**Complexity:** Time: O(file_size); Space: O(chunk_size) buffered by the streams.\n**Example:**\nInput: streamFile('big.bin', 'copy.bin')\nOutput: Copies data from source to destination\n**Notes:**\n- Handle errors with try/catch around `streamFile` calls.\n- Tune `highWaterMark` on the streams for performance needs.\n- Use `fs.createReadStream` with `start`/`end` for ranged streaming if needed.", "category": "function_implementation", "language": "javascript"}
{"prompt": "Write a Go function that finds the longest common substring", "response": "go\n```go\npackage main\n\n// LongestCommonSubstring returns the length of the longest common substring.\nfunc LongestCommonSubstring(a, b string) int {\n\tm, n := len(a), len(b)\n\tdp := make([][]int, m+1)\n\tbest := 0\n\tfor i := range dp {\n\t\tdp[i] = make([]int, n+1)\n\t}\n\tfor i := 1; i <= m; i++ {\n\t\tfor j := 1; j <= n; j++ {\n\t\t\tif a[i-1] == b[j-1] {\n\t\t\t\tdp[i][j] = dp[i-1][j-1] + 1\n\t\t\t\tif dp[i][j] > best {\n\t\t\t\t\tbest = dp[i][j]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn best\n}\n```\n**Explanation:** DP table `dp[i][j]` holds the longest common suffix ending at `a[i-1]` and `b[j-1]`. Matching chars extend the diagonal; track the maximum cell value as the answer.\n**Complexity:** Time: O(mn); Space: O(mn) (use rolling rows to reduce to O(n)).\n**Example:**\nInput: a=\"abcdxyz\", b=\"xyzabcd\"\nOutput: 4\n**Notes:**\n- Returns length; track indices to recover the substring if needed.\n- For memory savings, keep two rows instead of the full table.\n- Substring requires contiguity; for subsequence use a different DP.", "category": "function_implementation", "language": "go"}
{"prompt": "Write a Rust function that finds the nth Fibonacci number", "response": "rust\n```rust\n/// Return the nth Fibonacci number (0-indexed: fib(0)=0, fib(1)=1).\npub fn fibonacci(n: u32) -> u64 {\n    if n == 0 {\n        return 0;\n    }\n    let mut a: u64 = 0;\n    let mut b: u64 = 1;\n    for _ in 1..n {\n        let next = a + b;\n        a = b;\n        b = next;\n    }\n    b\n}\n```\n**Explanation:** Handles the n=0 base case, then iteratively advances two accumulators (`a`, `b`) to build the sequence without recursion. After `n-1` updates, `b` holds fib(n).\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: n = 7\nOutput: 13\n**Notes:**\n- For very large n, use `num_bigint::BigUint` to avoid overflow.\n- Zero-indexing keeps fib(0)=0, fib(1)=1; adjust if one-based is required.\n- Iterative approach avoids recursion depth and stack overhead.", "category": "function_implementation", "language": "rust"}
{"prompt": "Implement a Java function to transform given a stream of log lines", "response": "java\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class LogTransformer {\n    public static record LogRecord(String timestamp, String level, String message) {}\n\n    public static List<LogRecord> transform(List<String> lines) {\n        List<LogRecord> out = new ArrayList<>();\n        for (String line : lines) {\n            if (line == null || line.isBlank()) continue;\n            String[] parts = line.trim().split(\"\\\\s+\", 3);\n            String ts = parts.length > 0 ? parts[0] : \"\";\n            String level = parts.length > 1 ? parts[1].toUpperCase() : \"INFO\";\n            String msg = parts.length > 2 ? parts[2] : \"\";\n            out.add(new LogRecord(ts, level, msg));\n        }\n        return out;\n    }\n}\n```\n**Explanation:** Splits each log line into timestamp, level, and message (max 3 parts), uppercases the level, and returns structured `LogRecord` objects, skipping blank lines.\n**Complexity:** Time: O(n * m) over lines and length; Space: O(n) for output.\n**Example:**\nInput: [\"2024-01-01 info started\"]\nOutput: LogRecord(timestamp=\"2024-01-01\", level=\"INFO\", message=\"started\")\n**Notes:**\n- Adjust parsing if timestamps include spaces; a regex with capture groups may be needed.\n- Validate level against an allowlist if important.\n- For streaming, emit records incrementally rather than collecting in a list.", "category": "function_implementation", "language": "java"}
{"prompt": "Write a JavaScript function that finds the longest common substring", "response": "javascript\n```javascript\nfunction longestCommonSubstring(a, b) {\n  const m = a.length, n = b.length;\n  const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n  let best = 0;\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (a[i - 1] === b[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1] + 1;\n        best = Math.max(best, dp[i][j]);\n      }\n    }\n  }\n  return best;\n}\n```\n**Explanation:** Dynamic programming where `dp[i][j]` stores the length of the longest common suffix ending at `a[i-1]` and `b[j-1]`. Matching chars extend the diagonal value, and the maximum over the table is the LCS length.\n**Complexity:** Time: O(mn); Space: O(mn) (optimize to O(n) with rolling arrays).\n**Example:**\nInput: a=\"abcdxyz\", b=\"xyzabcd\"\nOutput: 4\n**Notes:**\n- To retrieve the substring, track the index where `best` occurs and slice back `best` chars.\n- For memory savings, keep only two rows.\n- This is substring (contiguous); for subsequence use a different DP.", "category": "function_implementation", "language": "javascript"}
{"prompt": "Create a Go utility that generates paginated results from a collection with proper error handling", "response": "go\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\n// Paginate returns a slice for the requested page along with total pages.\ntype PageResult[T any] struct {\n\tItems      []T\n\tPage       int\n\tPageSize   int\n\tTotal      int\n\tTotalPages int\n}\n\nfunc Paginate[T any](items []T, page, pageSize int) (PageResult[T], error) {\n\tif page <= 0 || pageSize <= 0 {\n\t\treturn PageResult[T]{}, fmt.Errorf(\"page and pageSize must be positive\")\n\t}\n\ttotal := len(items)\n\ttotalPages := int(math.Max(1, math.Ceil(float64(total)/float64(pageSize))))\n\tif page > totalPages {\n\t\tpage = totalPages\n\t}\n\tstart := (page - 1) * pageSize\n\tif start > total {\n\t\tstart = total\n\t}\n\tend := start + pageSize\n\tif end > total {\n\t\tend = total\n\t}\n\treturn PageResult[T]{\n\t\tItems:      items[start:end],\n\t\tPage:       page,\n\t\tPageSize:   pageSize,\n\t\tTotal:      total,\n\t\tTotalPages: totalPages,\n\t}, nil\n}\n```\n**Explanation:** Validates parameters, computes total pages, clamps the requested page, slices the backing collection to the desired window, and returns pagination metadata. Errors out on invalid inputs.\n**Complexity:** Time: O(k) to copy page items (k = pageSize); Space: O(k) for the slice view.\n**Example:**\nInput: items=[1,2,3,4,5], page=2, pageSize=2\nOutput: Items=[3,4], Page=2, TotalPages=3\n**Notes:**\n- Adjust behavior when `page` exceeds `totalPages` (throw instead of clamp) as needed.\n- For very large datasets, paginate at the data source instead of slicing in memory.\n- Consider returning iterators if copying is undesirable.", "category": "function_implementation", "language": "go"}
{"prompt": "Write a Go function that computes the greatest common divisor (GCD)", "response": "go\n```go\npackage main\n\n// GCD computes the greatest common divisor using the Euclidean algorithm.\nfunc GCD(a, b int) int {\n\tif a < 0 {\n\t\ta = -a\n\t}\n\tif b < 0 {\n\t\tb = -b\n\t}\n\tfor b != 0 {\n\t\ta, b = b, a%b\n\t}\n\treturn a\n}\n```\n**Explanation:** Iteratively applies Euclid’s algorithm, replacing (a, b) with (b, a % b) until b is zero; the remaining a is the GCD. Handles negative inputs by taking absolute values.\n**Complexity:** Time: O(log min(a, b)); Space: O(1).\n**Example:**\nInput: GCD(54, 24)\nOutput: 6\n**Notes:**\n- If both inputs are zero, result is zero; define behavior explicitly if needed.\n- Use `uint` if only non-negative inputs are expected.\n- Extend to compute LCM via `abs(a*b)/gcd(a,b)` with overflow checks.", "category": "function_implementation", "language": "go"}
{"prompt": "Create a Go utility that retries HTTP requests with exponential backoff with proper error handling", "response": "go\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// GetWithBackoff performs an HTTP GET with exponential backoff retries.\nfunc GetWithBackoff(url string, maxRetries int, baseDelay time.Duration) (*http.Response, error) {\n\tclient := &http.Client{Timeout: 10 * time.Second}\n\tfor attempt := 0; attempt <= maxRetries; attempt++ {\n\t\tresp, err := client.Get(url)\n\t\tif err == nil && resp.StatusCode < 500 {\n\t\t\treturn resp, nil\n\t\t}\n\t\tif resp != nil {\n\t\t\tresp.Body.Close()\n\t\t}\n\t\tif attempt == maxRetries {\n\t\t\treturn nil, fmt.Errorf(\"request failed after %d attempts: %w\", attempt+1, err)\n\t\t}\n\t\tdelay := time.Duration(float64(baseDelay) * math.Pow(2, float64(attempt)))\n\t\ttime.Sleep(delay)\n\t}\n\treturn nil, fmt.Errorf(\"unreachable code\")\n}\n```\n**Explanation:** Attempts the GET request up to `maxRetries + 1` times, doubling the delay after each failure. Treats 5xx or network errors as retryable, closing bodies before retrying. Returns on first success or after exhausting retries.\n**Complexity:** Time: O(retries * request_time); Space: O(1) auxiliary.\n**Example:**\nInput: GetWithBackoff(\"https://example.com\", 3, 200*time.Millisecond)\nOutput: HTTP response or error after retries\n**Notes:**\n- Add jitter to backoff to avoid synchronized retries.\n- Tighten retry logic to specific status codes/exceptions based on your needs.\n- Caller owns the response body; remember to close it when done.", "category": "function_implementation", "language": "go"}
{"prompt": "Implement a Rust function to validate given a string", "response": "rust\n```rust\npub fn is_valid_string(s: &str, min_len: usize, max_len: usize) -> bool {\n    let trimmed = s.trim();\n    let len = trimmed.chars().count();\n    len >= min_len && len <= max_len\n}\n```\n**Explanation:** Trims whitespace, counts Unicode scalar values, and checks length bounds to validate the string.\n**Complexity:** Time: O(n) to count chars; Space: O(1) extra.\n**Example:**\nInput: s=\"  hello  \", min_len=1, max_len=10\nOutput: true\n**Notes:**\n- For byte-length checks, use `trimmed.len()` instead of `chars().count()`.\n- Extend with regex or character class checks to enforce format.\n- Consider returning detailed errors rather than a boolean for better UX.", "category": "function_implementation", "language": "rust"}
{"prompt": "Write a Java function that validates an email address", "response": "java\n```java\nimport java.util.regex.Pattern;\n\npublic class EmailValidator {\n    private static final Pattern EMAIL = Pattern.compile(\"^[\\\\w.+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$\");\n\n    public static boolean isValid(String email) {\n        return email != null && EMAIL.matcher(email.trim()).matches();\n    }\n}\n```\n**Explanation:** Precompiles a simple regex for common email shapes (local@domain.tld). `isValid` trims whitespace, checks null, and matches against the pattern.\n**Complexity:** Time: O(n) for match; Space: O(1) auxiliary.\n**Example:**\nInput: \"user@example.com\"\nOutput: true\n**Notes:**\n- Regex is intentionally permissive; full RFC compliance requires a more complex pattern.\n- Trim handling avoids leading/trailing whitespace issues.\n- Consider normalizing case for domain comparisons if needed.", "category": "function_implementation", "language": "java"}
{"prompt": "Implement a Rust function to summarize given an array of objects", "response": "rust\n```rust\n#[derive(Debug)]\npub struct Item {\n    pub value: i32,\n}\n\npub fn summarize(items: &[Item]) -> (usize, i32, Option<i32>, Option<i32>) {\n    if items.is_empty() {\n        return (0, 0, None, None);\n    }\n    let mut total = 0;\n    let mut min = items[0].value;\n    let mut max = items[0].value;\n    for it in items {\n        total += it.value;\n        if it.value < min { min = it.value; }\n        if it.value > max { max = it.value; }\n    }\n    (items.len(), total, Some(min), Some(max))\n}\n```\n**Explanation:** Iterates once over the slice of objects, accumulating count, sum, and tracking min/max on a `value` field. Returns tuple with optional min/max to cover the empty case.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: items = [{value:1}, {value:4}]\nOutput: (2, 5, Some(1), Some(4))\n**Notes:**\n- Adjust return type to a struct for clarity if preferred.\n- Extend to compute average or other metrics as needed.\n- If Item shape differs, change the accessed field accordingly.", "category": "function_implementation", "language": "rust"}
{"prompt": "Implement a Go function to normalize given an array of objects", "response": "go\n```go\npackage main\n\nimport \"strings\"\n\ntype Obj map[string]string\n\n// NormalizeObjects lowercases keys and trims values.\nfunc NormalizeObjects(items []Obj) []Obj {\n\tout := make([]Obj, 0, len(items))\n\tfor _, o := range items {\n\t\tnorm := make(Obj)\n\t\tfor k, v := range o {\n\t\t\tnorm[strings.ToLower(strings.TrimSpace(k))] = strings.TrimSpace(v)\n\t\t}\n\t\tout = append(out, norm)\n\t}\n\treturn out\n}\n```\n**Explanation:** Iterates over a slice of map-like objects, producing new maps with lowercase, trimmed keys and trimmed values. Leaves original data unchanged.\n**Complexity:** Time: O(total entries); Space: O(total entries) for the normalized copy.\n**Example:**\nInput: [{\" Name \": \" Alice \"}]\nOutput: [{\"name\": \"Alice\"}]\n**Notes:**\n- Adjust normalization (e.g., value lowercasing) to suit your schema.\n- Use struct types for better compile-time checks instead of maps.\n- Handle nil maps by skipping or initializing before use.", "category": "function_implementation", "language": "go"}
{"prompt": "Write a Go function that converts a decimal number to binary", "response": "go\n```go\npackage main\n\nimport \"strconv\"\n\n// DecimalToBinary converts a non-negative integer to its binary string.\nfunc DecimalToBinary(n int) (string, error) {\n\tif n < 0 {\n\t\treturn \"\", fmt.Errorf(\"n must be non-negative\")\n\t}\n\treturn strconv.FormatInt(int64(n), 2), nil\n}\n```\n**Explanation:** Validates non-negative input and uses `strconv.FormatInt` with base 2 to produce the binary representation.\n**Complexity:** Time: O(log n); Space: O(log n) for the output string.\n**Example:**\nInput: 10\nOutput: \"1010\"\n**Notes:**\n- For padding, wrap result with `fmt.Sprintf` or `strings.Repeat` + concatenation.\n- For very large integers, switch to big.Int and call `.Text(2)`.\n- Returns an error for negative input to avoid surprising results.", "category": "function_implementation", "language": "go"}
{"prompt": "Write a Java function that computes the greatest common divisor (GCD)", "response": "java\n```java\npublic class GCDUtil {\n    public static int gcd(int a, int b) {\n        a = Math.abs(a);\n        b = Math.abs(b);\n        while (b != 0) {\n            int tmp = a % b;\n            a = b;\n            b = tmp;\n        }\n        return a;\n    }\n}\n```\n**Explanation:** Uses the iterative Euclidean algorithm, swapping remainder into the loop until the second operand becomes zero. Absolute values handle negative inputs.\n**Complexity:** Time: O(log min(a,b)); Space: O(1).\n**Example:**\nInput: gcd(48, 18)\nOutput: 6\n**Notes:**\n- If both inputs are zero, returns zero; adjust behavior if needed.\n- For multiple numbers, fold gcd across the list.\n- Use `long` for larger ranges to avoid overflow.", "category": "function_implementation", "language": "java"}
{"prompt": "Write a C++ function that finds the nth Fibonacci number", "response": "c++\n```cpp\nlong long fib(int n) {\n    if (n < 0) throw std::invalid_argument(\"n must be non-negative\");\n    if (n == 0) return 0;\n    long long a = 0, b = 1;\n    for (int i = 2; i <= n; ++i) {\n        long long next = a + b;\n        a = b;\n        b = next;\n    }\n    return b;\n}\n```\n**Explanation:** Iteratively computes Fibonacci numbers with two accumulators, handling the base case n=0. Avoids recursion depth and recomputation.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: fib(7)\nOutput: 13\n**Notes:**\n- For very large n, `long long` may overflow; use big integer libraries if needed.\n- Returns 1 for n=1 as per standard sequence.\n- Validate input to keep the function well-defined.", "category": "function_implementation", "language": "c++"}
{"prompt": "Implement a JavaScript function to normalize given a dictionary", "response": "javascript\n```javascript\n/** Normalize dictionary keys to lower-case and trim string values. */\nfunction normalizeDict(obj) {\n  const out = {};\n  for (const [k, v] of Object.entries(obj)) {\n    const key = k.trim().toLowerCase();\n    if (typeof v === 'string') {\n      out[key] = v.trim();\n    } else {\n      out[key] = v;\n    }\n  }\n  return out;\n}\n```\n**Explanation:** Iterates over entries, lowercases and trims keys, trims string values, and copies others as-is into a new object, leaving the original untouched.\n**Complexity:** Time: O(n) over properties; Space: O(n) for the new object.\n**Example:**\nInput: {\" Name \": \" Alice \", age: 30}\nOutput: {\"name\": \"Alice\", age: 30}\n**Notes:**\n- Adjust normalization rules for values (e.g., lowercasing) as needed.\n- Nested objects are not deep-normalized; apply recursively if required.\n- Skip or validate keys that become duplicates after normalization.", "category": "function_implementation", "language": "javascript"}
{"prompt": "Implement a Rust function to transform given an array of objects", "response": "rust\n```rust\n#[derive(Clone, Debug)]\npub struct Item {\n    pub value: i32,\n}\n\npub fn transform(items: &[Item], delta: i32) -> Vec<Item> {\n    items.iter().map(|i| Item { value: i.value + delta }).collect()\n}\n```\n**Explanation:** Returns a new vector where each item's `value` field is incremented by `delta`. Uses iterator mapping to avoid mutating the original slice.\n**Complexity:** Time: O(n); Space: O(n) for the new vector.\n**Example:**\nInput: [{value:1}, {value:2}], delta=5\nOutput: [{value:6}, {value:7}]\n**Notes:**\n- Adjust transformation logic to match real needs (e.g., normalization).\n- If in-place is acceptable, iterate mutably and modify directly.\n- Extend the struct fields as necessary for your domain.", "category": "function_implementation", "language": "rust"}
{"prompt": "Implement a Rust function to aggregate given a matrix", "response": "rust\n```rust\npub fn sum_matrix(mat: &[Vec<i32>]) -> i32 {\n    let mut total = 0;\n    for row in mat {\n        for &v in row {\n            total += v;\n        }\n    }\n    total\n}\n```\n**Explanation:** Iterates through each row and element, accumulating a running total of all entries in the matrix.\n**Complexity:** Time: O(r * c); Space: O(1) extra.\n**Example:**\nInput: [[1,2],[3,4]]\nOutput: 10\n**Notes:**\n- Replace the aggregation with min/max/average as needed.\n- Handle empty matrices naturally; result stays 0.\n- For large matrices, consider parallel iteration (e.g., Rayon) if performance is critical.", "category": "function_implementation", "language": "rust"}
{"prompt": "Create a JavaScript utility that debounces an async function call with proper error handling", "response": "javascript\n```javascript\n/**\n * Debounce an async function; rejects prior calls when superseded.\n */\nfunction debounceAsync(fn, wait = 200) {\n  let timer = null;\n  let rejectPrev = null;\n  return (...args) => {\n    if (timer) clearTimeout(timer);\n    if (rejectPrev) rejectPrev(new Error('debounced'));\n    return new Promise((resolve, reject) => {\n      rejectPrev = reject;\n      timer = setTimeout(async () => {\n        timer = null;\n        rejectPrev = null;\n        try {\n          const result = await fn(...args);\n          resolve(result);\n        } catch (err) {\n          reject(err);\n        }\n      }, wait);\n    });\n  };\n}\n```\n**Explanation:** Returns a wrapper that resets a timeout on each call. Previous pending calls are rejected to signal cancellation. Only the last call within the wait window invokes `fn`, and its result/error resolves/rejects the returned promise.\n**Complexity:** Time: O(1) per call; Space: O(1) for timer state.\n**Example:**\nInput: rapid invocations of `debounceAsync(fetchData, 300)`\nOutput: Only the final call runs `fetchData`; earlier calls reject with `debounced`.\n**Notes:**\n- Remove the rejection if you prefer silent cancellation.\n- Works in Node; for browsers, timer types remain compatible.\n- Ensure `fn` is idempotent if multiple rapid calls are possible.", "category": "function_implementation", "language": "javascript"}
{"prompt": "Create a TypeScript utility that parses and validates configuration files with proper error handling", "response": "typescript\n```typescript\nimport * as fs from 'fs';\n\ntype Config = {\n  port: number;\n  env: 'dev' | 'prod';\n};\n\nexport function loadConfig(path: string): Config {\n  const raw = fs.readFileSync(path, 'utf-8');\n  let parsed: any;\n  try {\n    parsed = JSON.parse(raw);\n  } catch (err) {\n    throw new Error(`Invalid JSON: ${err}`);\n  }\n  if (typeof parsed.port !== 'number' || !Number.isInteger(parsed.port)) {\n    throw new Error('port must be an integer');\n  }\n  if (!['dev', 'prod'].includes(parsed.env)) {\n    throw new Error('env must be \"dev\" or \"prod\"');\n  }\n  return { port: parsed.port, env: parsed.env } as Config;\n}\n```\n**Explanation:** Reads a JSON config file, parses it, and validates required fields (`port` integer, `env` enum). Throws descriptive errors when validation fails.\n**Complexity:** Time: O(n) to read/parse; Space: O(n) for the JSON string/object.\n**Example:**\nInput: file with `{\"port\":8080,\"env\":\"dev\"}`\nOutput: { port: 8080, env: 'dev' }\n**Notes:**\n- Extend schema with more fields and stricter checks as needed.\n- Wrap in try/catch at the call site to surface errors to users.\n- For large configs, stream parse or use a schema validator (e.g., zod, yup).", "category": "function_implementation", "language": "typescript"}
{"prompt": "Write a TypeScript function that computes the greatest common divisor (GCD)", "response": "typescript\n```typescript\nexport function gcd(a: number, b: number): number {\n  a = Math.abs(a);\n  b = Math.abs(b);\n  while (b !== 0) {\n    const tmp = a % b;\n    a = b;\n    b = tmp;\n  }\n  return a;\n}\n```\n**Explanation:** Euclidean algorithm iteratively replaces (a, b) with (b, a % b) until b becomes zero; the remaining a is the GCD. Takes absolute values to handle negatives.\n**Complexity:** Time: O(log min(a, b)); Space: O(1).\n**Example:**\nInput: gcd(54, 24)\nOutput: 6\n**Notes:**\n- If both inputs are zero, returns zero; define behavior if you need an error instead.\n- For arrays of numbers, fold this function across the collection.\n- Use bigint if you need exact results for very large integers.", "category": "function_implementation", "language": "typescript"}
{"prompt": "Create a C# utility that memoizes expensive computations with proper error handling", "response": "csharp\n```csharp\nusing System;\nusing System.Collections.Concurrent;\n\npublic static class Memoizer\n{\n    public static Func<T, TResult> Memoize<T, TResult>(Func<T, TResult> func)\n    {\n        var cache = new ConcurrentDictionary<T, TResult>();\n        return arg => cache.GetOrAdd(arg, func);\n    }\n}\n```\n**Explanation:** Wraps a unary function with a thread-safe `ConcurrentDictionary` cache. On each call, returns the cached result or computes and stores it if missing.\n**Complexity:** Time: O(1) average cache access plus `func` cost on misses; Space: O(m) for m cached entries.\n**Example:**\nInput: `var fibMemo = Memoizer.Memoize<int,int>(n => n < 2 ? n : fibMemo(n-1) + fibMemo(n-2)); fibMemo(10);`\nOutput: 55\n**Notes:**\n- Cache growth is unbounded; add eviction if necessary.\n- For multi-arg functions, wrap arguments in a tuple-like struct as the key.\n- Ensure `T` has correct hashing/equality semantics for dictionary use.", "category": "function_implementation", "language": "c#"}
{"prompt": "Implement a JavaScript function to process given a stream of log lines", "response": "javascript\n```javascript\n/**\n * Process a stream of log lines into structured objects.\n */\nfunction processLogs(lines) {\n  const records = [];\n  for (const line of lines) {\n    if (!line || !line.trim()) continue;\n    const [timestamp, level = 'INFO', ...msgParts] = line.trim().split(/\\s+/);\n    records.push({\n      timestamp,\n      level: level.toUpperCase(),\n      message: msgParts.join(' '),\n    });\n  }\n  return records;\n}\n```\n**Explanation:** Iterates log lines, skips blanks, splits into timestamp/level/message tokens, normalizes the level, and aggregates structured records.\n**Complexity:** Time: O(n * m) over lines and average tokens; Space: O(n) for output.\n**Example:**\nInput: [\"2024-01-01 info started\", \"2024-01-01 warn high load\"]\nOutput: [{timestamp:\"2024-01-01\", level:\"INFO\", message:\"started\"}, {timestamp:\"2024-01-01\", level:\"WARN\", message:\"high load\"}]\n**Notes:**\n- Adjust parsing if timestamps contain spaces; use regex captures for richer formats.\n- Validate levels against an allowlist to filter malformed lines.\n- For streaming, yield results instead of collecting into an array.", "category": "function_implementation", "language": "javascript"}
{"prompt": "Create a Python utility that streams large files without loading into memory with proper error handling", "response": "python\n```python\nfrom typing import Callable\n\ndef stream_file(path: str, chunk_size: int = 8192, handler: Callable[[bytes], None] = lambda _: None) -> None:\n    try:\n        with open(path, \"rb\") as f:\n            while True:\n                chunk = f.read(chunk_size)\n                if not chunk:\n                    break\n                handler(chunk)\n    except OSError as exc:\n        raise RuntimeError(f\"failed to stream {path}: {exc}\")\n```\n**Explanation:** Opens the file in binary mode and reads it in fixed-size chunks, invoking a handler for each chunk. Wraps I/O errors in a RuntimeError to surface failures cleanly.\n**Complexity:** Time: O(file_size); Space: O(chunk_size).\n**Example:**\nInput: stream_file(\"big.bin\", 1024, lambda c: print(len(c)))\nOutput: Prints sizes of each 1KB chunk until EOF\n**Notes:**\n- Customize `handler` for processing (hashing, uploading, etc.).\n- Tune `chunk_size` for performance vs. memory.\n- Caller can catch the RuntimeError to retry or report errors.", "category": "function_implementation", "language": "python"}
{"prompt": "Write a JavaScript function that evaluates a postfix expression", "response": "javascript\n```javascript\nfunction evalPostfix(tokens) {\n  if (!tokens.length) throw new Error('empty expression');\n  const stack = [];\n  for (const t of tokens) {\n    if (['+', '-', '*', '/'].includes(t)) {\n      const b = stack.pop();\n      const a = stack.pop();\n      if (a === undefined || b === undefined) throw new Error('invalid expression');\n      switch (t) {\n        case '+': stack.push(a + b); break;\n        case '-': stack.push(a - b); break;\n        case '*': stack.push(a * b); break;\n        case '/': stack.push(Math.trunc(a / b)); break;\n      }\n    } else {\n      const num = Number(t);\n      if (Number.isNaN(num)) throw new Error('non-numeric token');\n      stack.push(num);\n    }\n  }\n  if (stack.length !== 1) throw new Error('invalid expression');\n  return stack[0];\n}\n```\n**Explanation:** Processes tokens left-to-right; numbers are pushed, operators pop two operands, apply the op, and push the result. After all tokens, exactly one value should remain as the result.\n**Complexity:** Time: O(n); Space: O(n) for the stack.\n**Example:**\nInput: ['2','1','+','3','*']\nOutput: 9\n**Notes:**\n- Division uses truncation toward zero; replace with floating division if needed.\n- Throws on malformed expressions or non-numeric operands.\n- Extend with additional operators by adding cases.", "category": "function_implementation", "language": "javascript"}
{"prompt": "Implement a C++ function to normalize given an array of objects", "response": "c++\n```cpp\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <algorithm>\n\n// Normalize keys to lower-case and trim spaces in both keys and string values.\nstd::vector<std::unordered_map<std::string, std::string>> normalizeObjects(\n    const std::vector<std::unordered_map<std::string, std::string>>& objects) {\n    auto trim = [](const std::string& s) {\n        size_t i = 0, j = s.size();\n        while (i < j && std::isspace(static_cast<unsigned char>(s[i]))) i++;\n        while (j > i && std::isspace(static_cast<unsigned char>(s[j - 1]))) j--;\n        return s.substr(i, j - i);\n    };\n    auto lower = [](std::string s) {\n        std::transform(s.begin(), s.end(), s.begin(), [](unsigned char c) { return std::tolower(c); });\n        return s;\n    };\n\n    std::vector<std::unordered_map<std::string, std::string>> out;\n    out.reserve(objects.size());\n    for (const auto& obj : objects) {\n        std::unordered_map<std::string, std::string> norm;\n        for (const auto& [k, v] : obj) {\n            norm[lower(trim(k))] = trim(v);\n        }\n        out.push_back(std::move(norm));\n    }\n    return out;\n}\n```\n**Explanation:** Iterates over each input map, lowercases and trims keys, trims string values, and builds a normalized copy. Leaves the original data unchanged.\n**Complexity:** Time: O(total_chars) across all keys/values; Space: O(total_chars) for the normalized copies.\n**Example:**\nInput: [{\" Name \":\" Alice \", \"Email\":\"TEST@EXAMPLE.COM\"}]\nOutput: [{\"name\":\"Alice\", \"email\":\"TEST@EXAMPLE.COM\"}]\n**Notes:**\n- Adjust normalization (e.g., lowercase values) to your needs.\n- For non-string values, extend the signature to handle variants.\n- Duplicate keys after normalization will overwrite earlier entries; detect if that matters.", "category": "function_implementation", "language": "c++"}
{"prompt": "Implement a Java function to validate given an array of objects", "response": "java\n```java\nimport java.util.List;\nimport java.util.function.Predicate;\n\npublic class ObjectValidator {\n    /** Validate that all objects in the list satisfy the predicate. */\n    public static <T> boolean validateAll(List<T> items, Predicate<T> rule) {\n        if (items == null || rule == null) return false;\n        for (T item : items) {\n            if (item == null || !rule.test(item)) return false;\n        }\n        return true;\n    }\n}\n```\n**Explanation:** Iterates through the array/list of objects and applies a caller-supplied predicate; returns false on nulls or the first violation, true otherwise.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: items of Users, predicate `u -> u.age >= 18`\nOutput: true if all users are adults\n**Notes:**\n- Replace predicate with field checks if you want built-in validation.\n- Returns false on null inputs to avoid NullPointerExceptions.\n- Extend to collect error messages instead of a boolean for better UX.", "category": "function_implementation", "language": "java"}
{"prompt": "Implement a C++ function to summarize given a stream of log lines", "response": "c++\n```cpp\n#include <string>\n#include <vector>\n\nstruct LogStats {\n    size_t lines;\n    size_t errors;\n};\n\n// Summarize a stream of log lines: count total lines and those containing \"ERROR\".\nLogStats summarizeLogs(const std::vector<std::string>& lines) {\n    LogStats stats{0, 0};\n    for (const auto& line : lines) {\n        stats.lines++;\n        if (line.find(\"ERROR\") != std::string::npos) stats.errors++;\n    }\n    return stats;\n}\n```\n**Explanation:** Walks log lines once, counting total lines and those containing the substring \"ERROR\", returning the counts in a struct.\n**Complexity:** Time: O(total_chars); Space: O(1).\n**Example:**\nInput: [\"INFO started\", \"ERROR failed\"]\nOutput: {lines:2, errors:1}\n**Notes:**\n- Adjust matching (case-insensitive, regex) to your log format.\n- Extend stats with warnings, timestamps, etc., as needed.\n- Accept iterators/streams instead of a vector for large inputs.", "category": "function_implementation", "language": "c++"}
{"prompt": "Write a Rust function that computes the greatest common divisor (GCD)", "response": "rust\n```rust\npub fn gcd(mut a: i64, mut b: i64) -> i64 {\n    if a < 0 { a = -a; }\n    if b < 0 { b = -b; }\n    while b != 0 {\n        let tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n    a\n}\n```\n**Explanation:** Euclidean algorithm with absolute values to handle negatives. Iteratively replaces (a, b) with (b, a % b) until b becomes zero; the remaining a is the GCD.\n**Complexity:** Time: O(log min(a, b)); Space: O(1).\n**Example:**\nInput: gcd(54, 24)\nOutput: 6\n**Notes:**\n- If both inputs are zero, returns zero; define alternate behavior if needed.\n- Use `u64` if negatives are impossible.\n- Extend to compute LCM via `(a / gcd(a,b)) * b` with overflow checks.", "category": "function_implementation", "language": "rust"}
{"prompt": "Create a Java utility that generates paginated results from a collection with proper error handling", "response": "java\n```java\nimport java.util.List;\n\npublic class Paginator<T> {\n    public static class Page<T> {\n        public final List<T> items;\n        public final int page;\n        public final int totalPages;\n        public Page(List<T> items, int page, int totalPages) {\n            this.items = items; this.page = page; this.totalPages = totalPages;\n        }\n    }\n\n    public Page<T> paginate(List<T> items, int page, int pageSize) {\n        if (page <= 0 || pageSize <= 0) {\n            throw new IllegalArgumentException(\"page and pageSize must be positive\");\n        }\n        int total = items.size();\n        int totalPages = Math.max(1, (int) Math.ceil(total / (double) pageSize));\n        int current = Math.min(page, totalPages);\n        int start = (current - 1) * pageSize;\n        int end = Math.min(start + pageSize, total);\n        return new Page<>(items.subList(start, end), current, totalPages);\n    }\n}\n```\n**Explanation:** Validates inputs, computes total pages, clamps the requested page, slices the list for that window, and returns a Page object with metadata.\n**Complexity:** Time: O(k) to build the sublist view; Space: O(1) extra.\n**Example:**\nInput: items=[1,2,3,4,5], page=2, pageSize=2\nOutput: items=[3,4], page=2, totalPages=3\n**Notes:**\n- Throws on invalid page/pageSize; adjust to return empty results if preferred.\n- For very large data sets, paginate at the data source rather than slicing an in-memory list.\n- SubList is a view; modifying it affects the original list.", "category": "function_implementation", "language": "java"}
{"prompt": "Create a C# utility that retries HTTP requests with exponential backoff with proper error handling", "response": "csharp\n```csharp\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\npublic static class HttpRetrier\n{\n    public static async Task<string> GetWithBackoffAsync(string url, int maxRetries = 3, int baseDelayMs = 200)\n    {\n        using var client = new HttpClient { Timeout = TimeSpan.FromSeconds(10) };\n        for (int attempt = 0; attempt <= maxRetries; attempt++)\n        {\n            try\n            {\n                using var resp = await client.GetAsync(url);\n                resp.EnsureSuccessStatusCode();\n                return await resp.Content.ReadAsStringAsync();\n            }\n            catch (Exception ex) when (attempt < maxRetries)\n            {\n                int delay = baseDelayMs * (1 << attempt);\n                await Task.Delay(delay);\n            }\n        }\n        throw new HttpRequestException($\"Failed after {maxRetries + 1} attempts\");\n    }\n}\n```\n**Explanation:** Attempts an HTTP GET up to `maxRetries + 1` times, doubling the delay after each failure. Returns the response body on success or throws after exhausting retries. Uses `EnsureSuccessStatusCode` to retry on non-2xx responses.\n**Complexity:** Time: O(retries * request_time); Space: O(1) extra.\n**Example:**\nInput: await GetWithBackoffAsync(\"https://example.com\", 2)\nOutput: Response body string if successful\n**Notes:**\n- Add jitter to delays to avoid synchronized retries under load.\n- Narrow the catch filter to transient exceptions (e.g., HttpRequestException) as needed.\n- Dispose of HttpClient differently (pool) if making many calls.", "category": "function_implementation", "language": "c#"}
{"prompt": "Implement a Go function to filter given a list of numbers", "response": "go\n```go\npackage main\n\n// Filter returns a new slice containing elements that satisfy the predicate.\nfunc Filter(nums []int, keep func(int) bool) []int {\n    out := make([]int, 0, len(nums))\n    for _, n := range nums {\n        if keep(n) {\n            out = append(out, n)\n        }\n    }\n    return out\n}\n```\n**Explanation:** Iterates through the input slice, applies the predicate, and appends values that return true to a new slice, leaving the original untouched.\n**Complexity:** Time: O(n); Space: O(n) for the filtered slice.\n**Example:**\nInput: nums=[1,2,3,4], keep even\nOutput: [2,4]\n**Notes:**\n- Adjust predicate for different criteria (e.g., > threshold).\n- For in-place filtering, overwrite elements and reslice to avoid allocations.\n- Works with nil slices; returns an empty slice.", "category": "function_implementation", "language": "go"}
{"prompt": "Write a Python function that validates an email address", "response": "python\n```python\nimport re\n\nEMAIL_RE = re.compile(r\"^[\\w.+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$\")\n\ndef is_valid_email(s: str) -> bool:\n    if not isinstance(s, str):\n        return False\n    return EMAIL_RE.fullmatch(s.strip()) is not None\n```\n**Explanation:** Strips whitespace and applies a simple regex to check common email structure (local@domain.tld). Returns False for non-string input or mismatches.\n**Complexity:** Time: O(n); Space: O(1) auxiliary.\n**Example:**\nInput: \" user@example.com \"\nOutput: True\n**Notes:**\n- Regex is simplified; full RFC compliance is more complex.\n- Trim prevents leading/trailing spaces from causing false positives.\n- Use casefolding on the domain if you need case-insensitive comparison.", "category": "function_implementation", "language": "python"}
{"prompt": "Create a Python utility that retries HTTP requests with exponential backoff with proper error handling", "response": "python\n```python\nimport time\nimport requests\nfrom typing import Callable, Any\n\n\ndef retry_with_backoff(func: Callable[[], Any], retries: int = 3, base_delay: float = 0.5) -> Any:\n    \"\"\"Call func with exponential backoff on exceptions.\"\"\"\n    attempt = 0\n    while True:\n        try:\n            return func()\n        except Exception as exc:\n            attempt += 1\n            if attempt > retries:\n                raise\n            delay = base_delay * (2 ** (attempt - 1))\n            time.sleep(delay)\n```\n**Explanation:** Wraps a callable in a retry loop. On failure, waits with exponential backoff before retrying, raising the exception after exceeding the retry limit.\n**Complexity:** Time: O(retries * work); Space: O(1).\n**Example:**\nInput: `retry_with_backoff(lambda: requests.get(url, timeout=5).raise_for_status())`\nOutput: Returns the response if a retry succeeds; otherwise raises the last exception\n**Notes:**\n- Adjust `retries`/`base_delay` and add jitter to avoid thundering herds.\n- Catch specific exceptions (e.g., `requests.exceptions.RequestException`) instead of blanket `Exception` in production.\n- If func is stateful, ensure it is safe to retry.", "category": "function_implementation", "language": "python"}
{"prompt": "Implement a JavaScript function to filter given a stream of log lines", "response": "javascript\n```javascript\nfunction filterLogs(lines, predicate = () => true) {\n  const out = [];\n  for (const line of lines) {\n    if (!line || !line.trim()) continue;\n    if (predicate(line)) out.push(line);\n  }\n  return out;\n}\n```\n**Explanation:** Iterates stream lines, skips blanks, applies a predicate, and collects those that pass into a new array.\n**Complexity:** Time: O(n); Space: O(n) for filtered lines.\n**Example:**\nInput: lines=[\"INFO ok\", \"ERROR boom\"], predicate=line=>line.startsWith(\"ERROR\")\nOutput: [\"ERROR boom\"]\n**Notes:**\n- Replace predicate with structured parsing for richer filtering.\n- For streaming without full materialization, yield via a generator instead of building an array.\n- Trim or normalize lines as needed before testing.", "category": "function_implementation", "language": "javascript"}
{"prompt": "Write a Go function that generates a URL-friendly slug", "response": "go\n```go\npackage main\n\nimport (\n\t\"regexp\"\n\t\"strings\"\n)\n\nvar nonAlnum = regexp.MustCompile(`[^a-z0-9]+`)\n\nfunc Slugify(s string) string {\n\ts = strings.ToLower(strings.TrimSpace(s))\n\ts = nonAlnum.ReplaceAllString(s, \"-\")\n\ts = strings.Trim(s, \"-\")\n\treturn s\n}\n```\n**Explanation:** Lowercases the string, replaces non-alphanumeric runs with dashes, and trims leading/trailing dashes to produce a URL-friendly slug.\n**Complexity:** Time: O(n); Space: O(n).\n**Example:**\nInput: \"Hello, World!\"\nOutput: \"hello-world\"\n**Notes:**\n- Adjust regex to permit additional characters if needed.\n- Collapse multiple separators into a single dash via the regex replacement.\n- Ensure Unicode handling meets your requirements; this example is ASCII-focused.", "category": "function_implementation", "language": "go"}
{"prompt": "Implement a C++ function to process given an array of objects", "response": "c++\n```cpp\n#include <vector>\n#include <string>\n\nstruct Record { std::string msg; int level; };\n\n// Append a suffix to messages of all records\nstd::vector<Record> processRecords(const std::vector<Record>& records, const std::string& suffix) {\n    std::vector<Record> out;\n    out.reserve(records.size());\n    for (const auto& r : records) {\n        out.push_back(Record{r.msg + suffix, r.level});\n    }\n    return out;\n}\n```\n**Explanation:** Processes an array of objects (records) by copying them and appending a suffix to each message field, returning the transformed array.\n**Complexity:** Time: O(n * m) where m is avg message length; Space: O(n) for the output.\n**Example:**\nInput: [{msg:\"hi\", level:1}], suffix=\"!\"\nOutput: [{msg:\"hi!\", level:1}]\n**Notes:**\n- Adjust transformation to meet your domain needs (filtering, normalization, etc.).\n- Reserve space to avoid reallocations.\n- Keep immutable input; modify in place if allowed.", "category": "function_implementation", "language": "c++"}
{"prompt": "Write a Python function that sorts an array using quicksort", "response": "python\n```python\nfrom typing import List\n\ndef quicksort(arr: List[int]) -> None:\n    def sort(lo: int, hi: int) -> None:\n        if lo >= hi:\n            return\n        p = partition(lo, hi)\n        sort(lo, p - 1)\n        sort(p + 1, hi)\n\n    def partition(lo: int, hi: int) -> int:\n        pivot = arr[hi]\n        i = lo\n        for j in range(lo, hi):\n            if arr[j] <= pivot:\n                arr[i], arr[j] = arr[j], arr[i]\n                i += 1\n        arr[i], arr[hi] = arr[hi], arr[i]\n        return i\n\n    sort(0, len(arr) - 1)\n```\n**Explanation:** Lomuto partition quicksort: choose the last element as pivot, partition the subarray around it, and recursively sort left/right partitions.\n**Complexity:** Time: O(n log n) average, O(n²) worst; Space: O(log n) recursion.\n**Example:**\nInput: [3, 7, 2, 5]\nOutput: [2, 3, 5, 7]\n**Notes:**\n- Randomize pivot to mitigate worst cases on sorted input.\n- Not stable; equal elements may reorder.\n- Tail recursion optimization is not guaranteed in Python; for huge arrays, consider iterative quicksort or Timsort (built-in sorted).", "category": "function_implementation", "language": "python"}
{"prompt": "Create a Java utility that streams large files without loading into memory with proper error handling", "response": "java\n```java\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\npublic class Streamer {\n    public interface ChunkHandler { void handle(byte[] chunk, int len) throws IOException; }\n\n    public static void streamFile(Path path, int chunkSize, ChunkHandler handler) throws IOException {\n        try (InputStream in = Files.newInputStream(path)) {\n            byte[] buf = new byte[chunkSize];\n            int read;\n            while ((read = in.read(buf)) != -1) {\n                handler.handle(buf, read);\n            }\n        }\n    }\n}\n```\n**Explanation:** Opens a file as an InputStream and reads it in fixed-size chunks, invoking a handler for each chunk. Uses try-with-resources for cleanup and propagates IOExceptions.\n**Complexity:** Time: O(file_size); Space: O(chunk_size) buffer.\n**Example:**\nInput: streamFile(Path.of(\"data.bin\"), 8192, (buf,len) -> System.out.println(len))\nOutput: Prints sizes of each chunk read\n**Notes:**\n- Handler can write to network, compute hashes, etc.\n- Choose chunkSize based on performance requirements.\n- Add retries or throttling at call sites if needed.", "category": "function_implementation", "language": "java"}
{"prompt": "Implement a Rust function to validate given a stream of log lines", "response": "rust\n```rust\npub fn validate_logs(lines: &[String]) -> Result<(), String> {\n    for (idx, line) in lines.iter().enumerate() {\n        if line.trim().is_empty() {\n            return Err(format!(\"Line {} is empty\", idx));\n        }\n        if !line.contains(' ') {\n            return Err(format!(\"Line {} missing separators\", idx));\n        }\n    }\n    Ok(())\n}\n```\n**Explanation:** Performs simple validation over a stream of log lines: rejects empty/whitespace lines and those lacking at least one space (expecting at least timestamp and message). Returns a descriptive error on the first failure.\n**Complexity:** Time: O(n * m) over lines and lengths; Space: O(1).\n**Example:**\nInput: [\"2024-01-01 INFO started\"]\nOutput: Ok(())\n**Notes:**\n- Extend checks for timestamp format, level allowlist, etc.\n- Return a collection of all errors if you prefer aggregated reporting.\n- Accept an iterator instead of slice if logs are streamed.", "category": "function_implementation", "language": "rust"}
{"prompt": "Write a JavaScript function that flattens a nested list of numbers", "response": "javascript\n```javascript\nfunction flattenNested(list) {\n  const result = [];\n  (function dfs(node) {\n    if (Array.isArray(node)) {\n      for (const item of node) dfs(item);\n    } else {\n      result.push(Number(node));\n    }\n  })(list);\n  return result;\n}\n```\n**Explanation:** Depth-first recursion walks nested arrays; numbers (or coercible values) are pushed to the result. Arrays are expanded in order.\n**Complexity:** Time: O(n) elements; Space: O(n) for output plus recursion depth.\n**Example:**\nInput: [1, [2, [3]]]\nOutput: [1, 2, 3]\n**Notes:**\n- Replace recursion with a stack for very deep nesting.\n- Remove `Number()` coercion if non-numeric leaves should be preserved.\n- Maintains original order of elements.", "category": "function_implementation", "language": "javascript"}
{"prompt": "Implement a C++ function to aggregate given a string", "response": "c++\n```cpp\n#include <string>\n\n// Aggregate: count characters and return length of the string.\nint aggregateString(const std::string& s) {\n    return static_cast<int>(s.size());\n}\n```\n**Explanation:** Treats aggregation as computing the length of the input string; returns the number of characters.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: \"hello\"\nOutput: 5\n**Notes:**\n- Adjust aggregation to sum digits, count words, or other metrics as needed.\n- For UTF-8 length in code points, iterate with a decoder instead of `size()`.", "category": "function_implementation", "language": "c++"}
{"prompt": "Implement a Java function to aggregate given a string", "response": "java\n```java\npublic class StringAggregator {\n    public static int length(String s) {\n        if (s == null) throw new IllegalArgumentException(\"null string\");\n        return s.length();\n    }\n}\n```\n**Explanation:** Aggregates a string by returning its length, with a null check for safety.\n**Complexity:** Time: O(1) for length; Space: O(1).\n**Example:**\nInput: \"hello\"\nOutput: 5\n**Notes:**\n- Replace aggregation logic (e.g., count words, digits) as needed.\n- Throwing on null avoids ambiguous results; adjust to return 0 if preferred.\n- For Unicode grapheme counts, use BreakIterator instead of `length()`.", "category": "function_implementation", "language": "java"}
{"prompt": "Implement a JavaScript function to validate given a stream of log lines", "response": "javascript\n```javascript\n/** Validate that each log line has at least a timestamp and level token. */\nfunction validateLogStream(lines) {\n  return lines.every((line) => {\n    if (!line || !line.trim()) return false;\n    const parts = line.trim().split(/\\s+/, 3);\n    return parts.length >= 2;\n  });\n}\n```\n**Explanation:** Checks that every line is non-empty and splits into at least two tokens (timestamp and level). Returns true only if all lines meet the minimum structure.\n**Complexity:** Time: O(n * m) over lines and tokenization; Space: O(1) extra (excluding input).\n**Example:**\nInput: [\"2024-01-01 INFO started\", \"2024-01-01 WARN high load\"]\nOutput: true\n**Notes:**\n- Tighten validation by regex for timestamp/level formats.\n- Adjust required token count if messages can be empty.\n- Short-circuits on the first failing line.", "category": "function_implementation", "language": "javascript"}
{"prompt": "Implement a C++ function to process given a matrix", "response": "c++\n```cpp\n#include <vector>\n\n// Compute the sum of all elements in a 2D matrix.\nlong long sumMatrix(const std::vector<std::vector<int>>& mat) {\n    long long total = 0;\n    for (const auto& row : mat) {\n        for (int v : row) total += v;\n    }\n    return total;\n}\n```\n**Explanation:** Iterates rows and elements, accumulating a running sum of all entries in the matrix.\n**Complexity:** Time: O(r*c); Space: O(1) extra.\n**Example:**\nInput: [[1,2],[3,4]]\nOutput: 10\n**Notes:**\n- Adjust aggregation to compute min/max/average or other metrics.\n- Handles empty matrices naturally (returns 0).\n- Use larger integer types if sums may overflow int.", "category": "function_implementation", "language": "c++"}
{"prompt": "Create a C# utility that parses and validates configuration files with proper error handling", "response": "csharp\n```csharp\nusing System;\nusing System.IO;\nusing System.Text.Json;\n\npublic static class ConfigLoader\n{\n    public static T Load<T>(string path)\n    {\n        if (!File.Exists(path)) throw new FileNotFoundException(path);\n        var json = File.ReadAllText(path);\n        try\n        {\n            return JsonSerializer.Deserialize<T>(json, new JsonSerializerOptions { PropertyNameCaseInsensitive = true })\n                   ?? throw new InvalidOperationException(\"Deserialized to null\");\n        }\n        catch (JsonException ex)\n        {\n            throw new InvalidDataException(\"Invalid JSON\", ex);\n        }\n    }\n}\n```\n**Explanation:** Reads a JSON config file, deserializes into a typed object with case-insensitive property binding, and throws descriptive errors for missing files or parse failures.\n**Complexity:** Time: O(n) to read/parse; Space: O(n) for the JSON text/object.\n**Example:**\nInput: Config file `{ \"port\": 8080 }`, `Load<Config>(path)`\nOutput: Config instance with port set\n**Notes:**\n- Define the `Config` type with required properties; add validation after deserialization.\n- For large configs, stream the JSON with `JsonSerializer.DeserializeAsync`.\n- Catch and handle exceptions at the call site to surface user-friendly messages.", "category": "function_implementation", "language": "c#"}
{"prompt": "Implement a Go function to aggregate given a string", "response": "go\n```go\npackage main\n\n// Aggregate a string by returning its length.\nfunc AggregateString(s string) int {\n\treturn len(s)\n}\n```\n**Explanation:** Simple aggregation computing the byte-length of the input string.\n**Complexity:** Time: O(1) for len; Space: O(1).\n**Example:**\nInput: \"hello\"\nOutput: 5\n**Notes:**\n- For rune count, use utf8.RuneCountInString.\n- Adjust aggregation to suit your use case (word count, hashing, etc.).", "category": "function_implementation", "language": "go"}
{"prompt": "Create a Go utility that streams large files without loading into memory with proper error handling", "response": "go\n```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n// StreamFile reads a file in fixed-size chunks, yielding each chunk to the caller.\nfunc StreamFile(path string, chunkSize int, handle func([]byte) error) error {\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\tr := bufio.NewReader(f)\n\tbuf := make([]byte, chunkSize)\n\tfor {\n\t\tn, err := r.Read(buf)\n\t\tif n > 0 {\n\t\t\tif e := handle(buf[:n]); e != nil {\n\t\t\t\treturn e\n\t\t\t}\n\t\t}\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc main() {\n\thandle := func(chunk []byte) error {\n\t\tfmt.Printf(\"read %d bytes\\n\", len(chunk))\n\t\treturn nil\n\t}\n\t_ = StreamFile(\"/path/to/large.bin\", 8192, handle)\n}\n```\n**Explanation:** Opens the file, reads it in `chunkSize` blocks via a buffered reader, and invokes a callback for each chunk. This avoids loading the entire file into memory and propagates errors from reading or handling.\n**Complexity:** Time: O(file_size); Space: O(chunk_size).\n**Example:**\nInput: stream a 20KB file with chunkSize=8KB\nOutput: handler invoked 3 times (8KB, 8KB, 4KB)\n**Notes:**\n- Choose chunk size based on I/O patterns; larger chunks reduce syscall overhead.\n- Caller can stop early by returning an error from `handle`.\n- Wrap with retries or checksums if robustness is required for network filesystems.", "category": "function_implementation", "language": "go"}
{"prompt": "Write a JavaScript function that sorts an array using quicksort", "response": "javascript\n```javascript\nfunction quickSort(arr, lo = 0, hi = arr.length - 1) {\n  if (lo >= hi) return arr;\n  const p = partition(arr, lo, hi);\n  quickSort(arr, lo, p - 1);\n  quickSort(arr, p + 1, hi);\n  return arr;\n}\n\nfunction partition(arr, lo, hi) {\n  const pivot = arr[hi];\n  let i = lo;\n  for (let j = lo; j < hi; j++) {\n    if (arr[j] <= pivot) {\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n      i++;\n    }\n  }\n  [arr[i], arr[hi]] = [arr[hi], arr[i]];\n  return i;\n}\n```\n**Explanation:** In-place Lomuto partition quicksort. Recursively sorts subarrays around a pivot; partition ensures elements ≤ pivot are left of it.\n**Complexity:** Time: O(n log n) average, O(n²) worst; Space: O(log n) recursion.\n**Example:**\nInput: [3,1,4,1]\nOutput: [1,1,3,4]\n**Notes:**\n- Randomize pivot to mitigate worst case.\n- Not stable; equal elements may reorder.\n- Tail recursion not guaranteed; iterative conversion for huge arrays.", "category": "function_implementation", "language": "javascript"}
{"prompt": "Create a C# utility that generates paginated results from a collection with proper error handling", "response": "csharp\n```csharp\nusing System;\nusing System.Collections.Generic;\n\npublic static class Paginator\n{\n    public record Page<T>(IReadOnlyList<T> Items, int Page, int TotalPages);\n\n    public static Page<T> Paginate<T>(IReadOnlyList<T> items, int page, int pageSize)\n    {\n        if (page <= 0 || pageSize <= 0) throw new ArgumentException(\"page and pageSize must be positive\");\n        int total = items.Count;\n        int totalPages = Math.Max(1, (int)Math.Ceiling(total / (double)pageSize));\n        int current = Math.Min(page, totalPages);\n        int start = (current - 1) * pageSize;\n        int end = Math.Min(start + pageSize, total);\n        var slice = new List<T>();\n        for (int i = start; i < end; i++) slice.Add(items[i]);\n        return new Page<T>(slice, current, totalPages);\n    }\n}\n```\n**Explanation:** Validates inputs, computes total pages, clamps the requested page, slices the input into a new list for that page, and returns pagination metadata.\n**Complexity:** Time: O(k) for copying page items; Space: O(k) for the slice.\n**Example:**\nInput: items [1,2,3,4,5], page=2, pageSize=2\nOutput: Page(items=[3,4], page=2, totalPages=3)\n**Notes:**\n- Throws on invalid arguments; adjust to return an empty page if preferred.\n- For very large datasets, paginate at the data source rather than copying in memory.\n- Slice is a copy; modifications don’t affect the original list.", "category": "function_implementation", "language": "c#"}
{"prompt": "Implement a Rust function to aggregate given a string", "response": "rust\n```rust\npub fn aggregate_string(s: &str) -> usize {\n    s.chars().count()\n}\n```\n**Explanation:** Aggregates a string by returning its character count (Unicode scalar values).\n**Complexity:** Time: O(n) over characters; Space: O(1).\n**Example:**\nInput: \"hello\"\nOutput: 5\n**Notes:**\n- Use `s.len()` for byte length instead.\n- Adjust to aggregate differently (e.g., count words or digits) as needed.\n- Counting grapheme clusters requires a more advanced iterator (e.g., unicode-segmentation crate).", "category": "function_implementation", "language": "rust"}
{"prompt": "Create a JavaScript utility that retries HTTP requests with exponential backoff with proper error handling", "response": "javascript\n```javascript\n// Retry an async function with exponential backoff\nasync function retryWithBackoff(fn, retries = 3, baseDelayMs = 200) {\n  for (let attempt = 0; attempt <= retries; attempt++) {\n    try {\n      return await fn();\n    } catch (err) {\n      if (attempt === retries) throw err;\n      const delay = baseDelayMs * Math.pow(2, attempt);\n      await new Promise(res => setTimeout(res, delay));\n    }\n  }\n}\n```\n**Explanation:** Wraps an async operation in a retry loop, doubling the delay after each failure. Returns on the first success or rethrows after exhausting attempts.\n**Complexity:** Time: O(retries * fn_time); Space: O(1).\n**Example:**\nInput: `retryWithBackoff(() => fetch(url).then(r => r.json()))`\nOutput: JSON response or thrown error after retries\n**Notes:**\n- Add jitter to delays to avoid synchronized retries under load.\n- Filter retryable errors/status codes within `fn` or around this wrapper.\n- For idempotent operations; avoid retrying non-idempotent side effects.", "category": "function_implementation", "language": "javascript"}
{"prompt": "Write a Rust function that checks if a string is a palindrome", "response": "rust\n```rust\npub fn is_palindrome(s: &str) -> bool {\n    let cleaned: Vec<char> = s.chars().filter(|c| c.is_alphanumeric()).map(|c| c.to_lowercase().next().unwrap()).collect();\n    let mut i = 0usize;\n    let mut j = cleaned.len().saturating_sub(1);\n    while i < j {\n        if cleaned[i] != cleaned[j] { return false; }\n        i += 1;\n        j -= 1;\n    }\n    true\n}\n```\n**Explanation:** Normalizes the string by keeping alphanumerics and lowercasing, then uses two pointers to compare characters from both ends, returning false on first mismatch.\n**Complexity:** Time: O(n); Space: O(n) for the cleaned vector.\n**Example:**\nInput: \"RaceCar!\"\nOutput: true\n**Notes:**\n- For byte-based palindromes, skip normalization and operate on bytes.\n- `to_lowercase` may yield multiple chars for some Unicode; using `.next().unwrap()` suffices for basic Latin; use full iterator for complete support.\n- Handles empty strings as palindromes.", "category": "function_implementation", "language": "rust"}
{"prompt": "Create a Java utility that retries HTTP requests with exponential backoff with proper error handling", "response": "java\n```java\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\n\npublic class HttpRetrier {\n    private final HttpClient client = HttpClient.newHttpClient();\n\n    public HttpResponse<String> getWithBackoff(String url, int maxRetries) throws Exception {\n        int attempt = 0;\n        while (true) {\n            try {\n                HttpRequest req = HttpRequest.newBuilder(URI.create(url)).GET().build();\n                return client.send(req, HttpResponse.BodyHandlers.ofString());\n            } catch (Exception ex) {\n                if (++attempt > maxRetries) throw ex;\n                long delay = Math.min(1000L * (1L << (attempt - 1)), 8000L);\n                Thread.sleep(delay);\n            }\n        }\n    }\n}\n```\n**Explanation:** Wraps an HTTP GET in a retry loop with exponential backoff. On failure, waits (capped) before retrying, up to `maxRetries`, then rethrows the last exception.\n**Complexity:** Time: O(retries * request_time); Space: O(1).\n**Example:**\nInput: new HttpRetrier().getWithBackoff(\"https://example.com\", 3)\nOutput: HTTP response body (or exception after retries)\n**Notes:**\n- Add jitter to avoid synchronized retries under load.\n- Restrict retryable exceptions/status codes per your policy.\n- Consider async `sendAsync` if you need non-blocking behavior.", "category": "function_implementation", "language": "java"}
{"prompt": "Write a Java function that checks if a string is a palindrome", "response": "java\n```java\npublic class PalindromeChecker {\n    public static boolean isPalindrome(String s) {\n        if (s == null) return false;\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            if (s.charAt(i) != s.charAt(j)) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}\n```\n**Explanation:** Two-pointer comparison from both ends of the string; returns false on first mismatch, true if all pairs match.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: \"level\"\nOutput: true\n**Notes:**\n- Case-sensitive; add normalization if needed.\n- For ignoring non-alphanumerics, skip them within the loop.\n- Returns false on null to avoid ambiguity; adjust to throw if preferred.", "category": "function_implementation", "language": "java"}
{"prompt": "Implement a C++ function to summarize given a list of numbers", "response": "c++\n```cpp\n#include <vector>\n\nlong long sumList(const std::vector<int>& nums) {\n    long long total = 0;\n    for (int v : nums) total += v;\n    return total;\n}\n```\n**Explanation:** Iterates through the list and accumulates the sum in a 64-bit accumulator.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: [1,2,3]\nOutput: 6\n**Notes:**\n- Use `std::accumulate` for brevity.\n- Switch to a larger type or arbitrary-precision if overflow is a concern.\n- Extend to compute min/max/average as needed.", "category": "function_implementation", "language": "c++"}
{"prompt": "Write Java code to make an HTTP GET request and parse JSON", "response": "java\n```java\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class HttpJsonFetcher {\n    private static final HttpClient CLIENT = HttpClient.newHttpClient();\n    private static final ObjectMapper MAPPER = new ObjectMapper();\n\n    public static JsonNode getJson(String url) throws IOException, InterruptedException {\n        HttpRequest request = HttpRequest.newBuilder(URI.create(url))\n                .GET()\n                .header(\"Accept\", \"application/json\")\n                .build();\n\n        HttpResponse<String> response = CLIENT.send(request, HttpResponse.BodyHandlers.ofString());\n        if (response.statusCode() / 100 != 2) {\n            throw new IOException(\"HTTP error: \" + response.statusCode());\n        }\n        return MAPPER.readTree(response.body());\n    }\n\n    public static void main(String[] args) throws Exception {\n        JsonNode json = getJson(\"https://api.github.com\");\n        System.out.println(json.get(\"current_user_url\"));\n    }\n}\n```\n**Explanation:** Builds an `HttpClient` request, sends it, checks for a 2xx status, and parses the response body into a Jackson `JsonNode` for easy JSON traversal.\n**Complexity:** Time: O(response_size); Space: O(response_size) to hold the body/parsed tree.\n**Example:**\nInput: URL `https://api.github.com`\nOutput: Parsed JSON node containing fields like `current_user_url`.\n**Notes:**\n- Requires Jackson (`com.fasterxml.jackson.core:jackson-databind`) on the classpath.\n- Add timeouts/auth headers as needed; handle redirects per policy.\n- For large payloads, stream via `BodyHandlers.ofInputStream()` and incremental parsing.", "category": "real_world", "language": "java"}
{"prompt": "Write Java code to implement a CLI tool with subcommands", "response": "java\n```java\nimport java.util.Scanner;\n\npublic class CliTool {\n    public static void main(String[] args) {\n        if (args.length == 0) {\n            printHelp();\n            return;\n        }\n        String cmd = args[0];\n        switch (cmd) {\n            case \"greet\" -> greet(args);\n            case \"sum\" -> sum(args);\n            default -> {\n                System.err.println(\"Unknown command: \" + cmd);\n                printHelp();\n            }\n        }\n    }\n\n    private static void greet(String[] args) {\n        if (args.length < 2) {\n            System.err.println(\"Usage: greet <name>\");\n            return;\n        }\n        System.out.println(\"Hello, \" + args[1] + \"!\");\n    }\n\n    private static void sum(String[] args) {\n        if (args.length < 3) {\n            System.err.println(\"Usage: sum <a> <b>\");\n            return;\n        }\n        int a = Integer.parseInt(args[1]);\n        int b = Integer.parseInt(args[2]);\n        System.out.println(a + b);\n    }\n\n    private static void printHelp() {\n        System.out.println(\"Commands: greet <name> | sum <a> <b>\");\n    }\n}\n```\n**Explanation:** Simple Java CLI: first argument selects a subcommand (`greet` or `sum`), subsequent arguments are parsed per command. Errors print usage hints.\n**Complexity:** Time: O(1); Space: O(1).\n**Example:**\nInput: `java CliTool sum 2 5`\nOutput: `7`\n**Notes:**\n- For richer CLIs, use libraries like picocli or Commons CLI.\n- Validate number parsing to handle `NumberFormatException` gracefully.\n- Extend `switch` with more subcommands as needed.", "category": "real_world", "language": "java"}
{"prompt": "Write Python code to implement a CLI tool with subcommands", "response": "python\n```python\nimport argparse\nimport sys\n\n\ndef build_parser() -> argparse.ArgumentParser:\n    parser = argparse.ArgumentParser(description=\"Demo CLI with subcommands\")\n    sub = parser.add_subparsers(dest=\"command\", required=True)\n\n    greet = sub.add_parser(\"greet\", help=\"Greet a user\")\n    greet.add_argument(\"name\", help=\"Name to greet\")\n\n    add = sub.add_parser(\"add\", help=\"Add two integers\")\n    add.add_argument(\"a\", type=int)\n    add.add_argument(\"b\", type=int)\n\n    return parser\n\n\ndef main(argv: list[str] | None = None) -> int:\n    args = build_parser().parse_args(argv)\n    if args.command == \"greet\":\n        print(f\"Hello, {args.name}!\")\n    elif args.command == \"add\":\n        print(args.a + args.b)\n    return 0\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    sys.exit(main())\n```\n**Explanation:** Uses `argparse` to define two subcommands: `greet` (prints a greeting) and `add` (adds two integers). `main` parses arguments and dispatches to the requested subcommand.\n**Complexity:** Time: O(1) for parsing small CLIs; Space: O(1).\n**Example:**\nInput: `python tool.py add 2 3`\nOutput: `5`\n**Notes:**\n- Extend with more subcommands by adding to the parser.\n- `required=True` forces a subcommand; remove for default behavior.\n- Return non-zero exit codes on errors to integrate with scripts.", "category": "real_world", "language": "python"}
{"prompt": "Write JavaScript code to handle exceptions gracefully", "response": "javascript\n```javascript\nasync function runTask() {\n  try {\n    const result = await riskyOperation();\n    console.log('Success:', result);\n  } catch (err) {\n    console.error('Operation failed', err);\n    // optional retry or fallback\n  } finally {\n    console.log('Cleanup goes here');\n  }\n}\n\nasync function riskyOperation() {\n  // placeholder for real work\n  return 'ok';\n}\n```\n**Explanation:** Wraps an async operation in try/catch/finally to log failures, optionally retry, and perform cleanup. Keeps error propagation explicit.\n**Complexity:** Time/Space: O(1) overhead around the wrapped call.\n**Example:**\nInput: call `runTask()`\nOutput: Logs either success or failure and runs cleanup.\n**Notes:**\n- Add specific error handling branches (network vs validation).\n- Re-throw after logging if upstream callers must handle the error.\n- For sync code, omit `await`/`async` and use plain try/catch.", "category": "real_world", "language": "javascript"}
{"prompt": "Write Java code to validate user input", "response": "java\n```java\nimport java.util.regex.Pattern;\n\npublic class InputValidator {\n    private static final Pattern EMAIL = Pattern.compile(\"^[\\\\w.+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$\");\n\n    public static boolean validateEmail(String s) {\n        return s != null && EMAIL.matcher(s.trim()).matches();\n    }\n\n    public static boolean validateLength(String s, int min, int max) {\n        if (s == null) return false;\n        int len = s.trim().length();\n        return len >= min && len <= max;\n    }\n}\n```\n**Explanation:** Provides reusable validation helpers: email pattern check and length bounds. Strings are trimmed before evaluation to avoid spurious whitespace issues.\n**Complexity:** Time: O(n) for regex/length; Space: O(1).\n**Example:**\nInput: validateEmail(\" user@example.com \")\nOutput: true\n**Notes:**\n- Add domain-specific rules (blocked words, profanity) as needed.\n- Prefer `Pattern` reuse to avoid recompilation costs.\n- Throw descriptive exceptions instead of booleans if you need error messages.", "category": "real_world", "language": "java"}
{"prompt": "Write Java code to stream large uploads with retry support", "response": "java\n```java\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpRequest.BodyPublishers;\n\npublic class Uploader {\n    private static final HttpClient CLIENT = HttpClient.newHttpClient();\n\n    public static HttpResponse<String> uploadWithRetry(String url, String filePath, int maxRetries) throws IOException, InterruptedException {\n        int attempt = 0;\n        while (true) {\n            try (FileInputStream fis = new FileInputStream(filePath)) {\n                HttpRequest req = HttpRequest.newBuilder(URI.create(url))\n                        .POST(BodyPublishers.ofInputStream(() -> fis))\n                        .header(\"Content-Type\", \"application/octet-stream\")\n                        .build();\n                return CLIENT.send(req, HttpResponse.BodyHandlers.ofString());\n            } catch (IOException e) {\n                if (++attempt > maxRetries) throw e;\n                Thread.sleep((long) Math.min(1000 * Math.pow(2, attempt), 8000));\n            }\n        }\n    }\n}\n```\n**Explanation:** Opens the file as a stream, posts it via `HttpClient`, and retries with exponential backoff on I/O failures up to `maxRetries`. Each attempt reopens the stream to start fresh.\n**Complexity:** Time: O(file_size) per attempt; Space: O(1) extra.\n**Example:**\nInput: uploadWithRetry(\"https://example.com/upload\", \"data.bin\", 3)\nOutput: HTTP response or thrown after retries\n**Notes:**\n- Add specific retryable status checks (e.g., 5xx) if desired; this example retries only on IO exceptions.\n- For very large files, consider multipart uploads or resumable protocols.\n- Tune backoff and maximum sleep to your reliability requirements.", "category": "real_world", "language": "java"}
{"prompt": "Write JavaScript code to create a REST API endpoint", "response": "javascript\n```javascript\nimport { Client } from 'pg';\n\nexport async function runQuery() {\n  const client = new Client({\n    connectionString: process.env.DATABASE_URL,\n  });\n  await client.connect();\n  try {\n    const res = await client.query('SELECT id, name FROM users WHERE active = $1', [true]);\n    return res.rows;\n  } finally {\n    await client.end();\n  }\n}\n```\n**Explanation:** Uses `node-postgres` to connect with a connection string, executes a parameterized query, and returns the result rows. Ensures the client closes in a `finally` block.\n**Complexity:** Time: O(n) over returned rows; Space: O(n) for loaded results.\n**Example:**\nInput: `await runQuery()`\nOutput: Array of active user records\n**Notes:**\n- Install dependency: `npm install pg`.\n- Prefer pooled clients (`Pool`) for repeated queries.\n- Handle errors with try/catch around the call site for logging or retries.", "category": "real_world", "language": "javascript"}
{"prompt": "Write JavaScript code to read a CSV file and calculate statistics", "response": "javascript\n```javascript\nimport fs from 'fs';\nimport readline from 'readline';\n\n// Read a CSV file of numeric values (one row) and compute min/avg/max\nexport async function csvStats(path) {\n  const stream = fs.createReadStream(path);\n  const rl = readline.createInterface({ input: stream, crlfDelay: Infinity });\n  let min = Infinity, max = -Infinity, sum = 0, count = 0;\n\n  for await (const line of rl) {\n    const values = line.split(',').map(Number);\n    for (const v of values) {\n      if (Number.isNaN(v)) continue;\n      min = Math.min(min, v);\n      max = Math.max(max, v);\n      sum += v;\n      count++;\n    }\n  }\n  return {\n    min,\n    max,\n    average: count ? sum / count : 0,\n    count,\n  };\n}\n```\n**Explanation:** Streams the CSV file line by line to avoid loading it all at once, parses comma-separated numbers, and updates running min/max/sum/count, returning aggregate statistics.\n**Complexity:** Time: O(n) over values; Space: O(1) extra.\n**Example:**\nInput: file containing `1,2,3\\n4,5`\nOutput: {min:1, max:5, average:3, count:5}\n**Notes:**\n- Assumes simple numeric CSV; use a parser like `csv-parse` for quoted fields.\n- Skip NaN values; handle errors for malformed rows as needed.\n- For very large files, tune stream highWaterMark for performance.", "category": "real_world", "language": "javascript"}
{"prompt": "Write JavaScript code to connect to a database and run a query", "response": "javascript\n```javascript\nimport mysql from 'mysql2/promise';\n\nexport async function fetchUsers() {\n  const conn = await mysql.createConnection({\n    host: 'localhost', user: 'user', password: 'pass', database: 'app'\n  });\n  try {\n    const [rows] = await conn.execute('SELECT id, name FROM users WHERE active = ?', [1]);\n    return rows;\n  } finally {\n    await conn.end();\n  }\n}\n```\n**Explanation:** Opens a MySQL connection using `mysql2/promise`, runs a parameterized query, returns the result set, and closes the connection in a `finally` block.\n**Complexity:** Time: O(n) over returned rows; Space: O(n) to hold them.\n**Example:**\nInput: `await fetchUsers()`\nOutput: Array of user records\n**Notes:**\n- Install dependency: `npm install mysql2`.\n- Use pooled connections (`createPool`) for higher throughput.\n- Handle errors at the call site for logging/retries.", "category": "real_world", "language": "javascript"}
{"prompt": "Write JavaScript code to validate user input", "response": "javascript\n```javascript\nexport function validateInput(value, { min = 1, max = 100, pattern } = {}) {\n  if (typeof value !== 'string') return { valid: false, error: 'must be a string' };\n  const trimmed = value.trim();\n  if (trimmed.length < min) return { valid: false, error: `min length ${min}` };\n  if (trimmed.length > max) return { valid: false, error: `max length ${max}` };\n  if (pattern && !pattern.test(trimmed)) return { valid: false, error: 'pattern mismatch' };\n  return { valid: true, value: trimmed };\n}\n```\n**Explanation:** Normalizes the input by trimming, enforces length bounds, and optionally checks a regex. Returns a result object with validity and either the cleaned value or an error message.\n**Complexity:** Time: O(n) for length/pattern checks; Space: O(1).\n**Example:**\nInput: validateInput(\" user@example.com \", { pattern: /^[\\w.+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$/ })\nOutput: { valid: true, value: 'user@example.com' }\n**Notes:**\n- Expand with domain-specific checks (blocked words, profanity, etc.).\n- Run validation on both client and server to maintain integrity.\n- Provide field-specific defaults for min/max as needed.", "category": "real_world", "language": "javascript"}
{"prompt": "Write Python code to handle exceptions gracefully", "response": "python\n```python\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\ndef run_task():\n    try:\n        result = risky_operation()\n        logger.info(\"Success: %s\", result)\n        return result\n    except Exception as exc:  # catch specific exceptions in real code\n        logger.exception(\"Task failed\")\n        # optionally retry or re-raise\n        raise\n    finally:\n        logger.debug(\"Cleanup done\")\n```\n**Explanation:** Wraps work in try/except/finally, logging successes, failures, and cleanup. Exceptions are logged with stack traces and re-raised to propagate failure.\n**Complexity:** Time/Space overhead: O(1) around the wrapped call.\n**Example:**\nInput: call `run_task()` when `risky_operation` raises ValueError\nOutput: Logs stack trace via logger and re-raises the error\n**Notes:**\n- Replace broad `Exception` with specific ones to avoid masking bugs.\n- Use retries/backoff around transient failures if appropriate.\n- Configure logging handlers/levels elsewhere (e.g., basicConfig).", "category": "real_world", "language": "python"}
{"prompt": "Write Java code to schedule recurring background tasks", "response": "java\n```java\nimport java.time.Duration;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\npublic class Scheduler {\n    private final ScheduledExecutorService exec = Executors.newScheduledThreadPool(1);\n\n    public void scheduleAtFixedRate(Runnable task, Duration initialDelay, Duration period) {\n        exec.scheduleAtFixedRate(task, initialDelay.toMillis(), period.toMillis(), TimeUnit.MILLISECONDS);\n    }\n\n    public void shutdown() {\n        exec.shutdown();\n    }\n\n    public static void main(String[] args) {\n        Scheduler scheduler = new Scheduler();\n        scheduler.scheduleAtFixedRate(() -> System.out.println(\"tick\"), Duration.ZERO, Duration.ofSeconds(5));\n    }\n}\n```\n**Explanation:** Uses a `ScheduledExecutorService` to run a task on a fixed schedule with an initial delay. Provides a shutdown method for cleanup.\n**Complexity:** Time: O(1) scheduling overhead; Space: O(1) plus thread resources.\n**Example:**\nInput: schedule a task every 5 seconds\nOutput: prints \"tick\" every 5 seconds\n**Notes:**\n- Handle interruptions and task exceptions; by default, exceptions can cancel future runs.\n- Adjust thread pool size based on number of concurrent tasks.\n- Call `shutdown()` on application exit to release threads.", "category": "real_world", "language": "java"}
{"prompt": "Write JavaScript code to create a simple web scraper", "response": "javascript\n```javascript\nimport fetch from 'node-fetch';\nimport { load } from 'cheerio';\n\n// Fetch a page and return all absolute hrefs\nexport async function scrapeLinks(url) {\n  const resp = await fetch(url, { timeout: 10000 });\n  if (!resp.ok) throw new Error(`HTTP ${resp.status}`);\n  const html = await resp.text();\n  const $ = load(html);\n  const links = [];\n  $('a[href]').each((_, el) => {\n    const href = $(el).attr('href');\n    if (href) links.push(href);\n  });\n  return links;\n}\n```\n**Explanation:** Downloads HTML with `fetch`, parses it with Cheerio (server-side jQuery), selects all anchor tags with `href`, and collects their URLs into an array.\n**Complexity:** Time: O(page_size + links); Space: O(page_size) for parsed DOM.\n**Example:**\nInput: `scrapeLinks('https://example.com')`\nOutput: `[\"https://www.iana.org/domains/example\"]`\n**Notes:**\n- Install deps: `npm install node-fetch cheerio`.\n- Normalize relative URLs (e.g., with WHATWG URL) if you need absolute links.\n- Respect robots.txt and rate limits when scraping.", "category": "real_world", "language": "javascript"}
{"prompt": "Write Java code to connect to a database and run a query", "response": "java\n```java\nimport java.sql.*;\n\npublic class DbQueryExample {\n    public static void main(String[] args) throws Exception {\n        String url = \"jdbc:postgresql://localhost:5432/mydb\";\n        String user = \"user\";\n        String pass = \"password\";\n        String sql = \"SELECT id, name FROM users WHERE active = ?\";\n\n        try (Connection conn = DriverManager.getConnection(url, user, pass);\n             PreparedStatement ps = conn.prepareStatement(sql)) {\n            ps.setBoolean(1, true);\n            try (ResultSet rs = ps.executeQuery()) {\n                while (rs.next()) {\n                    System.out.printf(\"%d %s%n\", rs.getInt(\"id\"), rs.getString(\"name\"));\n                }\n            }\n        }\n    }\n}\n```\n**Explanation:** Opens a JDBC connection, prepares a parameterized query, executes it, and iterates the `ResultSet`. Resources are closed automatically via try-with-resources.\n**Complexity:** Time: O(n) over returned rows; Space: O(1) aside from driver buffers.\n**Example:**\nInput: active users in DB\nOutput: Printed rows like `1 Alice`\n**Notes:**\n- Ensure the JDBC driver is on the classpath (e.g., PostgreSQL driver).\n- Use connection pools (HikariCP) and externalized credentials in production.\n- Always parameterize queries to avoid SQL injection.", "category": "real_world", "language": "java"}
{"prompt": "Write JavaScript code to implement a CLI tool with subcommands", "response": "javascript\n```javascript\nimport { program } from 'commander';\n\nprogram\n  .name('demo')\n  .description('Example CLI with subcommands');\n\nprogram\n  .command('greet <name>')\n  .description('Greet a user')\n  .action((name) => {\n    console.log(`Hello, ${name}!`);\n  });\n\nprogram\n  .command('add <a> <b>')\n  .description('Add two numbers')\n  .action((a, b) => {\n    const sum = Number(a) + Number(b);\n    if (Number.isNaN(sum)) {\n      console.error('Arguments must be numbers');\n      process.exitCode = 1;\n      return;\n    }\n    console.log(sum);\n  });\n\nprogram.parse(process.argv);\n```\n**Explanation:** Uses Commander to define two subcommands (`greet` and `add`), each with arguments and handlers. Parsing `process.argv` dispatches to the appropriate action with basic validation.\n**Complexity:** Time: O(1) parse overhead for small CLIs; Space: O(1).\n**Example:**\nInput: `node cli.js add 2 3`\nOutput: `5`\n**Notes:**\n- Install Commander: `npm install commander`.\n- Add error handling and more subcommands as needed.\n- For ESM/CommonJS compatibility, adjust import syntax per environment.", "category": "real_world", "language": "javascript"}
{"prompt": "Write JavaScript code to implement logging", "response": "javascript\n```javascript\nimport fs from 'fs';\n\nclass Logger {\n  constructor(logFile = null) {\n    this.logFile = logFile;\n  }\n  log(level, message, meta = {}) {\n    const entry = { ts: new Date().toISOString(), level, message, ...meta };\n    const line = JSON.stringify(entry);\n    console.log(line);\n    if (this.logFile) fs.appendFileSync(this.logFile, line + '\\n');\n  }\n  info(msg, meta) { this.log('INFO', msg, meta); }\n  warn(msg, meta) { this.log('WARN', msg, meta); }\n  error(msg, meta) { this.log('ERROR', msg, meta); }\n}\n```\n**Explanation:** Simple structured logger that prints JSON lines to stdout and optionally appends to a file. Provides convenience methods for common levels.\n**Complexity:** Time: O(1) per call (plus I/O); Space: O(1).\n**Example:**\nInput: `const logger = new Logger('app.log'); logger.info('started', {pid: process.pid});`\nOutput: Logs a JSON line to console and file.\n**Notes:**\n- For async performance, switch to non-blocking `appendFile` or use a dedicated logging library like pino/winston.\n- Add rotation to avoid unbounded file growth.\n- Ensure log directory exists before writing.", "category": "real_world", "language": "javascript"}
{"prompt": "Write JavaScript code to parse command-line arguments", "response": "javascript\n```javascript\nimport minimist from 'minimist';\n\nexport function parseArgs(argv = process.argv.slice(2)) {\n  const args = minimist(argv, {\n    string: ['name'],\n    boolean: ['verbose'],\n    alias: { n: 'name', v: 'verbose' },\n    default: { verbose: false },\n  });\n  return args;\n}\n```\n**Explanation:** Uses `minimist` to parse command-line arguments, setting up aliases and defaults. Returns the parsed args object for further processing.\n**Complexity:** Time: O(n) over arguments; Space: O(n) for parsed structure.\n**Example:**\nInput: `node app.js --name Alice -v`\nOutput: `{ _: [], name: 'Alice', verbose: true }`\n**Notes:**\n- Install with `npm install minimist`.\n- Add validation for required flags or value types as needed.\n- For subcommands or richer schemas, consider Commander or yargs.", "category": "real_world", "language": "javascript"}
{"prompt": "Write Java code to create a REST API endpoint", "response": "java\n```java\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"/api\")\npublic class HelloController {\n\n    @GetMapping(\"/hello\")\n    public Message hello() {\n        return new Message(\"Hello, world\");\n    }\n\n    public record Message(String message) {}\n}\n```\n**Explanation:** Defines a Spring REST controller with a `/api/hello` GET endpoint that returns a JSON message. Uses a record for the response payload.\n**Complexity:** Time: O(1); Space: O(1) beyond framework overhead.\n**Example:**\nInput: GET /api/hello\nOutput: {\"message\":\"Hello, world\"}\n**Notes:**\n- Requires Spring Web dependency and appropriate application bootstrap.\n- Add validation/authentication as needed for real endpoints.\n- Change mappings to fit your routing conventions.", "category": "real_world", "language": "java"}
{"prompt": "Write Python code to validate user input", "response": "python\n```python\nimport re\nfrom typing import Tuple, Optional, Pattern\n\ndef validate_input(value: str, *, min_len: int = 1, max_len: int = 100, pattern: Optional[Pattern[str]] = None) -> Tuple[bool, str]:\n    if not isinstance(value, str):\n        return False, \"must be a string\"\n    trimmed = value.strip()\n    if len(trimmed) < min_len:\n        return False, f\"min length {min_len}\"\n    if len(trimmed) > max_len:\n        return False, f\"max length {max_len}\"\n    if pattern and not pattern.fullmatch(trimmed):\n        return False, \"pattern mismatch\"\n    return True, trimmed\n```\n**Explanation:** Trims whitespace, enforces length bounds, optionally checks a regex, and returns a boolean plus either the cleaned value or an error message.\n**Complexity:** Time: O(n); Space: O(1).\n**Example:**\nInput: validate_input(\" user@example.com \", pattern=re.compile(r\"^[\\w.+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$\"))\nOutput: (True, \"user@example.com\")\n**Notes:**\n- Swap `fullmatch` for `search` if you want substring matches.\n- Adjust defaults per field requirements.\n- For multiple validations, compose error messages rather than returning early.", "category": "real_world", "language": "python"}
{"prompt": "Write Python code to make an HTTP GET request and parse JSON", "response": "python\n```python\nimport requests\n\ndef fetch_json(url: str, timeout: float = 10.0) -> dict:\n    resp = requests.get(url, timeout=timeout)\n    resp.raise_for_status()\n    return resp.json()\n```\n**Explanation:** Issues an HTTP GET with a configurable timeout, raises on non-2xx responses, and parses the body as JSON, returning the decoded Python object.\n**Complexity:** Time: O(response_size); Space: O(response_size) for the parsed JSON.\n**Example:**\nInput: fetch_json(\"https://api.github.com\")\nOutput: Dict containing GitHub API metadata\n**Notes:**\n- Catch `requests.exceptions.RequestException` at call sites for retries/logging.\n- For large bodies, stream and incrementally parse instead of loading fully.\n- Ensure `requests` is installed in the environment.", "category": "real_world", "language": "python"}
{"prompt": "Write Java code to parse command-line arguments", "response": "java\n```java\nimport java.util.Arrays;\n\npublic class CliArgs {\n    public static void main(String[] args) {\n        if (args.length == 0) {\n            System.out.println(\"Usage: --name <value> [--verbose]\");\n            return;\n        }\n        String name = null; boolean verbose = false;\n        for (int i = 0; i < args.length; i++) {\n            switch (args[i]) {\n                case \"--name\" -> {\n                    if (i + 1 >= args.length) throw new IllegalArgumentException(\"--name requires a value\");\n                    name = args[++i];\n                }\n                case \"--verbose\" -> verbose = true;\n                default -> throw new IllegalArgumentException(\"Unknown flag: \" + args[i]);\n            }\n        }\n        System.out.printf(\"name=%s verbose=%b%n\", name, verbose);\n    }\n}\n```\n**Explanation:** Minimal CLI parser: scans argv for `--name` (expects a following value) and `--verbose` flag, handling errors for unknown flags or missing values, then prints parsed results.\n**Complexity:** Time: O(n) over arguments; Space: O(1).\n**Example:**\nInput: `java CliArgs --name Alice --verbose`\nOutput: `name=Alice verbose=true`\n**Notes:**\n- For richer CLIs, use a library like picocli.\n- Add default values and required-field checks as appropriate.\n- Expand switch with more flags or subcommands as needed.", "category": "real_world", "language": "java"}
{"prompt": "Write JavaScript code to make an HTTP GET request and parse JSON", "response": "javascript\n```javascript\nimport fetch from 'node-fetch';\n\nexport async function fetchJson(url) {\n  const resp = await fetch(url, { timeout: 10000 });\n  if (!resp.ok) throw new Error(`HTTP ${resp.status}`);\n  return resp.json();\n}\n```\n**Explanation:** Performs an HTTP GET with a 10s timeout, checks for a 2xx response, and parses the body as JSON, returning the decoded object.\n**Complexity:** Time: O(response_size); Space: O(response_size).\n**Example:**\nInput: `await fetchJson('https://api.github.com')`\nOutput: Parsed JSON payload\n**Notes:**\n- Install dependency: `npm install node-fetch`.\n- Wrap calls in try/catch for retries or error handling.\n- For large payloads, consider streaming/parsing incrementally.", "category": "real_world", "language": "javascript"}
{"prompt": "Write JavaScript code to stream large uploads with retry support", "response": "javascript\n```javascript\nimport fetch from 'node-fetch';\nimport fs from 'fs';\n\nexport async function uploadWithRetry(url, filePath, maxRetries = 3) {\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      const stream = fs.createReadStream(filePath);\n      const resp = await fetch(url, { method: 'POST', body: stream });\n      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);\n      return await resp.text();\n    } catch (err) {\n      if (attempt === maxRetries) throw err;\n      await new Promise(res => setTimeout(res, 200 * 2 ** attempt));\n    }\n  }\n}\n```\n**Explanation:** Streams a file to an HTTP endpoint with exponential backoff on failure. Retries a limited number of times, returning the response text on success or rethrowing after exhaustion.\n**Complexity:** Time: O(retries * upload_time); Space: O(chunk_size) buffered by streams.\n**Example:**\nInput: `await uploadWithRetry('https://example.com/upload', 'video.mp4')`\nOutput: server response body\n**Notes:**\n- Install `node-fetch`; ensure file path is valid.\n- Add content-type headers if required by the server.\n- For large uploads, consider resumable protocols; this does full retries.", "category": "real_world", "language": "javascript"}
{"prompt": "Write JavaScript code to process image uploads and generate thumbnails", "response": "javascript\n```javascript\nimport sharp from 'sharp';\nimport fs from 'fs/promises';\n\nexport async function processImage(inputPath, outputPath, width = 200, height = 200) {\n  const buffer = await fs.readFile(inputPath);\n  const processed = await sharp(buffer).resize(width, height).toFormat('jpeg').toBuffer();\n  await fs.writeFile(outputPath, processed);\n}\n```\n**Explanation:** Reads an image, uses `sharp` to resize it to the given dimensions, converts to JPEG, and writes the thumbnail to the output path.\n**Complexity:** Time: O(image_size) for processing; Space: O(image_size) for buffers.\n**Example:**\nInput: processImage('in.png', 'thumb.jpg', 100, 100)\nOutput: Writes a 100x100 JPEG thumbnail\n**Notes:**\n- Install sharp: `npm install sharp`.\n- Adjust format/compression options as needed.\n- Handle errors (I/O, decoding) at the call site with try/catch.", "category": "real_world", "language": "javascript"}
{"prompt": "Write Python code to create a simple web scraper", "response": "python\n```python\nimport requests\nfrom bs4 import BeautifulSoup\n\n\ndef scrape_titles(url: str) -> list[str]:\n    resp = requests.get(url, timeout=10)\n    resp.raise_for_status()\n    soup = BeautifulSoup(resp.text, \"html.parser\")\n    return [a.get_text(strip=True) for a in soup.find_all(\"a\")]\n```\n**Explanation:** Fetches a page, parses HTML with BeautifulSoup, and extracts anchor text into a list. Raises for HTTP errors and uses a 10s timeout.\n**Complexity:** Time: O(page_size); Space: O(page_size) for parsed DOM plus output list.\n**Example:**\nInput: scrape_titles(\"https://example.com\")\nOutput: [\"More information...\"]\n**Notes:**\n- Install dependencies: `pip install requests beautifulsoup4`.\n- Respect robots.txt and site terms when scraping.\n- Adjust selectors to target specific elements (e.g., headlines).", "category": "real_world", "language": "python"}
