java
```java
import java.util.ArrayList;
import java.util.EmptyStackException;

public class Stack<T> {
    private final ArrayList<T> data = new ArrayList<>();

    public void push(T value) {
        data.add(value);
    }

    public T pop() {
        if (data.isEmpty()) throw new EmptyStackException();
        return data.remove(data.size() - 1);
    }

    public T peek() {
        if (data.isEmpty()) throw new EmptyStackException();
        return data.get(data.size() - 1);
    }

    public boolean isEmpty() {
        return data.isEmpty();
    }

    public int search(T value) {
        // returns 1-based position from the top, -1 if not found (mimics java.util.Stack)
        for (int i = data.size() - 1, pos = 1; i >= 0; i--, pos++) {
            if ((value == null && data.get(i) == null) || (value != null && value.equals(data.get(i)))) {
                return pos;
            }
        }
        return -1;
    }
}
```
**Explanation:** Wraps an `ArrayList` to provide stack semantics. Push appends; pop and peek operate on the last element, throwing when empty. `search` walks downward from the top to find a value, returning its 1-based offset similar to `java.util.Stack`.
**Complexity:** Time: O(1) for push/pop/peek, O(n) for search; Space: O(n).
**Example:**
Input: push 1, push 2, peek -> 2, pop -> 2
Output: stack contains [1]
**Notes:**
- Not thread-safe; synchronize externally if needed.
- Accepts null values; equality check handles null safely.
- For capacity-sensitive use, consider pre-sizing the ArrayList.
