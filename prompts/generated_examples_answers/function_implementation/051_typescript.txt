typescript
```typescript
// Debounce an async function; returns a wrapper that resolves with the inner result
function debounceAsync<T extends (...args: any[]) => Promise<any>>(fn: T, wait: number) {
  let timer: NodeJS.Timeout | null = null;
  let pendingReject: ((reason?: any) => void) | null = null;

  return (...args: Parameters<T>): Promise<ReturnType<T>> => {
    if (timer) clearTimeout(timer);
    if (pendingReject) {
      pendingReject(new Error('debounced'));
      pendingReject = null;
    }
    return new Promise((resolve, reject) => {
      pendingReject = reject;
      timer = setTimeout(async () => {
        timer = null;
        pendingReject = null;
        try {
          const result = await fn(...args);
          resolve(result as ReturnType<T>);
        } catch (err) {
          reject(err);
        }
      }, wait);
    });
  };
}
```
**Explanation:** Returns a wrapper that resets a timer on each call; only the final call within the `wait` window executes `fn`. Previous pending promises are rejected to signal cancellation. Errors from `fn` propagate via promise rejection.
**Complexity:** Time: O(1) per call; Space: O(1) for timer state.
**Example:**
Input: Rapid calls to `debounceAsync(fetchData, 300)`
Output: Only the last invocation triggers `fetchData`; earlier calls reject with `debounced`.
**Notes:**
- Adjust cancellation behavior if you prefer silent drops instead of rejection.
- Works in Node; swap timer types for browser if needed.
- Ensure `fn` is idempotent if multiple callers may race.
