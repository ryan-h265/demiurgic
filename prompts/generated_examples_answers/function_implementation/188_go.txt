go
```go
package main

import (
	"fmt"
	"math"
	"net/http"
	"time"
)

// GetWithBackoff performs an HTTP GET with exponential backoff retries.
func GetWithBackoff(url string, maxRetries int, baseDelay time.Duration) (*http.Response, error) {
	client := &http.Client{Timeout: 10 * time.Second}
	for attempt := 0; attempt <= maxRetries; attempt++ {
		resp, err := client.Get(url)
		if err == nil && resp.StatusCode < 500 {
			return resp, nil
		}
		if resp != nil {
			resp.Body.Close()
		}
		if attempt == maxRetries {
			return nil, fmt.Errorf("request failed after %d attempts: %w", attempt+1, err)
		}
		delay := time.Duration(float64(baseDelay) * math.Pow(2, float64(attempt)))
		time.Sleep(delay)
	}
	return nil, fmt.Errorf("unreachable code")
}
```
**Explanation:** Attempts the GET request up to `maxRetries + 1` times, doubling the delay after each failure. Treats 5xx or network errors as retryable, closing bodies before retrying. Returns on first success or after exhausting retries.
**Complexity:** Time: O(retries * request_time); Space: O(1) auxiliary.
**Example:**
Input: GetWithBackoff("https://example.com", 3, 200*time.Millisecond)
Output: HTTP response or error after retries
**Notes:**
- Add jitter to backoff to avoid synchronized retries.
- Tighten retry logic to specific status codes/exceptions based on your needs.
- Caller owns the response body; remember to close it when done.
