c++
```cpp
#include <vector>
#include <stdexcept>

class SegmentTree {
public:
    explicit SegmentTree(const std::vector<int>& nums) : n_(nums.size()), tree_(2 * nums.size()) {
        for (size_t i = 0; i < n_; ++i) tree_[n_ + i] = nums[i];
        for (size_t i = n_ - 1; i > 0; --i) tree_[i] = tree_[i << 1] + tree_[i << 1 | 1];
    }

    void update(size_t idx, int val) {
        if (idx >= n_) throw std::out_of_range("index");
        size_t i = idx + n_;
        tree_[i] = val;
        while (i > 1) {
            i >>= 1;
            tree_[i] = tree_[i << 1] + tree_[i << 1 | 1];
        }
    }

    int query(size_t l, size_t r) const {
        if (l > r || r >= n_) throw std::out_of_range("range");
        l += n_; r += n_;
        int res = 0;
        while (l <= r) {
            if (l & 1) res += tree_[l++];
            if (!(r & 1)) res += tree_[r--];
            l >>= 1; r >>= 1;
        }
        return res;
    }

private:
    size_t n_;
    std::vector<int> tree_;
};
```
**Explanation:** Iterative segment tree for range sums with point updates. Leaves start at offset n; parents store child sums. Updates refresh ancestors; queries walk two pointers inward to accumulate sums.
**Complexity:** Time: O(log n) per update/query; Space: O(n).
**Example:**
Input: nums=[1,3,5], query(0,2)
Output: 9
**Notes:**
- Adjust merge function for min/max as needed.
- Include bounds checks (provided) to avoid invalid access.
- Use larger integer types if sums may overflow int.
