java
```java
public class CircularSegmentTree {
    private final int n;
    private final int[] tree;
    private int head = 0; // next write position
    private int size = 0;

    public CircularSegmentTree(int capacity) {
        if (capacity <= 0) throw new IllegalArgumentException("capacity must be positive");
        this.n = capacity;
        this.tree = new int[2 * n];
    }

    public void push(int value) {
        int pos = (head + size) % n;
        if (size == n) {
            // overwrite oldest at head
            pos = head;
            head = (head + 1) % n;
        } else {
            size++;
        }
        updatePhysical(pos, value);
    }

    public void updateLogical(int idx, int value) {
        if (idx < 0 || idx >= size) throw new IndexOutOfBoundsException();
        int pos = (head + idx) % n;
        updatePhysical(pos, value);
    }

    public int rangeSum(int l, int r) {
        if (l < 0 || r >= size || l > r) throw new IndexOutOfBoundsException();
        int start = (head + l) % n;
        int end = (head + r) % n;
        if (start <= end) return query(start, end);
        return query(start, n - 1) + query(0, end);
    }

    private void updatePhysical(int pos, int value) {
        int i = pos + n;
        tree[i] = value;
        while (i > 1) {
            i >>= 1;
            tree[i] = tree[i << 1] + tree[i << 1 | 1];
        }
    }

    private int query(int l, int r) {
        l += n; r += n;
        int res = 0;
        while (l <= r) {
            if ((l & 1) == 1) res += tree[l++];
            if ((r & 1) == 0) res += tree[r--];
            l >>= 1; r >>= 1;
        }
        return res;
    }
}
```
**Explanation:** Fixed-capacity ring buffer backed by a segment tree for range sums. `push` overwrites the oldest when full. Logical indices offset from `head` map to physical positions for updates and queries; wrapped ranges are split into two queries.
**Complexity:** Time: O(log n) for push/update/query; Space: O(n) for the tree.
**Example:**
Input: capacity=3; push 1,2,3; rangeSum(0,2)=6; push 4 (overwrites 1); rangeSum(0,2)=9
Output: sums as shown
**Notes:**
- Adjust merge operation for min/max as needed.
- If overwriting is undesirable, throw when size==capacity instead.
- Ensure callers respect current `size` when querying logical indices.
