rust
```rust
pub struct SegmentTree {
    n: usize,
    tree: Vec<i64>,
}

impl SegmentTree {
    pub fn new(nums: &[i64]) -> Self {
        let n = nums.len();
        let mut tree = vec![0; 2 * n];
        tree[n..n + n].copy_from_slice(nums);
        for i in (1..n).rev() {
            tree[i] = tree[i << 1] + tree[i << 1 | 1];
        }
        Self { n, tree }
    }

    pub fn update(&mut self, idx: usize, val: i64) {
        let mut i = idx + self.n;
        self.tree[i] = val;
        i >>= 1;
        while i > 0 {
            self.tree[i] = self.tree[i << 1] + self.tree[i << 1 | 1];
            i >>= 1;
        }
    }

    pub fn query(&self, l: usize, r: usize) -> i64 {
        let (mut l, mut r) = (l + self.n, r + self.n);
        let mut res = 0;
        while l <= r {
            if l & 1 == 1 { res += self.tree[l]; l += 1; }
            if r & 1 == 0 { res += self.tree[r]; r -= 1; }
            l >>= 1; r >>= 1;
        }
        res
    }
}
```
**Explanation:** Iterative segment tree for range sums with point updates. Leaves at offset n; parents store child sums. Updates bubble changes up; queries walk two pointers inward to accumulate results.
**Complexity:** Time: O(log n) per update/query; Space: O(n).
**Example:**
Input: nums=[1,3,5], query(0,2)
Output: 9
**Notes:**
- Change merge op for min/max as needed.
- Indices are zero-based and inclusive for queries.
- Ensure bounds checking in production code.
