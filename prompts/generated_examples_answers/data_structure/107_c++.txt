c++
```cpp
#include <vector>
#include <numeric>
#include <mutex>

class ThreadSafeDSU {
public:
    explicit ThreadSafeDSU(int n) : parent_(n), rank_(n, 0) {
        std::iota(parent_.begin(), parent_.end(), 0);
    }

    int find(int x) {
        std::lock_guard<std::mutex> lg(mu_);
        return findLocked(x);
    }

    void unite(int a, int b) {
        std::lock_guard<std::mutex> lg(mu_);
        a = findLocked(a);
        b = findLocked(b);
        if (a == b) return;
        if (rank_[a] < rank_[b]) std::swap(a, b);
        parent_[b] = a;
        if (rank_[a] == rank_[b]) rank_[a]++;
    }

private:
    int findLocked(int x) {
        if (parent_[x] != x) parent_[x] = findLocked(parent_[x]);
        return parent_[x];
    }

    std::vector<int> parent_;
    std::vector<int> rank_;
    std::mutex mu_;
};
```
**Explanation:** Wraps standard union-find with a mutex to serialize access, ensuring thread-safe path compression and union-by-rank operations.
**Complexity:** Time: Amortized ~O(Î±(n)) per op; Space: O(n).
**Example:**
Input: unite(0,1); unite(2,3); find(3)
Output: representative of set containing 3
**Notes:**
- Coarse-grained locking keeps it simple; finer-grained locks could allow more concurrency.
- Validate indices in production.
- Keep critical sections small to avoid contention.
