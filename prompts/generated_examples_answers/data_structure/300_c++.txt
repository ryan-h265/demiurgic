c++
```cpp
#include <vector>
#include <numeric>

class UnionFind {
public:
    explicit UnionFind(int n) : parent_(n), rank_(n, 0) {
        std::iota(parent_.begin(), parent_.end(), 0);
    }
    int find(int x) {
        if (parent_[x] != x) parent_[x] = find(parent_[x]);
        return parent_[x];
    }
    void unite(int a, int b) {
        a = find(a); b = find(b);
        if (a == b) return;
        if (rank_[a] < rank_[b]) std::swap(a, b);
        parent_[b] = a;
        if (rank_[a] == rank_[b]) rank_[a]++;
    }
private:
    std::vector<int> parent_;
    std::vector<int> rank_;
};
```
**Explanation:** Classic disjoint-set union with path compression and union by rank to keep trees shallow, delivering near-constant-time operations for connectivity queries.
**Complexity:** Time: Amortized ~O(Î±(n)); Space: O(n).
**Example:**
Input: unite(0,1); unite(2,3); find(3)
Output: representative of set containing 3
**Notes:**
- Capacity fixed at construction; recreate to expand.
- Add `connected(a,b)` helper for convenience.
- Not thread-safe; add synchronization if shared across threads.
