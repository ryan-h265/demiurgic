javascript
```javascript
class TrieNode {
  constructor() {
    this.children = new Map();
    this.end = false;
    this.minChar = null;
    this.maxChar = null;
  }
}

class Trie {
  constructor() {
    this.root = new TrieNode();
  }
  insert(word) {
    let node = this.root;
    for (const ch of word) {
      if (!node.children.has(ch)) node.children.set(ch, new TrieNode());
      if (node.minChar === null || ch < node.minChar) node.minChar = ch;
      if (node.maxChar === null || ch > node.maxChar) node.maxChar = ch;
      node = node.children.get(ch);
    }
    node.end = true;
  }
  contains(word) {
    let node = this.root;
    for (const ch of word) {
      if (!node.children.has(ch)) return false;
      node = node.children.get(ch);
    }
    return node.end;
  }
  // O(1) access to min/max starting chars stored at root
  minStart() { return this.root.minChar; }
  maxStart() { return this.root.maxChar; }
}
```
**Explanation:** Standard trie storing children per node. Tracks minimum and maximum starting characters at each node during insertion, allowing O(1) retrieval of min/max starting edges. Supports word insertion and membership checks.
**Complexity:** Time: O(L) per insert/lookup; Space: O(total characters).
**Example:**
Input: insert('cat'), insert('dog'); minStart() -> 'c', maxStart() -> 'd'
Output: min/max reflect lexicographic extremes of stored words.
**Notes:**
- Extend min/max tracking deeper if you need prefix-specific extremes.
- Replace Map with arrays for fixed alphabets for speed.
- Add delete and prefix search as needed.
