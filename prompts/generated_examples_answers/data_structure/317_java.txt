java
```java
import java.util.function.BiFunction;

public class SegmentTree {
    private final int n;
    private final int[] tree;

    public SegmentTree(int[] nums) {
        this.n = nums.length;
        this.tree = new int[2 * n];
        System.arraycopy(nums, 0, tree, n, n);
        for (int i = n - 1; i > 0; i--) {
            tree[i] = tree[2 * i] + tree[2 * i + 1];
        }
    }

    public synchronized void update(int idx, int val) {
        int i = idx + n;
        tree[i] = val;
        for (i >>= 1; i > 0; i >>= 1) {
            tree[i] = tree[2 * i] + tree[2 * i + 1];
        }
    }

    public synchronized int rangeSum(int l, int r) {
        l += n; r += n;
        int res = 0;
        while (l <= r) {
            if ((l & 1) == 1) res += tree[l++];
            if ((r & 1) == 0) res += tree[r--];
            l >>= 1; r >>= 1;
        }
        return res;
    }
}
```
**Explanation:** Coarse-grained synchronized segment tree supporting point updates and range sum queries. Leaves start at `n`; parents aggregate child sums upward.
**Complexity:** Time: O(log n) per update/query; Space: O(n).
**Example:**
Input: nums=[1,3,5], rangeSum(0,2)
Output: 9
**Notes:**
- Replace sum with another associative operation if needed.
- Synchronization is simple but blocks concurrent reads/writes; use finer locks if necessary.
- Validate indices in production code.
