rust
```rust
use std::collections::BTreeMap;

pub struct TrieNode {
    children: BTreeMap<char, TrieNode>,
    end: bool,
}

impl TrieNode {
    fn new() -> Self { Self { children: BTreeMap::new(), end: false } }
}

pub struct Trie {
    root: TrieNode,
}

impl Trie {
    pub fn new() -> Self { Self { root: TrieNode::new() } }

    pub fn insert(&mut self, word: &str) {
        let mut node = &mut self.root;
        for ch in word.chars() {
            node = node.children.entry(ch).or_insert_with(TrieNode::new);
        }
        node.end = true;
    }

    pub fn contains(&self, word: &str) -> bool {
        let mut node = &self.root;
        for ch in word.chars() {
            if let Some(next) = node.children.get(&ch) {
                node = next;
            } else {
                return false;
            }
        }
        node.end
    }

    pub fn min_char(&self) -> Option<char> {
        self.root.children.keys().next().copied()
    }
    pub fn max_char(&self) -> Option<char> {
        self.root.children.keys().next_back().copied()
    }
}
```
**Explanation:** Standard trie backed by ordered `BTreeMap` for children, enabling O(1) access (via first/last key) to the minimum/maximum starting character. Supports insertion and membership checks.
**Complexity:** Time: O(L) per insert/lookup; Space: O(total characters stored).
**Example:**
Input: insert("cat"), insert("dog"); min_char()->'c', max_char()->'d'
Output: min/max starting characters
**Notes:**
- For deeper min/max per prefix, descend storing additional metadata.
- Replace `BTreeMap` with arrays for fixed alphabets to improve speed and memory.
- Add delete and prefix search as needed.
