rust
```rust
use std::collections::BTreeMap;

pub struct TrieNode {
    children: BTreeMap<char, TrieNode>,
    end: bool,
}

impl TrieNode {
    fn new() -> Self { Self { children: BTreeMap::new(), end: false } }
}

pub struct Trie {
    root: TrieNode,
}

impl Trie {
    pub fn new() -> Self { Self { root: TrieNode::new() } }

    pub fn insert(&mut self, word: &str) {
        let mut node = &mut self.root;
        for ch in word.chars() {
            node = node.children.entry(ch).or_insert_with(TrieNode::new);
        }
        node.end = true;
    }

    pub fn iter<'a>(&'a self) -> impl Iterator<Item = String> + 'a {
        let mut stack: Vec<(String, &TrieNode)> = Vec::new();
        stack.push((String::new(), &self.root));
        std::iter::from_fn(move || {
            while let Some((prefix, node)) = stack.pop() {
                if node.end {
                    return Some(prefix);
                }
                for (&ch, child) in node.children.iter().rev() {
                    let mut next = prefix.clone();
                    next.push(ch);
                    stack.push((next, child));
                }
            }
            None
        })
    }
}
```
**Explanation:** Implements a trie with insertion and a lazy iterator that yields stored words via an explicit stack. Uses `BTreeMap` for ordered children; iterator clones prefixes as it traverses.
**Complexity:** Time: O(L) insert; iteration O(total characters); Space: O(total characters) for storage plus O(h) stack during iteration.
**Example:**
Input: insert("cat"), insert("car"); iter() yields "car", "cat" (order depends on iteration order)
Output: as described
**Notes:**
- Adjust iteration order by changing the traversal of `children`.
- For memory efficiency, yield references to characters with lifetimes instead of owning Strings, at the cost of ergonomics.
- Add search/prefix methods as needed.
