c++
```cpp
#include <vector>
#include <numeric>

class DisjointSet {
public:
    explicit DisjointSet(int n) : parent_(n), rank_(n, 0) {
        std::iota(parent_.begin(), parent_.end(), 0);
    }
    int find(int x) {
        if (parent_[x] != x) parent_[x] = find(parent_[x]);
        return parent_[x];
    }
    bool unite(int a, int b) {
        a = find(a); b = find(b);
        if (a == b) return false;
        if (rank_[a] < rank_[b]) std::swap(a, b);
        parent_[b] = a;
        if (rank_[a] == rank_[b]) rank_[a]++;
        return true;
    }
private:
    std::vector<int> parent_;
    std::vector<int> rank_;
};
```
**Explanation:** Implements union-find with path compression and union by rank to maintain shallow trees, enabling near-constant-time union/find operations.
**Complexity:** Time: Amortized ~O(Î±(n)) per op; Space: O(n).
**Example:**
Input: unite(0,1); unite(2,3); find(3)
Output: representative of set containing 3
**Notes:**
- Fixed capacity set at construction; resize by creating a new instance.
- Thread-safety not provided; wrap calls with locks if accessed concurrently.
- Add `connected(a,b)` helper for convenience.
