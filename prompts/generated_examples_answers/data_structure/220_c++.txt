c++
```cpp
#include <vector>
#include <stdexcept>

// Circular buffer with range-sum queries and point updates using a segment tree.
class CircularBuffer {
public:
    explicit CircularBuffer(size_t capacity)
        : n_(capacity), data_(capacity, 0), seg_(capacity * 2, 0), head_(0), size_(0) {
        if (capacity == 0) throw std::invalid_argument("capacity must be > 0");
    }

    void push(int value) {
        size_t idx = (head_ + size_) % n_;
        if (size_ == n_) { // overwrite oldest
            updateInternal(idx, value);
            head_ = (head_ + 1) % n_;
        } else {
            data_[idx] = value;
            updateInternal(idx, value);
            size_++;
        }
    }

    // Range sum on logical indices [l, r] within current size, with wrap handled.
    int rangeSum(size_t l, size_t r) const {
        if (l > r || r >= size_) throw std::out_of_range("invalid range");
        // map logical indices to physical positions
        size_t start = (head_ + l) % n_;
        size_t end = (head_ + r) % n_;
        if (start <= end) return query(start, end);
        // wrapped: sum start..n-1 plus 0..end
        return query(start, n_ - 1) + query(0, end);
    }

    void updateLogical(size_t idx, int value) {
        if (idx >= size_) throw std::out_of_range("invalid index");
        size_t pos = (head_ + idx) % n_;
        updateInternal(pos, value);
    }

private:
    size_t n_;
    std::vector<int> data_;
    std::vector<int> seg_;
    size_t head_, size_;

    void build() {
        for (size_t i = 0; i < n_; i++) seg_[n_ + i] = data_[i];
        for (size_t i = n_ - 1; i > 0; i--) seg_[i] = seg_[i << 1] + seg_[i << 1 | 1];
    }

    void updateInternal(size_t pos, int value) {
        data_[pos] = value;
        size_t i = n_ + pos;
        seg_[i] = value;
        while (i > 1) {
            i >>= 1;
            seg_[i] = seg_[i << 1] + seg_[(i << 1) | 1];
        }
    }

    int query(size_t l, size_t r) const {
        int res = 0;
        for (l += n_, r += n_; l <= r; l >>= 1, r >>= 1) {
            if (l & 1) res += seg_[l++];
            if (!(r & 1)) res += seg_[r--];
        }
        return res;
    }
};
```
**Explanation:** Maintains a fixed-size ring buffer and a segment tree for point updates and range-sum queries. Logical indices are offset by the head pointer to support wrap-around; queries split into up to two ranges when they wrap the physical array.
**Complexity:** Time: O(log n) for push (overwrite/update), updateLogical, and rangeSum; Space: O(n) for storage and tree.
**Example:**
Input: capacity=4; push 1,2,3,4; rangeSum(1,3)
Output: 9 (2+3+4)
**Notes:**
- Push overwrites the oldest element when full; adjust policy if eviction should fail instead.
- Initialization builds the segment tree lazily via updates; call build() if bulk-loading data.
- Convert to other aggregate functions by changing the merge operation.
