go
```go
package main

import (
	"container/heap"
	"math"
)

type Node struct {
	id     int
	x, y   int
	cost   float64
	index  int
	parent *Node
}

type PriorityQueue []*Node

func (pq PriorityQueue) Len() int { return len(pq) }
func (pq PriorityQueue) Less(i, j int) bool { return pq[i].cost < pq[j].cost }
func (pq PriorityQueue) Swap(i, j int) {
	pq[i], pq[j] = pq[j], pq[i]
	pq[i].index = i; pq[j].index = j
}
func (pq *PriorityQueue) Push(x interface{}) { *pq = append(*pq, x.(*Node)) }
func (pq *PriorityQueue) Pop() interface{} {
	old := *pq
	n := len(old)
	item := old[n-1]
	*pq = old[:n-1]
	return item
}

func heuristic(a, b *Node) float64 {
	dx := float64(a.x - b.x)
	dy := float64(a.y - b.y)
	return math.Abs(dx) + math.Abs(dy) // Manhattan
}

// AStar runs A* search on a grid graph described by walkable matrix.
func AStar(grid [][]int, start, goal [2]int) []*Node {
	rows, cols := len(grid), len(grid[0])
	nodes := make([][]*Node, rows)
	for i := range nodes {
		nodes[i] = make([]*Node, cols)
	}
	var goalNode *Node
	id := 0
	for r := 0; r < rows; r++ {
		for c := 0; c < cols; c++ {
			nodes[r][c] = &Node{id: id, x: r, y: c, cost: math.Inf(1)}
			id++
		}
	}
	startNode := nodes[start[0]][start[1]]
	goalNode = nodes[goal[0]][goal[1]]

	open := PriorityQueue{}
	heap.Init(&open)
	startNode.cost = heuristic(startNode, goalNode)
	heap.Push(&open, startNode)
	gScore := map[*Node]float64{startNode: 0}
	cameFrom := map[*Node]*Node{}

	dirs := [][2]int{{1,0},{-1,0},{0,1},{0,-1}}

	for open.Len() > 0 {
		current := heap.Pop(&open).(*Node)
		if current == goalNode {
			return reconstructPath(cameFrom, current)
		}
		for _, d := range dirs {
			nr, nc := current.x+d[0], current.y+d[1]
			if nr < 0 || nr >= rows || nc < 0 || nc >= cols || grid[nr][nc] == 1 {
				continue
			}
			neighbor := nodes[nr][nc]
			tentative := gScore[current] + 1
			if g, ok := gScore[neighbor]; !ok || tentative < g {
				cameFrom[neighbor] = current
				gScore[neighbor] = tentative
				neighbor.cost = tentative + heuristic(neighbor, goalNode)
				heap.Push(&open, neighbor)
			}
		}
	}
	return nil // no path
}

func reconstructPath(prev map[*Node]*Node, current *Node) []*Node {
	path := []*Node{current}
	for p := prev[current]; p != nil; p = prev[p] {
		path = append(path, p)
	}
	for i, j := 0, len(path)-1; i < j; i, j = i+1, j-1 {
		path[i], path[j] = path[j], path[i]
	}
	return path
}
```
**Explanation:** Represents grid cells as nodes, uses a min-heap priority queue ordered by f = g + h (gScore + Manhattan heuristic). Expands neighbors skipping walls (grid value 1). Tracks predecessors to reconstruct the path when the goal is dequeued.
**Complexity:** Time: O(E log V); Space: O(V) for scores, heap, and path.
**Example:**
Input: 0/1 grid with start (0,0) and goal (1,1)
Output: Shortest walkable path as a list of nodes
**Notes:**
- Heuristic assumes 4-neighbor grid; adjust for diagonals.
- For weighted grids, add edge weights to gScore increments.
- Validate bounds and walkability before running.
