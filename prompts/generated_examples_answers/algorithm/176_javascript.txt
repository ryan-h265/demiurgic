javascript
```javascript
function solveNQueens(n) {
  const solutions = [];
  const cols = new Set();
  const diag1 = new Set(); // r - c
  const diag2 = new Set(); // r + c
  const board = Array.from({ length: n }, () => Array(n).fill('.'));

  function backtrack(r) {
    if (r === n) {
      solutions.push(board.map(row => row.join('')));
      return;
    }
    for (let c = 0; c < n; c++) {
      if (cols.has(c) || diag1.has(r - c) || diag2.has(r + c)) continue;
      cols.add(c); diag1.add(r - c); diag2.add(r + c);
      board[r][c] = 'Q';
      backtrack(r + 1);
      board[r][c] = '.';
      cols.delete(c); diag1.delete(r - c); diag2.delete(r + c);
    }
  }

  backtrack(0);
  return solutions;
}
```
**Explanation:** Backtracks row by row, placing queens only where columns and diagonals are unoccupied, tracked by three sets. On placing queens in all rows, records the board layout.
**Complexity:** Time: O(N!) in the worst case; Space: O(N) for recursion plus O(N) for tracking sets.
**Example:**
Input: n = 4
Output: [".Q..","...Q","Q...","..Q."], ["..Q.","Q...","...Q",".Q.."]
**Notes:**
- Uses string rows for readable solutions; adjust output as needed.
- Sets give O(1) threat checks; bitmasks can improve performance.
- Prune early by skipping attacked columns/diagonals.
