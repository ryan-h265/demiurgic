rust
```rust
pub fn merge_sort(arr: &mut [i32]) {
    let n = arr.len();
    if n <= 1 { return; }
    let mid = n / 2;
    merge_sort(&mut arr[..mid]);
    merge_sort(&mut arr[mid..]);
    let mut merged = arr.to_vec();
    let (left, right) = merged.split_at_mut(mid);
    left.copy_from_slice(&arr[..mid]);
    right.copy_from_slice(&arr[mid..]);
    merge(left, right, arr);
}

fn merge(left: &[i32], right: &[i32], out: &mut [i32]) {
    let (mut i, mut j, mut k) = (0, 0, 0);
    while i < left.len() && j < right.len() {
        if left[i] <= right[j] {
            out[k] = left[i]; i += 1;
        } else {
            out[k] = right[j]; j += 1;
        }
        k += 1;
    }
    while i < left.len() { out[k] = left[i]; i += 1; k += 1; }
    while j < right.len() { out[k] = right[j]; j += 1; k += 1; }
}
```
**Explanation:** Recursively splits the array, sorts halves, and merges them with a temporary buffer copied from the original. Stable and deterministic regardless of input order.
**Complexity:** Time: O(n log n); Space: O(n) for the buffer plus O(log n) stack.
**Example:**
Input: [5,2,4,6,1,3]
Output: [1,2,3,4,5,6]
**Notes:**
- For large inputs, consider iterative bottom-up merges to reduce recursion.
- To minimize allocations, reuse a scratch buffer across calls.
- Stable ordering keeps equal elements in their original relative order.
