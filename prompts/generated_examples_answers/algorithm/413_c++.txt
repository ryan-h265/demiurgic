c++
```cpp
#include <vector>
#include <numeric>

class UnionFind {
public:
    explicit UnionFind(int n) : parent_(n), rank_(n, 0) {
        std::iota(parent_.begin(), parent_.end(), 0);
    }
    int find(int x) {
        if (parent_[x] != x) parent_[x] = find(parent_[x]);
        return parent_[x];
    }
    void unite(int a, int b) {
        a = find(a); b = find(b);
        if (a == b) return;
        if (rank_[a] < rank_[b]) std::swap(a, b);
        parent_[b] = a;
        if (rank_[a] == rank_[b]) rank_[a]++;
    }
};
```
**Explanation:** Disjoint set union with path compression and union by rank for efficient connectivity queries.
**Complexity:** Time: Amortized ~O(Î±(n)) per op; Space: O(n).
**Example:**
Input: unite(0,1); unite(1,2); find(2)
Output: representative of merged set
**Notes:**
- Add `connected(a,b)` for readability.
- Capacity fixed at construction; reinitialize to grow.
- Not thread-safe; add locking for concurrent use.
