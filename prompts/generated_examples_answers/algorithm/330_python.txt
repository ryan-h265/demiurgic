python
```python
def max_subarray(nums):
    best = curr = nums[0]
    for n in nums[1:]:
        curr = max(n, curr + n)
        best = max(best, curr)
    return best
```
**Explanation:** Kadaneâ€™s algorithm keeps a running best ending at each position (`curr`) and tracks the global maximum (`best`). At each element, decide whether to start fresh or extend the current subarray.
**Complexity:** Time: O(n); Space: O(1).
**Example:**
Input: [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
**Notes:**
- Works even if all numbers are negative; returns the largest element.
- To recover indices, track start/end positions when updating best.
- Requires non-empty array; add guard if inputs may be empty.
