typescript
```typescript
class LRUCache<K, V> {
  private map = new Map<K, V>();
  constructor(private capacity: number) {
    if (capacity <= 0) throw new Error('capacity must be positive');
  }
  get(key: K): V | -1 {
    if (!this.map.has(key)) return -1;
    const val = this.map.get(key)!;
    this.map.delete(key);
    this.map.set(key, val); // refresh recency
    return val;
  }
  put(key: K, value: V): void {
    if (this.map.has(key)) this.map.delete(key);
    this.map.set(key, value);
    if (this.map.size > this.capacity) {
      const lruKey = this.map.keys().next().value;
      this.map.delete(lruKey);
    }
  }
}
```
**Explanation:** Uses `Map` insertion order to track recency. Access deletes and re-inserts the key to mark it as most recent; `put` evicts the oldest key when capacity is exceeded.
**Complexity:** Time: O(1) amortized for get/put; Space: O(capacity).
**Example:**
Input: cache.put(1,"a"), cache.put(2,"b"), cache.get(1), cache.put(3,"c"), cache.get(2)
Output: get(1) -> "a", get(2) -> -1
**Notes:**
- Works in modern runtimes where Map preserves insertion order.
- Add type guards or default values to avoid returning -1 with non-number V if desired.
- Eviction occurs immediately after any insertion that exceeds capacity.
