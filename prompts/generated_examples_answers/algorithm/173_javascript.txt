javascript
```javascript
function ladderLength(beginWord, endWord, wordList) {
  const dict = new Set(wordList);
  if (!dict.has(endWord)) return 0;
  const queue = [[beginWord, 1]];
  const visited = new Set([beginWord]);
  const alphabet = 'abcdefghijklmnopqrstuvwxyz';

  while (queue.length) {
    const [word, depth] = queue.shift();
    if (word === endWord) return depth;
    for (let i = 0; i < word.length; i++) {
      for (const ch of alphabet) {
        if (ch === word[i]) continue;
        const next = word.slice(0, i) + ch + word.slice(i + 1);
        if (dict.has(next) && !visited.has(next)) {
          visited.add(next);
          queue.push([next, depth + 1]);
        }
      }
    }
  }
  return 0;
}
```
**Explanation:** BFS explores one-letter transformations present in the dictionary, starting from `beginWord`. The first time `endWord` is dequeued yields the shortest ladder length. Visited set prevents revisiting words.
**Complexity:** Time: O(N * L * 26) where N is dictionary size and L word length; Space: O(N) for sets/queue.
**Example:**
Input: begin="hit", end="cog", list=["hot","dot","dog","lot","log","cog"]
Output: 5
**Notes:**
- Returns 0 if `endWord` not reachable or absent.
- For performance on large dictionaries, precompute wildcard patterns or use bidirectional BFS.
- Assumes all words have equal length; filter otherwise.
